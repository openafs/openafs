From: Marc Dionne <marc.dionne@your-file-system.com>
Date: Mon, 5 Jan 2015 07:17:14 -0500
Subject: Linux 3.19: struct nameidata becomes opaque

With kernel 3.19 struct nameidata becomes opaque.  As a result
we cannot rely on STRUCT_NAMEIDATA_HAS_PATH being true for
new kernels.

Rework the conditions here so that STRUCT_NAMEIDATA_HAS_PATH
is only tested when we're using a nameidata structure and
the result matters.

Also modify a configure test to use a nameidata pointer
instead of an actual structure.

Reviewed-on: http://gerrit.openafs.org/11648
Reviewed-by: Daria Brashear <shadow@your-file-system.com>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit 72e22eb00f641f137f7dbe4195d6d82f4a8addc9)

Change-Id: Ia794d9006a054d16a3b9e5b8ced55c798244d4c7
Reviewed-on: http://gerrit.openafs.org/11662
Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Daria Brashear <shadow@your-file-system.com>
Reviewed-by: Stephan Wiesand <stephan.wiesand@desy.de>
(cherry picked from commit 3da7b86c4ac998640b0b7ffd0e01613449d72e30)
---
 src/afs/LINUX/osi_compat.h | 16 ++++++++--------
 src/cf/linux-test4.m4      |  4 ++--
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 53b78b7..c1cdb19 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -475,23 +475,23 @@ afs_get_dentry_ref(struct nameidata *nd, struct vfsmount **mnt, struct dentry **
 #else
 afs_get_dentry_ref(afs_linux_path_t *path, struct vfsmount **mnt, struct dentry **dpp) {
 #endif
-#if defined(STRUCT_NAMEIDATA_HAS_PATH)
-# if defined(HAVE_LINUX_PATH_LOOKUP)
+#if defined(HAVE_LINUX_PATH_LOOKUP)
+# if defined(STRUCT_NAMEIDATA_HAS_PATH)
     *dpp = dget(nd->path.dentry);
     if (mnt)
 	*mnt = mntget(nd->path.mnt);
     path_put(&nd->path);
 # else
-    *dpp = dget(path->dentry);
-    if (mnt)
-	*mnt = mntget(path->mnt);
-    path_put(path);
-# endif
-#else
     *dpp = dget(nd->dentry);
     if (mnt)
 	*mnt = mntget(nd->mnt);
     path_release(nd);
+# endif
+#else
+    *dpp = dget(path->dentry);
+    if (mnt)
+	*mnt = mntget(path->mnt);
+    path_put(path);
 #endif
 }
 
diff --git a/src/cf/linux-test4.m4 b/src/cf/linux-test4.m4
index 5f5ec5c..604d380 100644
--- a/src/cf/linux-test4.m4
+++ b/src/cf/linux-test4.m4
@@ -278,9 +278,9 @@ AC_DEFUN([LINUX_IOP_I_PUT_LINK_TAKES_COOKIE], [
 #include <linux/namei.h>],
 [struct inode _inode;
 struct dentry _dentry;
-struct nameidata _nameidata;
+struct nameidata *_nameidata;
 void *cookie;
-(void)_inode.i_op->put_link(&_dentry, &_nameidata, cookie);],
+(void)_inode.i_op->put_link(&_dentry, _nameidata, cookie);],
 		       [IOP_PUT_LINK_TAKES_COOKIE],
 		       [define if your iops.put_link takes a cookie],
 		       [])
