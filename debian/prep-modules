#! /bin/sh
#
# Prepares to build kernel modules.  This script figures out and munges
# version strings.  The goal is:
#
#  * Set the package name to openafs-modules-$(KVERS) where $(KVERS) is the
#    major kernel revision plus the debian subrevision and whatever
#    architecture string is appropriate if building against the stock Debian
#    kernels.  $(KVERS) should be identical to the version component contained
#    in the Debian kernel package names.
#
#  * Make the package recommend either kernel-image-$(KVERS) or
#    linux-image-$(KVERS) as appropriate for the kernel version that we're
#    building against.  Use recommend rather than depends since the user may
#    have built their own kernel outside of the Debian package infrastructure.
#
#  * Save the version number of the binary package in debian/VERSION for later
#    use by dh_gencontrol.  This will be the version number of the source
#    package followed by a + and the version number of the kernel package that
#    we're building against.  If the kernel package version contains an epoch,
#    try to hack our way into doing the right thing by using that epoch number
#    as our own.  This isn't quite the right thing, but seems reasonably good.
#
# This script generates debian/control from debian/control.module using sed.
# Unfortunately, substvars cannot be used since the name of the package is
# modified and substvars happens too late.  It also outputs debian/VERSION,
# containing the version of the binary package.

set -e

if [ "$#" -ne 1 ]; then
    echo Usage: $0 kernelsource-location
    exit 1
fi

# We can get the kernel version from one of three places.  If KVERS and KDREV
# are both already set in the environment (which will be the case when invoked
# by make-kpkg or module-assistant), use them.  Otherwise, if we have a kernel
# source directory that contains debian/changelog (generated by make-kpkg),
# parse that file to find the version information.  Finally, if neither works,
# extract the kernel version from the kernel headers, append INT_SUBARCH to
# that version if it's available, and assume a kernel package revision of -0
# if none is provided.
#
# Set the variables $afs_kvers, which will hold the revision of the kernel,
# and $afs_kdrev, which will hold the version of the kernel package that we're
# building against.

changelog="$1/debian/changelog"
if [ -n "$KVERS" ] && [ -n "$KDREV" ]; then
    afs_kvers="${KVERS}${INT_SUBARCH}"
    afs_kdrev="${KDREV}"
elif [ ! -f "$changelog" ] ; then
    afs_kvers=`sh debian/kernel-version`
    if [ -z "$KDREV" ] ; then
        afs_kdrev="${afs_kvers}-0"
    else
        afs_kvers="${afs_kvers}${INT_SUBARCH}"
        afs_kdrev="${KDREV}"
    fi
else
    afs_kvers=`head -1 "$changelog" \
        | sed -e 's/.*source-\([^ ]*\) (\([^)]*\)).*/\1/'`
    afs_kdrev=`head -1 "$changelog" \
        | sed -e 's/.*source-\([^ ]*\) (\([^)]*\)).*/\2/'`
fi

# Determine the kernel package name.  For right now, assume linux-image for
# 2.6.12 and later, and kernel-image for anything earlier.  If this doesn't
# work for someone, please submit a bug with the details.

if dpkg --compare-versions "$afs_kvers" ge "2.6.12" ; then
    afs_image=linux-image
else
    afs_image=kernel-image
fi

# Generate the control file from the template.

sed -e "s/=KVERS/${afs_kvers}/g" -e "s/=IMG/${afs_image}/g" \
    debian/control.module > debian/control

# Now, calcuate the binary package version.  Extract the epoch from the kernel
# package revision and add it to the beginning of the binary package version
# if present.  Then, concatenate the source version, '+', and the kernel
# package revision without the epoch.

afs_version=`head -1 debian/changelog | sed -e 's/.*(\([^)]*\)).*/\1/'`
afs_epoch=`echo ${afs_kdrev} | sed -n -e 's/^\([0-9]*\):.*/\1/p'`
afs_version="${afs_version}+`echo ${afs_kdrev} | sed -e 's/^[0-9]*://'`"
if [ -n "$afs_epoch" ] ; then
    afs_version="${afs_epoch}:${afs_version}"
fi

echo "$afs_version" > debian/VERSION
