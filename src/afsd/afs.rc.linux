#! /bin/sh
# Modified by Sam Hartman <hartmans@mit.edu> for Debian
# Copyright 2000, International Business Machines Corporation and others.
# All Rights Reserved.
# 
# This software has been released under the terms of the IBM Public
# License.  For details, see the LICENSE file in the top-level source
# directory or online at http://www.openafs.org/dl/license10.html

# AFS	Start and stop AFS components
# 
# 
# chkconfig: 345 60 20
# description:  AFS is a distributed file system which provides location
#		transparency, caching and secure authentication.
#		Additional configuration can be done in the /etc/sysconfig/afs
#		file. Read the documentation in that file for more information.
#
# Note that AFS does not use a pid file in /var/run. It is turned off by
# unmounting /afs.

exec 3>/dev/null
exec </dev/null


# Gather up options and post startup script name, if present
if [ -f /etc/openafs/afs.conf ]; then
	. /etc/openafs/afs.conf
fi

# is_on returns 1 if value of arg is "true"
is_on() {
	if  test "$1" = "true" ; then return 0
	else return 1
	fi
}

# If choose_client can't correctly determine which client to use, set
# LIBAFS manually.
choose_client() {

	# Use the second field of the uname -v output instead of just
	# doing a match on the whole thing to protect against matching
	# a timezone named SMP -- I don't know of one, but let's be
	# paranoid.

	set X `uname -v`; shift
	case $2 in
	SMP) MP=.mp ;;	# MP system
	*)   MP= ;;	# SP system
	esac

	# For now, just use uname -r to get the module version. 
	VERSION=`uname -r`

        # The Debian OpenAFS packages do not add the .mp by default as of 1.3,
        # but modules obtained from other sources may.  If a module with the
        # .mp exists and this is an SMP system, use it; otherwise, use the
        # default value.  Unset $MP if not using it so that we can use it
        # later in the call to modprobe.
        if [ -n "$MP" -a -f "$MODLOADDIR/openafs${MP}.o" ] ; then
                LIBAFS=openafs${MP}.o
        elif [ -n "$MP" -a -f "$MODLOADDIR/openafs${MP}.ko" ] ; then
                LIBAFS=openafs${MP}.ko
        elif [ -f "$MODLOADDIR/openafs.ko" ] ; then
                MP=
                LIBAFS=openafs.ko
        else
                MP=
                LIBAFS=openafs.o
        fi
}

#
# Find prefix symbol to use with insmod.  We find the unregister_filesystem
# string from /proc/ksyms since we know it's there.  If /proc/ksyms does not
# exist, we print that info to the console and use the uname -v output to
# decide on a prefix.
# unregister_filesystem_Rsmp_b240cad8 is a typcial SMP version string from
# a kernel built from ftp.kernel.org
#

KSYMS_FILE=/proc/ksyms
SEARCH_STR="unregister_filesystem"
DEFAULT_SMP_PREFIX="smp_" # Redhat kernels need "smp" instead
PREFIX="" # none needed for UP with <= 1Gig memory

set_prefix()
{
	h='[0-9a-fA-F]'
	h8="$h$h$h$h$h$h$h$h"
	prefix_set=0

	set X `fgrep $SEARCH_STR $KSYMS_FILE 2> /dev/null`; shift
	str=$2
	case $str in
	${SEARCH_STR}_R$h8)
		# No prefix required
		;;
	$SEARCH_STR)
		# No versioning in kernel symbols
		;;
	${SEARCH_STR}_R*$h8)
		suffix=${str#${SEARCH_STR}_R}
		PREFIX=${suffix%$h8}
		;;
	*)
		case $str in
		'')
			echo afsd: Cannot find \"$SEARCH_STR\" in file $KSYMS_FILE
			;;
		*)
			echo afsd: Malformed kernel version symbol \"$str\"
			;;
		esac

		echo Guessing prefix from output of uname -v
		set X `uname -v`; shift
		case $2 in
		SMP)
			PREFIX=$DEFAULT_SMP_PREFIX
			;;
		esac
		;;
	esac
}


MODLOADDIR=/lib/modules/`uname -r`/fs
# load_client loads the AFS client module if it's not already loaded. 
load_client() {
	# If LIBAFS is set, use it.
	if [ -z "$LIBAFS" ] ; then
		# Try to determine the right client.
		choose_client
	fi
    
	if [ ! -f "$MODLOADDIR/$LIBAFS" ] ; then
                cat <<EOF
AFS module $MODLOADDIR/$LIBAFS does not exist.
Not starting AFS.  Please consider building kernel modules using
instructions in /usr/share/doc/openafs-client/README.modules
EOF
		exit 0
	fi

	# use the prefix command if required
#	set_prefix
	LOADED=`/sbin/lsmod | fgrep openafs`
	if [ -z "$LOADED" ] ; then
                modprobe openafs${MP}
	fi
}

# start_client() -- run afsd
start_client() {
    		if pidof /usr/sbin/afsd >/dev/null ; then : 
		    else
		    start-stop-daemon --start --quiet --exec /usr/sbin/afsd \
			-- ${OPTIONS}
		    echo -n " afsd"
		    fi
		if [ x$AFS_CRYPT = xtrue ] ; then
		    fs setcrypt on
		    fi
}


case "$1" in 
  start)
	# Load kernel extensions
	if  load_client  ; then :
	else
		echo Failed to load AFS client, not starting AFS services.
		exit 1
	fi

	# Start AFS client
	if  is_on $AFS_CLIENT && test -x /usr/sbin/afsd  ; then
	    echo -n "Starting AFS services: "
	start_client
		echo "."
		$AFS_POST_INIT
	fi

	;;

force-start)
	# Load kernel extensions
	if  load_client  ; then :
	else
		echo Failed to load AFS client, not starting AFS services.
		exit 1
	fi

	# Start AFS client
	if test -x /usr/sbin/afsd  ; then
	    echo -n "Starting AFS services: "
	start_client
		echo "."
		$AFS_POST_INIT
	fi
    	;;
  stop|force-stop)
	# Stop AFS
	echo -n "Stopping AFS services: "

	if  mount |grep -q \^AFS  ; then
		umount /afs
		echo -n " afsd"
	fi
	pidof /usr/sbin/afsd >/dev/null &&afsd -shutdown

	LIBAFS=`/sbin/lsmod | fgrep openafs`
	if [ -n "$LIBAFS" ] ; then
		LIBAFS=`echo $LIBAFS | awk 'BEGIN { FS = " " } { print $1 }'`
		/sbin/rmmod $LIBAFS
		echo -n " libafs"
	fi
	echo "."

	;;

  restart|force-reload)
	"$0" stop
	"$0" start
	;;

  *)
	echo Usage: 'openafs-client <start|stop>'

esac

