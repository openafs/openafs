<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    --> 
<BODY bgcolor="ffffff"> 
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<HR><H1><A NAME="HDRWQ174" HREF="auagd002.htm#ToC_201">볼륨 관리</A></H1>
<P>이 장에서는 파일 서버 시스템에 저장된 볼륨을 관리하는 방법을 설명합니다.
볼륨은 AFS에서 관리 단위로 지정되어 있으므로 이 작업은 관리자의 업무 중
많은 부분을 차지합니다.
<HR><H2><A NAME="HDRWQ175" HREF="auagd002.htm#ToC_202">명령어(instruction) 요약</A></H2>
<P>이 장에서는 지정된 명령을 사용하여 다음 타스크를 수행하는 방법을 설명합니다.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기/쓰기 볼륨 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos create</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기 전용 볼륨 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos addsite</B> <B>및</B> <B>vos release</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">백업 볼륨 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos backup</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">한 번에 여러 백업 볼륨 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos backupsys</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">VLDB 항목 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos listvldb</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 헤더 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos listvol</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">VLDB 항목과 볼륨 헤더 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos examine</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨의 이름 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs listquota</B> <B>또는</B> <B>fs examine</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 ID 번호 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs examine</B> <B>또는</B> <B>vos examine</B> <B>또는</B> <B>vos listvol</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">파티션 크기 및 여유 공간 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos partinfo</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 위치 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs whereis</B> <B>또는</B> <B>vos examine</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">마운트 포인트 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs mkmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">마운트 포인트 제거
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs rmmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">마운트 포인트 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs lsmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기/쓰기 볼륨 이동
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos move</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 헤더와 VLDB 동기화
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos syncvldb</B> <B>및</B> <B>vos syncserv</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 할당량 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs setvol</B> <B>또는</B> <B>fs setquota</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 할당량 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs quota</B> <B>또는</B> <B>fs listquota</B> <B>또는</B> <B>fs examine</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 현재 크기 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>fs listquota</B> <B>또는</B> <B>fs examine</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">시스템/파티션의 볼륨 목록 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos listvol</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기/쓰기 볼륨 제거
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos remove</B> <B>및</B> <B>fs rmmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기 전용 볼륨 제거
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos remove</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">백업 볼륨 제거
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos remove</B> <B>및</B> <B>fs rmmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 제거, VLDB 변경사항 없음
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos zap</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">읽기 전용 사이트 정의 제거
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos remsite</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">VLDB 항목 제거, 볼륨 변경사항 없음
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos delentry</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 덤프
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos dump</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">덤프된 볼륨 복원
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos restore</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 이름 변경
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos rename</B>, <B>fs rmmount</B> <B>및</B> <B>fs mkmount</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 잠금 해제
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos unlock</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">다중 볼륨 잠금 해제
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos unlockvldb</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">볼륨 잠금
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>vos lock</B>
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ177" HREF="auagd002.htm#ToC_203">볼륨에 대하여</A></H2>
<A NAME="IDX6430"></A>
<P>AFS <I>볼륨</I>은 AFS 디렉토리의 파일에 대한 컨테이너와
같이 기능하는 디스크 공간의 논리적 단위로 파일들을 파일 서버 시스템의
한 파티션에 모두 보관합니다. 볼륨의 내용을 셀의 파일 트리에서 볼 수 있게
하고 사용자가 액세스할 수 있게 하려면 AFS 파일 공간의 디렉토리 위치로
볼륨을 마운트해야 합니다. 볼륨과 파일 공간에서의 그 위치와의 관계를
<I>마운트 포인트</I>라고 합니다. 왜냐하면 볼륨이 작동하는
AFS 내부가 표준 디렉토리 요소와 같이 보이고 수행되기 때문입니다.
사용자는 표준 UNIX 디렉토리의 내용을 액세스하고 처리하는 것과 같은 방식으로
볼륨의 내용을 액세스하고 처리할 수 있습니다. 볼륨과 디렉토리 간의
관계에 대한 자세한 정보를 보려면 <A HREF="#HDRWQ183">볼륨 마운트에 대하여</A>를
참조하십시오.
<P>관리자들의 일상적인 작업 중 많은 부분은 기본적인 기억영역이며 AFS의
관리 단위인 볼륨을 처리하는 작업과 관련되어 있습니다. 볼륨이 어떤 방식으로
작업을 보다 용이하게 해줄 수 있는가에 대한 설명을 보려면
<A HREF="#HDRWQ179">볼륨이 AFS 효율을 높이는 방법</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ178" HREF="auagd002.htm#ToC_204">세 가지 유형의 볼륨</A></H3>
<P>AFS에는 다음 목록에서 설명하는 것처럼 세 가지 유형의 볼륨이 있습니다.
<UL>
<LI>단일 <I>읽기/쓰기</I> 버전의 볼륨은 볼륨에 수정할 수
있는 파일 및 디렉토리 버전이 들어 있습니다.
<A NAME="IDX6431"></A>
이
볼륨은 다른 두 가지 유형의 볼륨이 <I>클론</I>이라는
복사 절차로부터 이 볼륨에서 파생되기 때문에 <I>읽기/쓰기
원본</I>으로 참조됩니다. 읽기/쓰기 볼륨 작성에 대한 지침을 보려면
<A HREF="#HDRWQ185">읽기/쓰기 볼륨 작성</A>을 참조하십시오.
</LI><LI><I>읽기 전용</I> 볼륨은 읽기/쓰기 원본 볼륨의
사본이며 여러 <I>사이트</I>(사이트는 특정 파일 서버
시스템에 있는 특정 파티션임)에 존재할 수 있습니다.
<A NAME="IDX6432"></A>
<A NAME="IDX6433"></A>
<A NAME="IDX6434"></A>
 둘 이상의
사이트에 동일한 데이터를 배치하는 것을 <I>복제</I>라고
합니다. <A HREF="#HDRWQ179">볼륨이 AFS 효율을 높이는 방법</A>을 참조하십시오. 그 이름에서 알수 있듯이
읽기 전용 볼륨의 내용은 읽기/쓰기 원본이 변경될 때 자동으로 변경되지
않으며 관리자가 <B>vos release</B> 명령을 실행할 때만
변경됩니다.
사용자가 AFS 파일 공간을 일관된 형태로 볼 수 있으려면 모든 읽기 전용
볼륨 사본이 서로 그리고 읽기/쓰기 원본과 일치해야 합니다. 모든 읽기 전용
볼륨은 동일한 이름을 가지며 이 이름은 읽기/쓰기 원본 이름에
<B>.readonly</B> 확장자를 추가하여 생성됩니다. 읽기
전용 볼륨 작성에 대한 지침을 보려면 <A HREF="#HDRWQ192">볼륨 복제(읽기 전용 볼륨 작성)</A>를 참조하십시오.
</LI><LI><I>백업</I> 볼륨은 읽기/쓰기 원본 볼륨의 클론이로
원본과 동일한 사이트에 저장됩니다. 
<A NAME="IDX6435"></A>
백업 버전은 특정 시간에
읽기/쓰기 원본의 상태를 기록하기 때문에 나중에 실수로 변경되었거나 삭제된
데이터를 복구할 수 있게 하므로 유용합니다. (자세한 설명을 보려면
<A HREF="#HDRWQ179">볼륨이 AFS 효율을 높이는 방법</A>을 참조하십시오.) 백업 볼륨 이름은
<B>.backup</B> 확장자를 읽기/쓰기 원본 이름에 추가하여
생성됩니다. 백업 볼륨 작성에 대한 지침을 보려면 <A HREF="#HDRWQ201">백업 볼륨 작성</A>을
참조하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">백업 볼륨은 볼륨의 백업 버전이 보통 볼륨을 테이프로 백업하는
프로세스의 한 단계에 해당한다고 해도 AFS 백업 시스템을 사용하여 테이프에
전송되는 볼륨의 백업과 동일하지 않습니다.
AFS 백업 시스템을 사용한 볼륨 백업에 대한 정보를 보려면
<A HREF="auagd012.htm#HDRWQ296">데이터 백업</A>을 참조하십시오.
</TD></TR></TABLE>
</LI></UL>
<P>앞서 설명한 것처럼 세 가지 유형의 볼륨은 서로 관련되어 있습니다. 즉
읽기 전용 및 백업 볼륨은 모두 클론이라는 프로세스를 통해 읽기/쓰기 볼륨으로부터
생성된 것입니다. 읽기 전용 및 백업 볼륨은 작성되었을 때의 읽기/쓰기 원본의
정확한 사본에 해당합니다.
<P><H3><A NAME="HDRWQ179" HREF="auagd002.htm#ToC_205">볼륨이 AFS 효율을 높이는 방법</A></H3>
<A NAME="IDX6436"></A>
<P>볼륨을 사용하면 다음의 세 가지 방식으로 셀을 보다 쉽게 관리하고
보다 효율적으로 만들 수 있습니다.
<UL>
<LI>볼륨은 정의에 의하면 파티션보다 더 작으므로 동일하거나 다른 시스템의
파티션 간을 쉽게 이동합니다.
<A NAME="IDX6437"></A>
 볼륨을
이동하는 가장 일반적인 원인은 파일 서버 시스템 사이에서 로드 밸런스를
이루고 특정 시스템에서 좀더 확보된 디스크 용량을 활용하는 것입니다.
볼륨 이동 중에 몇 초 동안만 볼륨의 내용이 사용 불가능해지므로 볼륨 내용에
대한 사용자 액세스를 방해하지 않고 필요한 만큼 자주 볼륨을
이동할 수 있습니다. VLDB(Location Database)의 자동 볼륨 위치 추적
기능은 액세스가 가시적으로 유지되게 합니다. 볼륨 이동에 대한 지침을 보려면
<A HREF="#HDRWQ226">볼륨 이동</A>을 참조하십시오.
</LI><LI>볼륨은 AFS에서 복제본 단위입니다. 
<A NAME="IDX6438"></A>
<A NAME="IDX6439"></A>
<I>복제</I>는
읽기/쓰기 원본에서 읽기 전용 클론을 작성하고 클론을 하나 이상의 사이트에
분배하는 과정을 나타냅니다. 복제는 둘 이상의 시스템이 자주 사용되는
파일에 대한 요청을 받을 수 있으므로 시스템 효율을 높입니다.
또한 시스템 또는 서버 프로세스 작동 중단 상태에 직면했을 때 데이터를
사용 가능하게 유지하는 데 도움을 줌으로써 시스템 신뢰성도 높입니다.
일반적으로 자주 사용되는 응용 프로그램과 자주 변경되지 않는 파일을
포함하는 볼륨은 복제될 가능성이 가장 높지만 어떠한 읽기/쓰기 볼륨도
복제할 수 있습니다. <A HREF="#HDRWQ192">볼륨 복제(읽기 전용 볼륨 작성)</A>를 참조하십시오.
</LI><LI>볼륨은 두 가지 측면에서 AFS의 백업 단위입니다. 
<A NAME="IDX6440"></A>
백업 볼륨 버전을
작성하여 지정된 시간에 읽기/쓰기 원본 볼륨의 상태를 보존할 수 있습니다.
AFS 파일 공간에 백업 버전을 마운트하여 사용자들이 실수로 변경했거나
삭제한 데이터를 관리자의 도움을 받아 복원할 수 있게 하여 다른 중요한
작업에 좀더 시간을 할애할 수 있습니다. 하루에 한번씩 새로운 사용자 볼륨
백업 버전을 만드는 경우 (이전 백업을 덮어쓰는 것으로 가정) 사용자는 항상
전날의 파일 버전을 검색할 수 있습니다. 지침을 보려면 <A HREF="#HDRWQ201">백업 볼륨 작성</A>을
참조하십시오.
<P>
<P>백업은 또한 AFS 백업 시스템을 사용하여 볼륨의 내용 사본을 테이프나 특수 백업
데이터에 영구히 저장는 것을 나타내기도 합니다. <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및
<A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ180" HREF="auagd002.htm#ToC_206">VLDB의 볼륨 정보</A></H3>
<P>VLDB(Location Database)에는 셀의 모든 볼륨에 대한 항목이 들어
있습니다. 항목에서 가장 중요한 정보는 AFS 데이터를 가시적으로 액세스하는 데
있어서 핵심적인 요소인 볼륨 위치일 것입니다. 사용자가 파일을 열면
캐쉬 관리 프로그램은 VLDB를 유지 관리하는 볼륨 위치(VL) 서버에 해당 파일을
포함하는 볼륨이 있는 파일 서버 시스템의 목록을 문의합니다. 그런 다음 캐쉬
관리 프로그램은 해당 파일 서버 시스템에서 실행되는 파일 서버로부터 파일을
요청합니다. 파일 위치는 사용자가 볼 수 없으며 사용자는 파일의 경로 이름만
알면 됩니다.
<A NAME="IDX6441"></A>
<A NAME="IDX6442"></A>
<A NAME="IDX6443"></A>
<P>읽기/쓰기 볼륨에 대한 VLDB 볼륨 항목에는 자체의 VLDB 항목을 가지고 있지
않은 읽기 전용 및 백업 버전에 대한 정보도 들어 있습니다(드문 예외로
읽기 전용 원본이 제거되었으므로 자체의 VLDB 항목을 가지고 있는 읽기
전용 볼륨을 들 수 있습니다). 볼륨의 VLDB 항목은 볼륨 이름, 각
버전(읽기/쓰기, 읽기 전용, 백업 및 releaseClone)에 대한 고유한 볼륨 ID
번호, 읽기/쓰기 또는 읽기 전용 버전을 저장하는 사이트의 수, 사이트의
목록을 기록합니다.
<P>하나 이상의 볼륨에 대해 VLDB 항목을 표시하려면 <A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>에서
설명하는 것처럼 <B>vos listvldb</B> 명령을 사용하십시오.
그 볼륨 헤더와 함께 단일 볼륨에 대한 VLDB 항목을 표시하려면
<A HREF="#HDRWQ222">볼륨의 VLDB 항목 및 볼륨 헤더를 표시하려면</A>에서 설명하는 것처럼 <B>vos examine</B>
명령을 사용하십시오(볼륨 헤더에 대한 설명을 보려면 다음 절을 참조하십시오).
<P><H3><A NAME="HDRWQ181" HREF="auagd002.htm#ToC_207">볼륨 헤더의 정보</A></H3>
<A NAME="IDX6444"></A>
<A NAME="IDX6445"></A>
<P>볼륨의 모든 버전이 하나의 VLDB 항목을 공유하는 반면 한 AFS 서버 파티션의
각 볼륨은 볼륨의 파일 및 디렉토리를 이들이 저장되어 있는 파티션에 대한
실제 메모리 주소에 맵핑하는 데이터 구조인 자체의 <I>볼륨
헤더</I>를 가집니다. 볼륨 헤더는 볼륨을 연속 메모리 블록에 저장되도록
요구하지 않으면서 볼륨의 내용을 논리 장치로 바인드합니다. 볼륨 헤더는
또한 볼륨에 대한 다음 정보를 제공합니다. 일부 항목은 VLDB 항목과
중복됩니다.
이름, 볼륨 ID 번호, 유형, 크기, 상태(온라인, 오프라인, 사용중), 공간
할당량, 작성 날짜와 마지막 수정 날짜에 대한 시간 소인 및 현재 날짜 중의 액세스 횟수.
<P>하나 이상의 파티션에 볼륨 헤더를 표시하려면 <A HREF="#HDRWQ220">볼륨 헤더를 표시하려면</A>에서
설명하는 것처럼 <B>vos listvol</B> 명령을 사용하십시오.
그 볼륨 헤더와 함께 단일 볼륨에 대한 VLDB 항목을 표시하려면
<A HREF="#HDRWQ222">볼륨의 VLDB 항목 및 볼륨 헤더를 표시하려면</A>에서 설명하는 것처럼 <B>vos examine</B>
명령을 사용하십시오.
<P><H3><A NAME="HDRWQ182" HREF="auagd002.htm#ToC_208">VLDB 및 볼륨 헤더의 동기화 상태 유지</A></H3>
<A NAME="IDX6446"></A>
<A NAME="IDX6447"></A>
<A NAME="IDX6448"></A>
<A NAME="IDX6449"></A>
<A NAME="IDX6450"></A>
<A NAME="IDX6451"></A>
<P>VLDB의 정보는 서버에 있는 가능한한 많은 수의 실제 볼륨의 상태(볼륨 헤더에
기록)와 일치하는 것이 중요합니다. VLDB에 있는 볼륨의 위치 정보가 잘못되면
캐쉬 관리 프로그램은 그 내용을 액세스할 수 없습니다. 볼륨의 상태를 변경하는
<B>vos</B> 명령을 실행할 때마다 볼륨 서버와 VL 서버는
공조하여 볼륨 헤더와 VLDB를 동기화 상태로 유지합니다. 드문 경우지만
<B>vos</B> 조작이 미리 중단된 경우와 같이 헤더와 VLDB가
달라지는 상황도 발생할 수 있습니다. 이들의 재동기화에 대한 지침을 보려면
<A HREF="#HDRWQ227">VLDB 및 볼륨 헤더 동기화</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ183" HREF="auagd002.htm#ToC_209">볼륨 마운트에 대하여</A></H3>
<A NAME="IDX6452"></A>
<A NAME="IDX6453"></A>
<A NAME="IDX6454"></A>
<P>볼륨의 내용을 셀의 파일 트리에서 볼 수 있게
하고 사용자가 액세스할 수 있게 하려면 AFS 파일 공간의 디렉토리 위치로
볼륨을 마운트해야 합니다.
볼륨과 파일 공간에서의 그 위치와의 관계를 <I>마운트 포인트</I>라고 합니다. AFS 마운트 포인트는 보통의 UNIX 파일 시스템 디렉토리와
같이 보이고 기능도 하지만 구조적으로는 캐쉬 관리 프로그램에 디렉토리와
연관된 볼륨의 이름을 알려 주는 기호 연결에 가깝습니다. 마운트 포인트는
캐쉬 관리 프로그램이 그 마운트 포인트를 해석하는 방법을 알고 있을 때만
디렉토리로 보이고 작동할 수 있습니다.
<P>캐쉬 관리 프로그램이 응용프로그램에서 요청한 파일을 검색해야 하는 일반적인
경우를 고려해 보십시오. 캐쉬 관리 프로그램은 AFS 루트(보통 <B>/afs</B>
디렉토리에 마운트되어 있음)에서 해당 파일까지 계속되는 파일의 완전한
경로 이름을 따라 진행합니다. 캐쉬 관리 프로그램이 진행 도중에 마운트 포인트를
만나면(또는 <I>가로지르면</I>) 마운트 포인트를
읽고 해당 디렉토리 위치에 마운트된 볼륨의 이름을 알아 냅니다. 캐쉬 관리
프로그램은 볼륨 위치(VL) 서버에 대한 위치 정보를 얻은 후에 지정된 볼륨을
페치하고 루트 디렉토리를 엽니다. 볼륨의 <I>루트 디렉토리</I>는
포함되어 있는 모든 파일, 하위 디렉토리 및 마운트 포인트를 나열합니다. 캐쉬
관리 프로그램은 경로 이름의 그 다음 요소에 대한 루트 디렉토리 목록을
스캔합니다. 또한 경로를 계속 따라가면서 요청된 파일이 있는 볼륨에 도착할
때까지 이 방법을 사용하여 다른 마운트 포인트를 해석합니다.
<A NAME="IDX6455"></A>
<A NAME="IDX6456"></A>
<P>마운트 포인트는 AFS 파일 공간을 연결하는 실마리가 되어 볼륨이 여러 다른
파일 서버 시스템에 잇는 경우에도 하나의 심리스(seamless) 파일 트리 형태를
작성합니다. 볼륨의 내용은 볼륨이 디렉토리 위치에 마운트될 때 보고 액세스할
수 있으며 볼륨이 마운트되지 않으면 절대 액세스할 수 없습니다.
<P>파일 트리의 둘 이상의 위치에 볼륨을 마운트할 수 있으나 이것은
두 가지 이유로 권장되지 않습니다. 먼저 파일 공간의 계층적 성향을 파괴할 수
있습니다. 둘째, 캐쉬 관리 프로그램은 파일에 도달하기 위해 추적하는
경로 이름에 혼동을 일으킬 수 있습니다 (예를 들어 <B>pwd</B>
명령의 예측치 못한 출력 야기). 그러나 둘 이상의 디렉토리에 볼륨을 마운트하면
해당 볼륨의 루트 디렉토리와 연관된 액세스 제어 목록(ACL)이 모든 마운트 포인트에 적용됩니다. 
<A NAME="IDX6457"></A>
<A NAME="IDX6458"></A>
<P>여러 유형의 마운트 포인트가 있으며 캐쉬 관리 프로그램은 각 마운트 포인트를
다른 방식으로 처리하며 각 마운트 포인트는 다른 목적에 적합합니다.
<A HREF="#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ184" HREF="auagd002.htm#ToC_210">볼륨 이름에 대하여</A></H3>
<A NAME="IDX6459"></A>
<A NAME="IDX6460"></A>
<P>읽기/쓰기 볼륨의 이름은 최대 22자까지 사용할 수 있습니다. 볼륨 서버는
자동으로 <B>.readonly</B> 및 <B>.backup</B> 확장자를 각각 읽기 전용 볼륨과 백업 볼륨에 추가합니다. 적절한
경우에도 볼륨 이름에 확장자를 명시적으로 추가하지 마십시오.
<P>일반적으로 볼륨이 포함하는 데이터의 유형이 볼륨 이름에 지정됩니다. 예를
들어 모든 사용자 볼륨을 <B>user</B>.<VAR>username</VAR>으로
명명하는 것이 일반적이며 여기서 <VAR>username</VAR>은 사용자의 로그인 이름입니다.
이와 마찬가지로 많은 셀들은 시스템 유형 코드로 시작되는 이름을 가진 볼륨에
시스템 2진 파일을 추가합니다. 다른 명명 규칙에 대한 목록을 보려면
<A HREF="auagd007.htm#HDRWQ44">볼륨을 작성하여 관리 간편화하기</A>를 참조하십시오.
<A NAME="IDX6461"></A>
<A NAME="IDX6462"></A>
<HR><H2><A NAME="HDRWQ185" HREF="auagd002.htm#ToC_211">읽기/쓰기 볼륨 작성</A></H2>
<A NAME="IDX6463"></A>
<A NAME="IDX6464"></A>
<A NAME="IDX6465"></A>
<P>읽기/쓰기 볼륨은 가장 기본적인 볼륨 유형으로 읽기 전용 또는 백업 버전을
작성하기 위해 반드시 먼저 존재해야 합니다. <B>vos create</B>
명령을 실행하여 읽기/쓰기 볼륨을 작성할 경우 VL 서버는 사용자가 지정한
이름을 기록하는 VLDB 항목을 작성하고, 읽기/쓰기 볼륨 ID 번호를 지정하고,
나중에 작성될 수 있는 읽기 전용 및 백업 버전에 대한 두 개의 연속 볼륨
ID 번호를 예약해 둡니다. 동시에 볼륨 서버는 사용자가 지정하는 사이트에
볼륨 헤더를 작성하고 디스크에 볼륨 루트 디렉토리의 이름을 기록할 공간을
할당합니다. 이 이름은 사용자가 <B>fs mkmount</B> 명령을
실행하여 볼륨을 마운트할 때 채워지고 마운트 포인트 이름과 일치합니다.
다음은 볼륨 헤더에도 기록됩니다.
<UL>
<LI>볼륨의 루트 디렉토리와 연관된 초기 ACL. 기본적으로 이것은 7개의 모든
액세스 권한을 <B>system:administrators</B> 그룹에
부여합니다. 볼륨을 마운트한 후에 <B>fs setacl</B> 명령을
사용하여 <B>system:administrators</B> 그룹에 대해 다른
항목을 추가 및 제거하거나 항목을 변경할 수 있습니다. <A HREF="auagd020.htm#HDRWQ573">ACL 항목 설정</A>을 참조하십시오. 
<A NAME="IDX6466"></A>
<A NAME="IDX6467"></A>
</LI><LI>볼륨의 읽기/쓰기 버전이 파일 서버 파티션에서 사용할 수 있는 디스크
공간의 양을 제한하는 공간 할당량. 기본값은 5000 킬로바이트 블록이지만
<B>vos create</B>에 대해 <B>-maxquota</B>
인수를 사용하여 다른 할당량을 설정할 수 있습니다.
<P>
<P>작성 후에 할당량을 변경하려면 <A HREF="#HDRWQ234">볼륨 할당량과 현재 크기 설정 및 표시</A>에서 설명하는
것처럼 <B>fs setquota</B> 명령을 사용하십시오.
<A NAME="IDX6468"></A>
<A NAME="IDX6469"></A>
</LI></UL>
<P><H3><A NAME="Header_212" HREF="auagd002.htm#ToC_212">읽기/쓰기 볼륨을 작성(마운트)하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>볼륨을 마우트하려는 디렉토리의 ACL에 대해 <B>a</B>(<B>administer</B>), <B>i</B>(<B>insert</B>) 및 <B>l</B>(<B>lookup</B>) 권한이 있는지 확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
<A NAME="IDX6470"></A>
<A NAME="IDX6471"></A>
</LI><LI><A NAME="LIWQ186"></A>새 볼륨에 대한 사이트(파일 서버 시스템의 디스크 파티션)를
선택하십시오. 사이트에 볼륨이 위치할 충분한 여유 공간이 있는지 확인하려면(현재
또는 전체 할당량을 사용할 수 있을 만큼 커진 상태에서)
<B>vos partinfo</B> 명령을 실행하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 명령의 출력에서 파티션 관련 통계가 항상 표준 UNIX <B>df</B>
명령 출력의 해당 값과 일치하는 것은 아닙니다. 이 명령에서 보고한 통계는
캐쉬 관리 프로그램이 5분 간격으로 파티션 정보에 대해 파일 서버를 폴링하므로
생성된 이후에 최대 5분까지 경과될 수 있습니다. 또한 일부 운영 체제에서
<B>df</B> 명령의 파티션 크기 보고에는 이 명령의 계산에는
포함되어 있지 않은 예약된 공간이 포함되므로 약 10%가 더 커질 수 있습니다.
</TD></TR></TABLE>
<P>
<PRE>   % <B>vos partinfo</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>partition&nbsp;name</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>p
</B><DD>허용되는 <B>partinfo</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>파티션 크기 및 사용도를 표시할 파일 서버 시스템을 지정합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>파티션 크기 및 사용도를 표시할 하나의 파티션을 명명합니다. 이 항목을
생략하면 출력은 시스템의 모든 파티션에 대해 사용할 수 있는 크기와 여유
공간을 표시합니다.
</DL>
</LI><LI><A NAME="LIWQ187"></A><A HREF="#HDRWQ184">볼륨 이름에 대하여</A>의 정보에 유의하여 볼륨
이름을 선택하십시오.
<A NAME="IDX6472"></A>
<A NAME="IDX6473"></A>
</LI><LI><A NAME="LIWQ188"></A><B>vos create</B> 명령을 실행하여
볼륨을 작성하십시오.
<P>
<PRE>   
   % <B>vos create</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>partition&nbsp;name</VAR>> &lt;<VAR>volume&nbsp;name</VAR>>  \
                [<B>-maxquota</B> &lt;<VAR>initial&nbsp;quota&nbsp;(KB)</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>cr
</B><DD>허용되는 <B>create</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>볼륨을 배치할 파일 서버 시스템을 지정합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>볼륨을 배치할 디스크 파티션을 지정합니다.
<P><DT><B><VAR>volume name</VAR>
</B><DD>볼륨을 명명합니다. 최대 22자까지의 영숫자 및 마침표를 사용할 수
있습니다. 셀에는 문자열 <B>user</B>로 사용자 볼륨 이름을
시작하고 마침표를 사용하여 이름의 부분을 분리하는 등의 볼륨에 대한
명명 규칙이 있을 것입니다.
<P><DT><B>-maxquota
</B><DD>킬로바이트 블록 수 단위로 볼륨의 할당량을 설정합니다. 이 인수를
생략하는 경우 할당량은 5000 킬로바이트 블록으로 설정됩니다.
</DL>
<A NAME="IDX6474"></A>
<A NAME="IDX6475"></A>
<A NAME="IDX6476"></A>
<A NAME="IDX6477"></A>
</LI><LI><A NAME="LIWQ189"></A><B>(선택적)</B> <B>fs mkmount</B> 명령을 실행하여 파일 공간에 볼륨을 마운트하십시오.
자세한 구문을 보려면 <A HREF="#HDRWQ212">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A>을 참조하십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>> 
   
</PRE>
</LI><LI><B>(선택적)</B> <B>fs lsmount</B> 명령을
실행하여 마운트 포인트가 올바른 볼륨을 참조하는지 확인하십시오.
<A HREF="#HDRWQ211">마운트 포인트를 표시하려면</A>에 나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>fs lsmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
</LI><LI><B>(선택적)</B> 볼륨 헤더에 볼륨에 대한 보조
정보를 기록하려면 <B>-offlinemsg</B> 인수와 함께
<B>fs setvol</B> 명령을 실행하십시오. 예를 들어
볼륨을 소유하는 사람이나 파일 공간에서 볼륨을 마운트한 위치를 기록할
수 있습니다. 이 정보를 표시하려면 <B>fs examine</B>
명령을 사용하십시오.
<P>
<PRE>   % <B>fs setvol</B> &lt;<VAR>dir/file path</VAR>>
<B>-offlinemsg</B> &lt;<VAR>offline message</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sv
</B><DD>허용되는 <B>setvol</B>의 별명(그리고 <B>setv</B>는 허용되는 가장 짧은 축약형)입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>메시지를 연관지을 볼륨의 마운트 포인트를 명명합니다.
부분 경로 이름은 현재 작업 디렉토리에 상대적으로 해석됩니다.
<P>
<P>마운트 포인트에 대한 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨을 변경하려고
할 때 발생하는 장애를 피하십시오. 일반적으로
경로 이름의 두 번째 레벨의 셀 이름 앞에 마침표를 사용하여 읽기/쓰기 경로를
나타내십시오(예를 들어 <B>/afs/.abc.com</B>). 파일 경로를
통한 읽기/쓰기 및 읽기 전용 경로의 개념에 대해 좀더 살펴 보려면
<A HREF="#HDRWQ209">마운트 포인트 통과 규칙</A>을 참조하십시오.
<P><DT><B>-offlinemsg
</B><DD>볼륨 헤더에 기록할 보조 정보를 128자까지 지정합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ190" HREF="auagd002.htm#ToC_213">클론 및 클로닝에 대하여</A></H2>
<A NAME="IDX6478"></A>
<A NAME="IDX6479"></A>
<A NAME="IDX6480"></A>
<A NAME="IDX6481"></A>
<P>백업 또는 읽기 전용 볼륨을 작성하기 위해 볼륨 서버는 읽기/쓰기 원본 볼륨을
<I>클로닝</I>하여 <I>클론</I>을 작성하기
시작합니다. 볼륨 서버는 <B>vos backup</B> 또는 <B>vos backupsys</B>
명령(백업 볼륨의 경우) 또는 <B>vos release</B> 명령(읽기
전용 볼륨의 경우)을 실행하여 자동으로 클론을 작성합니다. 사용자가 해야 할
특정 작업은 없습니다.
<P>클론은 읽기/쓰기 원본 볼륨의 데이터 사본이 아니고 읽기/쓰기 볼륨의
<I>vnode 색인</I> 사본입니다.
vnode 색인은 데이터가 있는 파티션의 물리적 디스크 블록과 볼륨에 있는
파일 및 디렉토리 간의 포인터의 테이블입니다.
다음 방식으로 클론으로부터 백업 및 읽기 전용 볼륨이 작성됩니다.
<UL>
<LI>읽기/쓰기 원본과 동일한 파티션을 차지하는 읽기 전용
볼륨(<I>읽기 전용 클론</I>이라고도 함)과 백업 볼륨은
볼륨 헤더를 클론에 부착하여 작성됩니다. 이들 볼륨은 이 클론 부분(vnode
색인)이 <A HREF="#FIGWQ191">그림 1</A>에서 설명하는 것처럼 읽기/쓰기 볼륨과
정확히 동일한 파일을 가리키기 때문에 처음에는 거의 디스크 공간을 차지하지
않습니다. 파일 공유는 클론이 읽기/쓰기 원본 볼륨과 동일한 파티션에
있을 때만 가능합니다. 읽기/쓰기 볼륨의 파일은 삭제되어도 백업 또는 읽기
전용 클론이 여전히 그 파일을 가리키므로 파티션에서 실제로 제거되지
않습니다. 이와 마찬가지로 읽기/쓰기 볼륨의 파일이 변경되면 전체 원본
파일은 클론이 여전히 해당 파일을 가리키고 있으며 읽기/쓰기 볼륨의 vnode
색인이 변경된 파일에 대한 새 공간을 가리키도록 변경되므로 디스크에
그대로 보유됩니다. 이 경우 백업 또는 읽기 전용 볼륨은 실제 디스크 공간을
차지하도록 커집니다.
</LI><LI>읽기/쓰기 원본과 동일한 사이트를 차지하지 않는 읽기 전용 볼륨은
클론 및 읽기/쓰기 원본 볼륨에 있는 모든 데이터의 사본입니다. 이것은
읽기 전용 볼륨이 작성되었을 때 읽기/쓰기 볼륨이 차지했던 것과 동일한
디스크 공간을 차지합니다.
</LI></UL>
<P><B><A NAME="FIGWQ191" HREF="auagd003.htm#FT_FIGWQ191">그림 1. 읽기/쓰기 원본 및 클론 볼륨 간의 파일 공유</A></B><BR>
<TABLE BORDER ><TR><TD><BR>
<B><BR><IMG SRC="vnode.gif" ALT="읽기/쓰기 원본 및 클론 볼륨 간의 파일 공유"><BR></B><BR>
</TD></TR></TABLE>
<A NAME="IDX6482"></A>
<A NAME="IDX6483"></A>
<A NAME="IDX6484"></A>
<A NAME="IDX6485"></A>
<A NAME="IDX6486"></A>
<A NAME="IDX6487"></A>
<A NAME="IDX6488"></A>
<HR><H2><A NAME="HDRWQ192" HREF="auagd002.htm#ToC_214">볼륨 복제(읽기 전용 볼륨 작성)</A></H2>
<P><I>복제</I>는 읽기/쓰기 볼륨의 읽기 전용 사본의 작성과
이 복사본을 하나 이상의 추가 파일 서버 시스템에 분배하는 것을 의미합니다.
복제를 수행하면 둘 이상의 파일 서버 시스템에서 볼륨의 내용을 액세스할 수
있으므로 데이터 사용 효율이 증가됩니다. 또한 네트워크 및 파일 서버의
작업 로드를 줄임으로써 시스템 효율성을 증가시킬 수 있습니다.
클라이언트 시스템의 서버 선호도에 따라 캐쉬 관리 프로그램이 가장
가까운 파일 서버 시스템에 저장된 볼륨 사본을 액세스하게 되는 경우
네트워크 로드가 줄어듭니다. 파일 서버 상의 로드는 읽기/쓰기 볼륨으로부터 페치된
각 파일에 대한 콜백의 경우와 반대로 읽기 전용 볼륨에서 페치된 모든
데이터에 대한 한 번의 콜백만 실행하므로 역시 줄어듭니다. 볼륨이 관리자
조치에 따라 달라지는 경우를 제외하고 변경되지 않으므로 전체 읽기 전용
볼륨에 대해 단일 콜백만으로도 충분합니다.
<A NAME="IDX6489"></A>
<A NAME="IDX6490"></A>
<A NAME="IDX6491"></A>
<A NAME="IDX6492"></A>
<A NAME="IDX6493"></A>
<P>볼륨을 복제할 때는 두 가지 명령을 실행해야 합니다. 먼저 <B>vos
addsite</B> 명령을 실행하여 볼륨의 VLDB 항목에 하나 이상의 사이트
정의를 추가하십시오(<I>사이트</I>는 파일 서버 시스템의
특정 파티션임). 그런 다음 <B>vos release</B> 명령을 사용하여
읽기/쓰기 원본 볼륨을 복제하고 클론을 정의된 읽기 전용 사이트에 분배하십시오.
각 읽기 전용 사이트에 대해 한번씩만 <B>vos addsite</B> 명령을
실행하면 되지만 읽기/쓰기 볼륨의 내용이 변경되고 사용자가 읽기 전용 볼륨을
갱신하기 원할 때마다 <B>vos release</B> 명령을 재실행해야 합니다.
<P>사용자가 일관된 파일 시스템 보기를 원하는 경우 읽기 전용 사이트에 대해
갱신된 볼륨의 릴리스가 원자 형태여야 합니다. 즉 모든 읽기 전용 사이트는
새 버전의 볼륨을 받거나 모든 사이트가 현재 가지고 있는 버전을 그대로
유지해야 할 것입니다. <B>vos release</B> 명령은 볼륨의
읽기 전용 버전의 모든 사본이 읽기/쓰기 원본 및 서로 간에 일치할 수 있게
만들도록 설계되었습니다. 시스템 또는 서버 프로세스 작동 중지와 같은
문제점이 릴리스 조작의 성공적인 완료를 방해하는 경우 AFS는 두 가지 메카니즘을
사용하여 사용자에게 경고합니다.
<A NAME="IDX6494"></A>
<A NAME="IDX6495"></A>
<A NAME="IDX6496"></A>
<A NAME="IDX6497"></A>
<A NAME="IDX6498"></A>
<A NAME="IDX6499"></A>
<A NAME="IDX6500"></A>
<A NAME="IDX6501"></A>
<A NAME="IDX6502"></A>
<A NAME="IDX6503"></A>
<A NAME="IDX6504"></A>
<A NAME="IDX6505"></A>
<A NAME="IDX6506"></A>
<A NAME="IDX6507"></A>
<P>첫째로 명령 인터프리터는 새 볼륨 버전을 수신하지 못한 각 읽기 전용 사이트를
명명하는 표준 오류 스트림에 오류 메시지를 생성합니다. 둘째로 릴리스 조작
중에 볼륨 위치(VL) 서버는 해당 사이트가 새 볼륨 버전을 가지고 있는지
여부를 나타내는 플래그(<TT>New release</TT> 및 <TT>Old release</TT>)로
VLDB 항목의 사이트 정의를 표시합니다. 조작이 완료된 후에 플래그가 남아
있으면 작업은 성공적으로 완료되지 못한 것입니다. 캐쉬 관리 프로그램은
<TT>New release</TT> 플래그로 표시된 사이트보다 더 큰 작업 부하를
초래할 수 있으므로 <TT>Old release</TT> 플래그로 표시된 읽기 전용 사이트의
액세스를 거부합니다. 장애의 원인을 조사하여 없앤 다음 오류 없이 릴리스가
완료되는 데 필요한 만큼 <B>vos release</B> 명령을 실행하는
것은 중요합니다.
<P>실패한 릴리스 조작 이후에 볼륨의 VLDB 항목에 남아 있는 사이트 플래그의
패턴은 조작이 실패하는 시점을 알아내는 데 도움이 될 수 있습니다.
<B>vos examine</B> 또는 <B>vos listvldb</B>
명령을 사용하여 VLDB 항목을 표시하십시오. VL 서버는 볼륨 서버의 조작과
관련하여 다음과 같이 플래그를 설정합니다.
<OL TYPE=1>
<LI>조작이 시작되기 전에 VL 서버는 VLDB 항목의 읽기/쓰기 사이트 정의에
<TT>New release</TT> 플래그를 설정하고 읽기 전용 사이트 정의에는
<TT>Old release</TT> 플래그를 설정합니다(마지막 릴리스 조작 이후에
읽기 전용 사이트가 정의되지 않은 경우와 실제 볼륨이 없는 경우. 실제 볼륨이
없는 경우에는 그 사이트 플래그가 <TT>Not released</TT>로 남아 있습니다).
</LI><LI>필요하면 볼륨 서버는 ReleaseClone이라는 읽기/쓰기 원본의 임시
사본(<I>클론</I>)을 작성합니다(볼륨 서버가 새 ReleaseClone을
작성하거나 작성하지 않을 때에 대한 다음 설명을 참조하십시오).
볼륨 서버는 ReleaseClone에 VL 서버가 원본 볼륨의 VLDB 항목의 <TT>RClone</TT>
필드에 기록하는 자체의 볼륨 ID 번호를 지정합니다.
</LI><LI>볼륨 서버는 VLDB 항목에 정의된 각 읽기 전용 사이트에 ReleaseClone
사본을 분배합니다. 사이트가 성공적으로 새 클론을 수신하면 VL 서버는 VLDB
항목의 사이트 플래그를 <TT>New release</TT>로 설정합니다.
</LI><LI>모든 읽기 전용 사본이 성공적으로 릴리스되면 VL 서버는 모든
<TT>New release</TT> 사이트 플래그를 지웁니다. ReleaseClone은 더 이상
필요하지 않으므로 볼륨 서버는 이를 삭제하고 VL 서버는 VLDB 항목에서
그 ID를 지웁니다.
</LI></OL>
<P>기본적으로 볼륨 서버는 새 ReleaseClone을 작성해야 할지 여부를 자동적으로
결정합니다.
<UL>
<LI>VLDB 항목의 사이트 정의에 플래그(<TT>New release</TT>, <TT>Old
release</TT> 또는 <TT>Not released</TT>)가 없으면 이전에 수행한
<B>vos release</B> 명령이 성공적으로 완료되고 모든 읽기
전용 사이트가 현재 동일한 볼륨을 가지게 됩니다. 볼륨 서버는 읽기 쓰기
볼륨이 변경되었으므로 현재의 <B>vos release</B> 명령이
실행되었다고 가정합니다. 볼륨 서버는 새 ReleaseClone을 작성하고 이를
모든 읽기 전용 사이트에 분배합니다.
</LI><LI>VLDB 항목의 사이트 정의에 플래그가 설정되어 있으면 이전의 릴리스 조작은
성공적으로 완료되지 못했거나 새로운 읽기 전용 사이트가 마지막 릴리스
이후에 정의된 것입니다.
볼륨 서버는 새 ReleaseClone을 작성하지 않고 대신 기존의 ReleaseClone을
<TT>Old release</TT> 또는 <TT>Not released</TT> 플래그가 설정된 사이트에
분배합니다. 앞서 설명한 것처럼 VL 서버는 사이트가 ReleaseClone을 수신할 때
각 VLDB 사이트 정의에 <TT>New release</TT> 플래그를 설정하고 모든 사이트가
성공적으로 ReleaseClone을 수신한 후에 모든 플래그를 지웁니다.
</LI></UL>
<P>기본 동작을 무시하고 강제로 볼륨 서버가 새로운 ReleaseClone을 작성하여
읽기 전용 사이트에 릴리스하게 하려면 <B>-f</B> 플래그를
포함시키십시오. 이것은 예를 들어 읽기/쓰기 사이트의 데이터가 기존의
ReleaseClone이 이전의 릴리스 조작 중에 작성된 이후에 변경되었을 때
적절합니다.
<P><H3><A NAME="HDRWQ193" HREF="auagd002.htm#ToC_215">읽기 전용 볼륨의 효율적 사용</A></H3>
<A NAME="IDX6508"></A>
<A NAME="IDX6509"></A>
<A NAME="IDX6510"></A>
<A NAME="IDX6511"></A>
<P>최대 효율을 위해 두 가지 기준을 만족하는 볼륨만 복제하십시오.
<UL>
<LI>볼륨의 내용이 많이 사용되고 있습니다. 문서 편집기나 자주 사용되는
다른 응용프로그램에 대한 2진 파일을 저장하는 볼륨, 사용자 홈 디렉토리로
진행되는 경로와 같이 복잡하게 진행되는 디렉토리 경로에 따라 마운트되는
볼륨 등을 예로 들 수 있습니다. 이 경우는 단일 파일 서버가 모든 요청을 쉽게
처리할 수 있을 만큼 요구가 낮은 볼륨을 복제하는 것은 불필요한 디스크 공간의
사용입니다.
</LI><LI>볼륨의 내용은 자주 변경되지 않습니다. 앞서 설명한 것처럼 파일 시스템
일관성을 위해 읽기 전용 볼륨의 내용이 읽기/쓰기 원본과 서로 간에 항상 일치해야
합니다. 읽기/쓰기 볼륨이 변경될 때마다 <B>vos release</B>
명령을 실행하여 읽기 전용 볼륨을 갱신해야 합니다. 이것은 읽기/쓰기 볼륨이
자주 변경되는 경우 짜증나는(잊어버리기 쉬운) 작업이 될 수 있습니다.
</LI></UL>
<A NAME="IDX6512"></A>
<A NAME="IDX6513"></A>
<P>읽기 전용 볼륨을 명시적으로 마운트하는 것은 (<B>.readonly</B>
확장자를 사용하여 볼륨을 명명하는 마운트 포인트를 작성) 일반적으로 불필요하며
적절하지 않습니다. 캐쉬 관리 프로그램은 가능할 때마다 복제된 볼륨의 읽기 전용
볼륨을 액세스하는 기본적인 성향을 가지고 있습니다. <A HREF="#HDRWQ209">마운트 포인트 통과 규칙</A>에서
좀더 자세히 설명하는 것처럼 캐쉬 관리 프로그램은 내부에서 볼륨 이름을
읽을 때 마운트 포인트를 만날 때 VL 서버에 접속하여 해당 볼륨이 있는 사이트의
목록을 확인합니다. 정상적인 경우에 마운트 포인트가 읽기 전용 볼륨에 있고
읽기/쓰기 볼륨을 명명하면 (<B>.readonly</B> 또는 <B>.backup</B> 확장자를 가지지 않는 볼륨) 캐쉬 관리 프로그램은 항상 볼륨의
읽기 전용 사본을 액세스하려고 합니다. 따라서 강제로 읽기 전용 볼륨을
마운트함으로써 캐쉬 관리 프로그램이 읽기 전용 볼륨을 액세스하게 할
필요가 없습니다.
<P>몇 가지 이유로 인해 읽기/쓰기 사이트에 읽기 전용 볼륨을 두는 것이
좋습니다. 먼저 읽기/쓰기 사이트의 읽기 전용 볼륨은 모든 데이터의 사본에
해당하는 클론이므로 적은 디스크 공간만
요구합니다(<A HREF="#HDRWQ190">클론 및 클로닝에 대하여</A> 참고). 읽기/쓰기 볼륨에서 많은 수의 파일이
제거되거나 변경되는 경우에만 읽기 전용 사본이 많은 디스크 공간을 차지합니다.
이러한 상황은 복제된 읽기/쓰기 볼륨의 변경에 대한 대처 방안이 이 볼륨을
재복제하는 것이므로 별로 자주 발생하지 않습니다. 읽기/쓰기 사이트에 읽기
전용 볼륨을 두는 또 다른 이유는 캐쉬 관리 프로그램이 모든 읽기 전용 사본을
액세스할 수 없게 되는 경우 복제된 볼륨의 읽기/쓰기 버전을 액세스하려고 시도하지
않는다는 것입니다. 읽기/쓰기 볼륨이 있는 파일 서버 시스템만 액세스가 가능한
유일한 시스템인 경우 캐쉬 관리 프로그램은 읽기/쓰기 사이트에 읽기 전용
사본이 있을 때만 이 데이터를 액세스할 수 있습니다.
<P>정의할 읽기 전용 사이트의 수는 여러 요소에 따라 달라집니다. 볼륨의 내용에
대한 요구 수준과 사용자가 볼륨의 여러 사본에 대해 사용하려는 디스크 공간의
크기를 통해 사이트 수가 결정될 것입니다. 물론 예상되는 각 읽기 전용
사이트에는 볼륨을 포함하는데 사용할 수 있는 충분한 공간이 있어야 합니다.
볼륨의 읽기 전용 사본 수에 대한 제한은 <I>AFS 릴리스 노트</I>에 정의되어 있는 볼륨의
VLDB 항목에 있는 최대 사이트 수 정의에 의해 결정됩니다. 볼륨의 읽기/쓰기
및 백업 버전을 포함하는 사이트는 하나의 사이트로 계산되고 각 읽기 전용
사이트는 추가 사이트로 계산됩니다(읽기/쓰기 사이트와 동일한 파일 서버
시스템 및 파티션에 정의된 읽기 전용 사이트는 별도의 사이트로 계산됨).
또한 볼륨 서버가 파일 서버 시스템 당 하나의 읽기 전용 볼륨 사본만
허용한다는 사실을 알아 두십시오.
<P><H3><A NAME="Header_216" HREF="auagd002.htm#ToC_216">복제 시나리오</A></H3>
<A NAME="IDX6514"></A>
<A NAME="IDX6515"></A>
<A NAME="IDX6516"></A>
<P>다음 절의 지침은 읽게 전용 사이트가 현재 정의되어 있지 않은 볼륨을 복제하는
방법을 설명합니다. 그러나 다른 일반적인 상황에서 이 지침을 사용할 수도 있습니다.
<UL>
<LI>이미 존재하는 사이트에 새 클론을 릴리스하는 경우 단계
<A HREF="#LIWQ196">2</A>를 건너뛸 수 있습니다. 그러나
<B>vos examine</B> 명령을 실행하여 원하는 읽기 전용
사이트가 정의되어 있는지 확인하는 것은 유용한 방법입니다.
</LI><LI>기존 사이트에 새로운 읽기 전용 사이트를 추가하는 경우 모든 단계를
수행하십시오. 단계 <A HREF="#LIWQ197">3</A>에서 새로운 사이트에 대해서만
<B>vos addsite</B> 명령을 실행하십시오.
</LI><LI>사이트를 정의하지만 아직 클론을 릴리스하지 않으려면 단계
<A HREF="#LIWQ197">3</A> 다음에서 정지하고 준비될 때 계속하십시오.
</LI><LI>새 클론을 나머지 사이트에 릴리스하기 전에 하나 이상의 사이트를
제거하는 경우 <A HREF="#HDRWQ235">볼륨 및 마운트 포인트 제거</A>에서 사이트 제거에 대한 지침을
참고하고 단계 <A HREF="#LIWQ198">4</A>에서 시작하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ194" HREF="auagd002.htm#ToC_217">읽기/쓰기 볼륨을 복제하려면 (읽기 전용 볼륨 작성)</A></H3>
<A NAME="IDX6517"></A>
<A NAME="IDX6518"></A>
<OL TYPE=1>
<LI><A NAME="LIWQ195"></A>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><A NAME="LIWQ196"></A>볼륨을 복제할 하나 이상의 사이트를 선택하십시오.
다음 사항을 고려해야 합니다.
<UL>
<LI>이미 정의되어 있는 사이트의 수. 앞서 언급한 것처럼 읽기/쓰기 사이트에서
읽기 전용 사이트를 정의하는 것은 적절합니다. 또한 볼륨 서버는 파일 서버
시스템 당 하나의 읽기 전용 볼륨 사본만 허용합니다.
볼륨의 현재 사이트를 표시하려면 <A HREF="#HDRWQ221">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A>에서
설명하는 것처럼 <B>vos examine</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>vos examine</B> &lt;<VAR>volume&nbsp;name&nbsp;or &nbsp;ID</VAR>>
    
</PRE>
<P>
<P>출력의 마지막 행에는 VLDB로부터의 볼륨 사이트 정의가 표시됩니다.
</LI><LI>셀에서 읽기 전용 볼륨만을 저장하기 위해 파일 서버 시스템을 전용으로
사용하는지 여부. 보통 아주 큰 셀에서만 읽기 전용 서버 시스템을 사용합니다.
</LI><LI>사이트에 볼륨을 저장할만한 충분한 공간이 있는지 여부. 읽기 전용 볼륨은
읽기/쓰기 버전과 동일한 공간을 요구합니다(이 볼륨이 읽기/쓰기 사이트에
있는 경우에도). <B>vos examine</B> 명령의 첫째 출력 행은
<A HREF="#HDRWQ221">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A>에서 볼 수 있는 것처럼 읽기/쓰기 볼륨의 현재
크기를 킬로바이트 블록 단위로 표시합니다.
<P>
<P>파일 서버 시스템의 파티션에서 사용할 수 있는 공간의 양을 표시하려면
<A HREF="#HDRWQ185">읽기/쓰기 볼륨 작성</A>에서 자세히 설명하는 것처럼
<B>vos partinfo</B> 명령을 사용하십시오.
<P>
<PRE>   
   % <B>vos partinfo</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>partition&nbsp;name</VAR>>]
   
</PRE>
</LI></UL>
<A NAME="IDX6519"></A>
<A NAME="IDX6520"></A>
<A NAME="IDX6521"></A>
<A NAME="IDX6522"></A>
<A NAME="IDX6523"></A>
<A NAME="IDX6524"></A>
</LI><LI><A NAME="LIWQ197"></A><B>vos addsite</B> 명령을 실행하여
VLDB에 새로운 각 읽기 전용 사이트를 정의하십시오.
<P>
<PRE>   
   % <B>vos addsite</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>partition&nbsp;name</VAR>> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>ad
</B><DD>허용되는 <B>addsite</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>새 사이트에 대한 파일 서버 시스템을 정의합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>시스템 <VAR>machine name</VAR>의 디스크 파티션을 명명합니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 복제할 읽기/쓰기 볼륨을 식별합니다.
</DL>
</LI><LI><A NAME="LIWQ198"></A><B>(선택적)</B> 읽기 전용 사이트를 정의한
각 파일 서버 시스템에서 <B>fs</B> 프로세스(볼륨 서버 통합)가
제대로 작동하는지 <B>vlserver</B> 프로세스(볼륨 위치 서버)가
각 데이터베이스 서버 시스템에서 제대로 작동하는지 확인하십시오. 이들이
제대로 기능할 경우 릴리스의 두 가지 실패 요인이 해결됩니다.
이 볼륨에 대한 읽기 전용 사이트가 있는 각 파일 서버 시스템과 각
데이터베이스 서버 시스템에 대해 <B>bos status</B> 명령을
실행하십시오.
이 명령은 <A HREF="auagd009.htm#HDRWQ158">프로세스 상태와 BosConfig 파일의 정보 표시하기</A>에서 자세히 설명합니다.
<P>
<PRE>   
   % <B>bos status</B> &lt;<VAR>machine&nbsp;name</VAR>> <B>fs vlserver</B>
   
</PRE>
<A NAME="IDX6525"></A>
<A NAME="IDX6526"></A>
<A NAME="IDX6527"></A>
<A NAME="IDX6528"></A>
</LI><LI><A NAME="LIWQ199"></A><B>vos release</B> 명령을 실행하여 읽기/쓰기
원본 볼륨을 클론하고 클론을 각 읽기 전용 사이트에 분배하십시오.
<P>
<PRE>   
   % <B>vos release</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>> [<B>-f</B>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>rel
</B><DD>허용되는 <B>release</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 복제할 읽기/쓰기 볼륨을 식별합니다.
읽기 전용 버전에는 <B>.readonly</B> 확장자가 붙은 동일한
이름이 부여됩니다. 모든 읽기 전용 사본은 동일한 읽기 전용 볼륨 ID 번호를 공유합니다.
<P><DT><B>-f
</B><DD>완전히 새로운 클론을 작성하고 릴리스합니다.
</DL>
</LI><LI><A NAME="LIWQ200"></A><B>(선택적)</B> <B>vos examine</B> 명령을 실행하여 VLDB 항목에 <TT>Old release</TT> 또는
<TT>New release</TT> 플래그가 설정된 사이트 정의가 없는지 확인하십시오.
이 명령은 <A HREF="#HDRWQ221">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A>에서 자세히 설명합니다.
<P>
<PRE>   
   % <B>vos examine</B> &lt;<VAR>volume&nbsp;name&nbsp;or &nbsp;ID</VAR>>
   
</PRE>
</LI></OL>
<P>단계 <A HREF="#LIWQ200">6</A>의 출력에 플래그가 나타나는 경우
볼륨 서버가 릴리스 조작 중에 오류 메시지를 생성하지 않고 플래그가 더 이상
나타나지 않을 때까지 단계 <A HREF="#LIWQ198">4</A> 및 <A HREF="#LIWQ199">5</A>를
반복하십시오. 네트워크, 시스템 또는 서버 프로세스 작동 중지로 인해
읽기/쓰기 사이트나 읽기 전용 사이트를 액세스할 수 없다는 사실을 알고
있을 경우에는 <B>vos release</B> 명령을 실행하지 마십시오.
<HR><H2><A NAME="HDRWQ201" HREF="auagd002.htm#ToC_218">백업 볼륨 작성</A></H2>
<A NAME="IDX6529"></A>
<A NAME="IDX6530"></A>
<A NAME="IDX6531"></A>
<A NAME="IDX6532"></A>
<A NAME="IDX6533"></A>
<P><I>백업 볼륨</I>은 읽기/쓰기 원본이 있는 동일한 사이트에
있는 클론입니다(클로닝 개념을 살펴 보려면 <A HREF="#HDRWQ190">클론 및 클로닝에 대하여</A>를
참조하십시오). 다음의 두 가지 목적으로 볼륨의 백업 버전을 작성하게 됩니다.
<UL>
<LI>일반적으로 AFS 백업 시스템을 사용하여 볼륨의 내용을 테이프로 덤프하는 것이
첫번째 단계입니다. 볼륨은 덤프되는 동안 액세스할 수 있으므로 읽기/쓰기 볼륨을
덤프하는 대신 백업 버전을 작성하여 덤프해야 합니다. 사용자는 보통 백업
버전을 액세스하지 않으므로 백업 버전의 덤프는 사용자에게 별 문제를 발생하지
않습니다. 자세한 정보를 보려면 <A HREF="auagd012.htm#HDRWQ296">데이터 백업</A>을 참조하십시오.
</LI><LI>백업 볼륨을 사용하면 사용자는 실수로 삭제했거나 변경한 데이터를 복원할
수 있으므로 다른 중요한 작업에 시간을 할애할 수 있습니다. 백업 버전은
백업이 작성된 시점에서 읽기/쓰기 원본의 상태를 캡처하며 그 내용은 변경할 수
없습니다. 사용자가 백업을 만든 시점의 상태로 파일을 복원할 수 있도록
파일 공간에 백업 버전을 마운트하십시오.
<A HREF="#HDRWQ204">백업 볼륨의 내용을 사용자가 사용할 수 있게 만들기</A>를 참조하십시오.
</LI></UL>
<A NAME="IDX6534"></A>
<A NAME="IDX6535"></A>
<A NAME="IDX6536"></A>
<P><H3><A NAME="HDRWQ202" HREF="auagd002.htm#ToC_219">한 번에 여러 볼륨 백업</A></H3>
<P><B>vos backupsys</B> 명령을 사용하면 한 번에 여러 읽기/쓰기
볼륨의 백업 버전이 작성됩니다. 이 명령은 AFS 백업 시스템을 사용하여 테이프로의
대규모의 백업을 계획할 때 유용합니다.
<P>VLDB에 나열된 모든 읽기/쓰기 볼륨을 클론하려면 모든 명령 옵션을 생략하십시오.
그렇지 않은 경우 다양한 볼륨 그룹을 클론하도록 명령 옵션을 조합하십시오.
옵션은 볼륨을 선택할 때 두 가지 기본적인 기준 중 하나를 사용합니다.
기준에는 위치(<B>-server</B> 및 <B>-partition</B>
인수) 또는 볼륨 이름에서 지정된 문자 스트링 집합 중 하나가 존재하는지
여부(<B>-prefix</B>, <B>-exclude</B> 및
<B>-xprefix</B> 옵션)가 있습니다.
<P>하나의 파일 서버 시스템에 위치하는 볼륨만 클론하려면
<B>-server</B> 인수를 포함시키십시오. 하나의 파티션에
위치하는 볼륨만 클론하려면 <B>-server</B> 및 <B>-partition</B> 인수를 조합하여 사용하십시오. <B>-partition</B>
인수는 모든 파일 서버 시스템의 지정된 파티션에 위치하는 볼륨을 클론하는데도
단독으로 사용할 수 있습니다. 이들 인수는 그 이름에 기반하여 볼륨을 선택하는
인수와 함께 사용할 수 있습니다.
<P>이름에 포함된 문자 스트링에 기반하여 볼륨을 선택하려면 지정된 방식으로
<B>-prefix</B>, <B>-exclude</B>
및 <B>-xprefix</B> 옵션을 조합하여 사용하십시오(
<B>-server</B> 및 <B>-partition</B> 인수
사용 여부에 관계 없음).
<UL>
<LI>그 이름에 지정된 문자 스트링 집합 중 하나가 들어 있는 모든 읽기/쓰기 볼륨을
지정된 위치에 클론하려면(예를 들어 <B>user.</B>에서
시작하거나 문자 스트링 <B>afs</B>를 포함) <B>-prefix</B> 인수를
사용하거나 <B>-xprefix</B> 및 <B>-exclude</B>
옵션을 조합해서 사용하십시오.
</LI><LI>그 이름에 지정된 문자 스트링 집합 중 하나가 들어 있는 볼륨을 제외하고
모든 읽기/쓰기 볼륨을 지정된 위치에 클론하려면 <B>-xprefix</B>
인수를 사용하거나 <B>-prefix</B> 및 <B>-exclude</B>
옵션을 조합해서 사용하십시오.
</LI><LI>그 이름에 지정된 문자 스트링 집합 중 하나가 들어 있는 볼륨을 제외하고
다른 문자 스트링 집합 중 하나가 들어 있는 모든 읽기/쓰기 볼륨을 지정된 위치에
복제하려면 <B>-prefix</B> 및 <B>-xprefix</B>
인수를 조합해서 사용하십시오. 이 명령은 <B>-prefix</B> 인수에 해당하는 모든 볼륨 목록을 작성한 다음
<B>-xprefix</B> 인수에 해당하는 볼륨 목록에서 해당 볼륨을
제거합니다. 효과적인 결과를 얻기 위해 <B>-xprefix</B> 인수에서
지정한 문자 스트링은 <B>-prefix</B> 인수에서 지정한 볼륨의
서브세트를 지정해야 합니다.
<P>
<P><B>-exclude</B> 플래그를 <B>-prefix</B> 및 <B>-xprefix</B> 인수와 조합해서 사용하면
명령은 <B>-prefix</B> 인수에 해당하지 않는 모든 볼륨의
목록을 작성한 다음 이 목록에 <B>-xprefix</B> 인수에
해당하는 볼륨을 추가합니다. <B>-exclude</B> 플래그가
사용되지 않을 때는 <B>-xprefix</B> 인수에서 지정한 문자 스트링이
<B>-prefix</B> 인수에서 지정한 볼륨의 서브세트를
지정하는 경우에만 결과가 효과적이 됩니다.
</LI></UL>
<P><B>-prefix</B> 및 <B>-xprefix</B> 인수는
모두 여러 개의 값을 허용하며 볼륨 그룹을 해체하는 데 사용할 수 있습니다.
각 값은 다음의 두 가지 유형 중 하나를 가집니다.
<OL TYPE=1>
<LI>그 이름이 해당 문자열로 시작되는 볼륨에 해당하는 단일 문자 스트링.
모든 문자는 문자 그대로 해석됩니다(즉 마침표와 같이 명령 쉘에서 특수한
의미를 가질 수 잇는 문자는 문자 자체의 의미만 가집니다).
</LI><LI>그 이름에 표현식이 들어 있는 볼륨에 해당하는 일반 표현식.
표현식 맨 앞에 캐럿(&nbsp;<B>^</B>&nbsp;)을
사용하고 전체 문자열을 작은 따옴표(<B>'</B>&nbsp;<B>'</B>)로 묶으십시오. 일반 표현식을
설명하는 것은 이 참조 페이지 범위를 벗어납니다. UNIX 설명서 페이지에서
<B>regexp(5)</B>를 참고하거나 간단한 소개가 제공되는
<A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>를 참조하십시오.
예를 들어 다음 표현식은 그 이름의 아무 위치에 문자열 <B>aix</B>를
가지는 볼륨에 해당합니다.
<P>
<PRE>   <B>-prefix  '^.*aix'</B>
</PRE>
</LI></OL>
<P>실제로 볼륨을 클론하지는 않으면서 클론될 볼륨 목록을 표시하려면
<B>-dryrun</B> 플래그를 포함시키십시오. 볼륨을 선택하는 데
사용되는 기준을 요약하는 문장을 표시하려면 <B>-verbose</B>
플래그를 포함시키십시오.
<P>단일 볼륨을 백업하려면 <B>vos backup</B> 명령을 사용하십시오.
이 명령은 단일 볼륨을 찾기 위한 보다 간편한 기술을 제공합니다.
<A NAME="IDX6537"></A>
<A NAME="IDX6538"></A>
<A NAME="IDX6539"></A>
<A NAME="IDX6540"></A>
<A NAME="IDX6541"></A>
<A NAME="IDX6542"></A>
<P><H3><A NAME="HDRWQ203" HREF="auagd002.htm#ToC_220">백업 볼륨 작성 자동화</A></H3>
<P>대부분의 셀은 매일 관련된 볼륨의 새로운 백업 버전을 작성하는 것이 바람직한
일이라는 것을 알고 있습니다. 백업 조작은 읽기/쓰기 볼륨을 일시적으로
사용 불가능하게 하므로 사용도가 낮을 때 백업 버전을 작성하는 것이 좋습니다.
<P>콘솔에서 <B>vos backupsys</B> 또는 <B>vos backup</B>
명령을 실행하거나 파일 서버 시스템의 <B>BosConfig</B>
파일에 <B>클론</B> 항목을 작성하여 관리자가 백업 조작을
초기화할 필요를 없앨 수 있습니다.
<P>다음 예제 명령은 시스템 <B>fs3.abc.com</B>의
<B>/usr/afs/local/BosConfig</B> 파일에
<B>backupusers</B>라는 <B>cron</B>
프로세스를 작성합니다. 이 프로세스는 매일 새벽 1시에 실행되어 그 이름이
문자열 <B>user</B>.로 시작하는 모든 볼륨의 백업 버전을
셀에 작성합니다. <B>-localauth</B> 플래그를 사용하면
프로세스는 인증을 받지 못한 상태에서 권한 있는 <B>vos backupsys</B> 명령을 호출할 수 있게 됩니다. <B>-cmd</B> 인수는 BOS 서버(로컬 수퍼유저 <B>루트</B>로
실행)에 대한 PATH 환경 변수에 보통 AFS 2진 파일로의 경로가 들어 있지
않으므로 <B>vos</B> 2진 파일에 대한 완전한 경로 이름을
지정한다는 점을 알아 두십시오.
<PRE>   
   % <B>bos create fs3.abc.com backupusers cron</B>  \
     <B>-cmd "/usr/afs/bin/vos backupsys  -prefix user -localauth" "1:00"</B>
    
</PRE>
<A NAME="IDX6543"></A>
<A NAME="IDX6544"></A>
<A NAME="IDX6545"></A>
<P><H3><A NAME="HDRWQ204" HREF="auagd002.htm#ToC_221">백업 볼륨의 내용을 사용자가 사용할 수 있게 만들기</A></H3>
<P>앞서 설명한 것처럼 백업 볼륨은 백업이 작성되었을 때의 읽기/쓰기 원본의
상태를 보존합니다. 많은 셀은 사용자가 관리자의 도움을 요청하지 않고
마지막 백업이 작성된 후에 실수로 삭제했거나 변경한 데이터를 액세스하고
복원할 수 있도록 백업 볼륨을 마운트하도록 선택합니다. 사용자 볼륨의 백업
버전을 마운트하기 가장 적절한 위치는 사용자의 홈 디렉토리의 하위 디렉토리입니다.
이 디렉토리에 대한 적절한 이름에는 <B>OldFiles</B>와
<B>Backup</B>이 포함됩니다. 이 하위 디렉토리는 백업이 작성되었을
때의 형태 그대로 사용자 자신의 홈 디렉토리와 같은 모양을 가지며 모든 파일과
디렉토리가 동일한 상대적 위치에 있습니다.
<P>사용자를 위한 백업 볼륨을 작성하여 마운트하는 경우 사용자에게 백업 볼륨이
작성되었음을 알리십시오. <I>AFS 사용자 안내서</I>에서는 사용자가 백업 볼륨을 사용할 수
있게 하는지 여부가 선택적이므로 백업 볼륨을 언급하지 않습니다. 새 백업을
생성하는 빈도를 사용자에게 알려서 복구할 수 있는 볼륨을 알 수 있게 하십시오.
백업 볼륨의 데이터는 변경될 수 없다는 점을 상기시켜 표준 UNIX <B>cp</B>
명령을 사용하여 홈 볼륨으로 그 데이터를 복사하고 거기에서 수정할 수 있게
하십시오. 백업 볼륨에 데이터가 읽기/쓰기 볼륨 할당량에 포함되지 않는다는
점을 다시 한번 알려 주십시오.
<P><H3><A NAME="HDRWQ205" HREF="auagd002.htm#ToC_222">백업 볼륨을 작성 및 마운트하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>볼륨을 마운트하려는 디렉토리의 ACL에 대해 <B>insert</B>(<B>i</B>) 및 <B>administer</B> (<B>a</B>) 권한이
있는지 확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
<A NAME="IDX6546"></A>
<A NAME="IDX6547"></A>
</LI><LI><A NAME="LIWQ206"></A><B>vos backup</B> 명령을 실행하여
읽기/쓰기 원본 볼륨의 백업 버전을 작성하십시오. 표시되는 메시지는 백업
조작의 성공을 확인해 줍니다.
<P>
<PRE>   
   % <B>vos backup</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   Created backup volume for <VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>backup
</B><DD>전체를 입력해야 합니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 백업할 읽기/쓰기 볼륨을 식별합니다.
백업 볼륨은 <B>.backup</B> 확장자를 추가한 동일한 이름을
가집니다. 또한 자체의 볼륨 ID 번호를 가집니다.
</DL>
<A NAME="IDX6548"></A>
<A NAME="IDX6549"></A>
</LI><LI><A NAME="LIWQ207"></A><B>(선택적)</B> <B>fs mkmount</B> 명령을 실행하여 백업 볼륨을 마운트하십시오. 이 단계가
선택적이지만 캐쉬 관리 프로그램은 볼륨이 마운트되지 않으면 볼륨의 내용을
액세스할 수 없다는 점을 알아 두십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>><B>.backup</B>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>mk
</B><DD>허용되는 <B>mkmount</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>directory</VAR>
</B><DD>작성할 마운트 포인트를 명명합니다. 미리 동일한 이름을 가진 파일이나
디렉토리를 작성하지 마십시오. 부분 경로 이름은 현재 작업 디렉토리에 상대적으로 해석됩니다.
사용자 볼륨의 백업 버전의 경우 일반적인 위치는 사용자의 홈 디렉토리입니다.
<P><DT><B><VAR>volume name</VAR><B>.backup</B>
</B><DD>백업 볼륨의 전체 이름입니다.
</DL>
</LI><LI><B>(선택적)</B> <B>fs lsmount</B> 명령을
실행하여 마운트 포인트가 올바른 볼륨을 참조하는지 확인하십시오.
<A HREF="#HDRWQ211">마운트 포인트를 표시하려면</A>에 나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>fs lsmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
</LI></OL>
<A NAME="IDX6550"></A>
<A NAME="IDX6551"></A>
<P><H3><A NAME="Header_223" HREF="auagd002.htm#ToC_223">한 번에 여러 백업 볼륨을 작성하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>vos backupsys</B> 명령을 실행하여 동일한 접두어나
사이트를 공유하는 모든 읽기/쓰기 볼륨의 백업 버전을 작성하십시오.
세 가지 인수를 조합해서 사용할 때의 결과는 <A HREF="#HDRWQ202">한 번에 여러 볼륨 백업</A>에서
설명합니다.
<P>
<PRE>   % <B>vos backupsys</B> [<B>-prefix</B> &lt;<VAR>common&nbsp;prefix&nbsp;on&nbsp;volume(s)</VAR>><SUP>+</SUP>]   \
        [<B>-server</B> &lt;<VAR>machine&nbsp;name</VAR>>]
[<B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>]  \
        [<B>-exclude</B>]   [<B>-xprefix</B> &lt;<VAR>negative&nbsp;prefix&nbsp;on&nbsp;volume(s)</VAR>><SUP>+</SUP>] 
        [<B>-dryrun</B>]  [<B>-verbose</B>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>backups
</B><DD>허용되는 <B>backupsys</B>의 가장 짧은 축약형입니다.
<P><DT><B>-prefix
</B><DD>임의의 길이를 가진 하나 이상의 단순 문자 스트링이나 볼륨 표현식을
지정합니다. 그 이름에 해당 문자열이 들어 있는 볼륨은 클론될 볼륨의
목록에 추가됩니다. 적절한 경우 필드 분리자(예: 마침표)를 포함시키십시오.
이 인수는 <B>-server</B>, <B>-partition</B>, <B>-exclude</B> 및 <B>-xprefix</B> 옵션을 임의로 조합하여 함께
사용할 수 있습니다.
<P><DT><B>-server
</B><DD>백업할 볼륨을 저장하는 파일 서버 시스템을 지정합니다. 이 인수는
<B>-prefix</B>,
<B>-partition</B>, <B>-exclude</B> 및
<B>-xprefix</B> 옵션을 조합하여 함께 사용할 수 있습니다.
<P><DT><B>-partition
</B><DD>백업하려는 볼륨이 있는 파티션을 지정합니다. 이 인수는
<B>-prefix</B>,
<B>-server</B>, <B>-exclude</B> 및 <B>-xprefix</B> 옵션을 조합해서 함께 사용할 수 있습니다.
<P><DT><B>-exclude
</B><DD><B>-prefix</B> 인수가 설정된 볼륨을 제외한 모든
볼륨이 백업되도록 지정합니다. <B>-prefix</B> 인수를
이 인수와 함께 사용해야 합니다. 또한 <B>-prefix</B>, <B>-server</B> 및 <B>-partition</B> 인수와 조합해서 또는
<B>-prefix</B> 및 <B>-xprefix</B> 인수를
모두 사용해서 사용할 수 있으나 <B>-xprefix</B> 인수만
사용하면 안됩니다.
<P><DT><B>-xprefix
</B><DD>임의의 길이를 가진 하나 이상의 단순 문자 스트링이나 볼륨 표현식을
지정합니다. 그 이름에 해당 문자열이 들어 있지 않은 볼륨이 클론될 볼륨의
목록에 추가됩니다. <B>-prefix</B>, <B>-server</B>
및 <B>-partition</B> 인수와 함께 조합해서 사용할 수 있으며
<B>-prefix</B>와 <B>-exclude</B> 옵션을
함께 사용해야 하지만 <B>-exclude</B> 플래그만 단독으로
포함시킬 수는 없습니다.
<P><DT><B>-dryrun
</B><DD>실제로 볼륨을 클론하지는 않으면서 클론될 볼륨 목록을 표준 출력
스트림에 표시합니다.
<P><DT><B>-verbose
</B><DD><B>-dryrun</B> 플래그와 함께 사용되는 경우 볼륨을
선택하는 데 사용되는 기준을 요약하는 문장을 표준 출력 스트림에 표시합니다.
이 플래그와 함께 사용되지 않으면 각 볼륨에 대한 클로닝 조작을 추적합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ208" HREF="auagd002.htm#ToC_224">볼륨 마운트</A></H2>
<A NAME="IDX6552"></A>
<P>마운트 포인트는 <A HREF="#HDRWQ183">볼륨 마운트에 대하여</A>에서 설명하는 것처럼 AFS
파일 공간에서 AFS 볼륨의 내용을 볼 수 있고 액세스할 수 있게 해 줍니다.
이 절에서는 캐쉬 관리 프로그램이 파일 공간을 지나갈 때 마운트 포인트를
처리하는 방법을 좀 더 자세히 설명합니다. 또한 세 가지 유형의 마운트 포인트,
그 목적 및 이들 유형을 구별하는 방법을 설명하고 마운트 포인트를 작성,
제거 및 검토하는 지침을 제공합니다.
<P><H3><A NAME="HDRWQ209" HREF="auagd002.htm#ToC_225">마운트 포인트 통과 규칙</A></H3>
<P>캐쉬 관리 프로그램은 AFS 파일을 통과하여 마운트 포인트를 만났을 때
다음의 세 가지 기본 규칙을 준수합니다.
<UL>
<LI><B>규칙 1:</B> 지정될 때 백업 및 읽기 전용 볼륨 액세스
<P>
<P>캐쉬 관리 프로그램이 <B>.readonly</B> 또는 <B>.backup</B> 확장자를 사용하여 볼륨을 지정하는 마운트 포인트를 만날 때
해당 유형의 볼륨만 액세스합니다. 마운트 포인트에 <B>.backup</B>
또는 <B>.readonly</B> 확장자가 없으면 캐쉬 관리 프로그램은
규칙 2와 3을 사용합니다.
<P>
<P>예를 들어 캐쉬 관리 프로그램은 마운트 포인트가 백업 버전을 명명하는 경우
볼륨의 읽기/쓰기 버전을 절대로 액세스하지 않습니다. 지정된 버전을 액세스할
수 없는 경우 캐쉬 관리 프로그램은 오류를 보고합니다.
</LI><LI><B>규칙 2:</B> 가능할 때 읽기 전용 경로를 따라가기
<P>
<P>마운트 포인트가 읽기 전용 볼륨에 위치하고 참조하는 볼륨이 복제되면
캐쉬 관리 프로그램은 볼륨의 읽기 전용 사본을 액세스하려고 합니다.
참조된 볼륨이 복제되지 않으면 캐쉬 관리 프로그램은 읽기/쓰기 사본을
액세스합니다. 따라서 캐쉬 관리 프로그램은 파일 공간을 통한
<I>읽기 전용 경로</I>를 선호하여 가능할 때 읽기 전용
볼륨을 액세스합니다.
<P>
<P>캐쉬 관리 프로그램은 <B>root.afs</B> 볼륨의 읽기 전용
사본이 있는 경우 이 사본을 항상 액세스하므로 처음에는 읽기 전용 경로에서
시작합니다. 볼륨은 셀의 AFS 파일 공간의 루트(일반적으로
<B>/afs</B>라고 명명됨)에 마운트됩니다.
즉 <B>root.afs</B> 볼륨이 복제되면 캐쉬 관리 프로그램은
읽기/쓰기 사본이 아닌 읽기 전용 사본을 액세스하려고 합니다. 이 규칙은
연속되는 각 볼륨이 복제되는 한 캐쉬 관리 프로그램이 읽기 전용 경로를
계속 따라가게 합니다. 이것은 캐쉬 관리 프로그램이 AFS 파일 공간
아래에 마운트된 복제 복륨을 액세스하기 위해 <B>root.afs</B> 및
<B>root.cell</B> 볼륨이 복제되어야 함을 의미합니다.
볼륨은 일반적으로 각각 <B>/afs</B> 및 <B>/afs/</B><VAR>cellname</VAR>
디렉토리에 마운트됩니다.
</LI><LI><B>규칙 3:</B> 읽기/쓰기 경로에만 위치
<P>
<P>마운트 포인트가 읽기/쓰기 볼륨에 위치하고 볼륨 이름에 <B>.readonly</B>
또는 <B>.backup</B> 확장자가 없는 경우 캐쉬 관리 프로그램은
볼륨의 읽기/쓰기 버전만 액세스하려고 합니다. 이 액세스 시도는 읽기 전용
버전을 액세스할 수 있는 경우에도 읽기/쓰기 버전을 액세스할 수 없는 경우
오류를 발생하면서 실패합니다. 이 상황에서 캐쉬 관리 프로그램은
<I>읽기/쓰기 경로</I>에 위치하며 마운트 포인트가
<B>.readonly</B> 확장자를 사용하여 볼륨을 명시적으로 명명하지
않는 한 읽기 전용 경로로 다시 되돌아갈 수 없습니다(셀
방식의 마운트 포인트는 다음에서 설명하는 것처럼 이 규칙의 중요한 예외 상황이 됩니다).
</LI></UL>
<P><H3><A NAME="HDRWQ210" HREF="auagd002.htm#ToC_226">세 가지 유형의 마운트 포인트</A></H3>
<P>AFS는 캐쉬 관리 프로그램에서 처리하는 방식으로 인해 각각이 다른 목적에
적합한 세 가지 유형의 마운트 포인트를 사용합니다.
<UL>
<LI>캐쉬 관리 프로그램은 <I>일반</I> 마운트 포인트를 통과할
때 앞서 설명한 세 가지 마운트 포인트 통과 규칙을 모두 준수합니다.
<A NAME="IDX6553"></A>
<A NAME="IDX6554"></A>
<P>
<P>
<P>AFS는 파일 공간의 대다수의 마운트 포인트가 일반 마운트 포인트일 때 최상으로
수행됩니다. 왜냐하면 마운트 포인트 통과 규칙은 복제 및 비복제 볼륨의
사용을 가장 효율적으로 만들어주기 때문입니다. 복제된 볼륨의 읽기 전용 사본이
여러 개 있을 확률이 있으므로 캐쉬 관리 프로그램이 단일 읽기/쓰기 버전을
액세스하는 것보다 읽기 전용 사본 중 하나를 액세스하는 것이 더 쉬운
것으로 생각되며 두 번째 규칙은 이러한 경향을 유도합니다. 볼륨이 복제되지
않은 경우 세 번째 규칙은 사용할 수 있는 읽기/쓰기 볼륨 유형이 하나만
있을 때 이 읽기/쓰기 볼륨을 여전히 액세스할 수 있음을 의미합니다. 즉,
일반 마운트 포인트는 강제로 캐쉬 관리 프로그램이 읽기 전용 볼륨(명시적으로는
"읽기 전용 마운트 포인트"이 아님)을 항상 액세스하게 하지 않습니다.
<P>
<P>일반 마운트 포인트를 작성하려면 <A HREF="#HDRWQ212">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A>에서 설명하는 것처럼
<B>fs mkmount</B> 명령을 사용하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">캐쉬 관리 프로그램이 일반 마운트 포인트에 의해 명명된 복제
볼륨의 읽기 전용 버전을 액세스할 수 있게 하려면 경로 이름에서 그 위에
마운트된 모든 볼륨 역시 복제되어야 합니다. 이것은 캐쉬 관리 프로그램이 목표
볼륨으로의 읽기 전용 경로에만 계속 위치할 수 있는 유일한 방법입니다.
</TD></TR></TABLE>
</LI><LI>캐쉬 관리 프로그램은 <I>읽기/쓰기</I> 마운트 포인트를
통과할 때 마운트 포인트에 명명된 볼륨 버전만 액세스하려고 합니다.
볼륨 이름이 기본(읽기/쓰기) 양식으로 <B>.readonly</B>
또는 <B>.backup</B> 확장자를 가지지 않은 경우 캐쉬
관리 프로그램은 볼륨이 복제된 경우에도 볼륨의 읽기/쓰기 버전을 액세스합니다.
즉 캐쉬 관리 프로그램은 읽기/쓰기 마운트 포인트를 통과할 때 두 번째 마운트 포인트
통과 규칙을 무시하고 파일 공간을 통한 읽기/쓰기 경로로 전환합니다.
<A NAME="IDX6555"></A>
<A NAME="IDX6556"></A>
<P>
<P>
<P>셀의 파일 공간에 하나의 읽기/쓰기 마운트 포인트만 작성하고 이를 사용하여
셀의 <B>root.cell</B> 볼륨을 AFS 파일 공간 루트(일반적으로
<B>/afs/.</B><VAR>cellname</VAR>) 바로 아래에 마운트하는 것이
일반적입니다. 앞서 지적한 것처럼 읽기/쓰기 마운트 포인트 이름 맨 앞에
마침표를 두는 것이 일반적입니다(예: <B>/afs/.abc.com</B>).
이 마침표는 읽기/쓰기 마운트 포인트를 동일한 레벨의 <B>root.cell</B>
볼륨에 대한 일반 마운트 포인트와 구분해 줍니다. 이것은 동일한 볼륨에 대해 두 개의
마운트 포인트를 작성하는 것이 일반적인 유일한 경우에 해당합니다. 이러한
읽기/쓰기 마운트 포인트에 대한 명명 규칙이 제시하는 바람직한 부가 효과는
마운트 포인트가 <B>-a</B> 플래그가 포함되지 않는 한
UNIX <B>ls</B> 명령의 출력에 나타나지 않으므로 이 지점을
사용하지 않는 일반 사용자들은 볼 수 없다는 것입니다.
<P>
<P>파일 공간의 이 지점에 하나의 읽기/쓰기 지점이 있는 경우 캐쉬 관리 프로그램이
파일 공간 맨 위의 읽기/쓰기 경로를 따라가게 되므로 필요할 때 모든 볼륨의
읽기/쓰기 버전을 액세스할 수 있게 됩니다.
동시에 <B>root.cell</B> 볼륨에 대한 일반 마운트 포인트는
대부분의 경우에 캐쉬 관리 프로그램이 읽기 전용 경로를 따라가게 합니다.
<P>
<P>읽기 전용 또는 백업 볼륨에 대해 하나의 읽기/쓰기 마운트 포인트를 사용하는 것은
가능하지만 반드시 그렇게 할 필요는 없습니다. 첫 번째 마운트 포인트 통과 규칙에서는
일반 마운트 포인트의 볼륨 이름이 <B>.readonly</B> 또는
<B>.backup</B> 확장자를 가지는 경우 캐쉬 관리 프로그램이
이들 볼륨을 액세스하도록 지정하고 있습니다.
<P>
<P>읽기/쓰기 마운트 포인트를 작성하려면 <A HREF="#HDRWQ212">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A>에서 설명하는
것처럼 <B>fs mkmount</B> 명령에서 <B>-rw</B> 플래그를 사용하십시오.
</LI><LI>캐쉬 관리 프로그램은 <I>셀 방식</I> 마운트 포인트를
통과할 때 일반적으로 외부 셀에 해당하는 지정된 셀에 있는 지정된 볼륨을
액세스합니다(마운트 포인트가 볼륨과 함께 셀을 명명하지 않는 경우 캐쉬
관리 프로그램은 마운트 포인트가 위치하는 셀에 있는 볼륨을 액세스합니다).
일반 셀 방식의 마운트 포인트를 통과할 때 캐쉬 관리 프로그램은 세 번째
마운트 포인트 통과 규칙을 무시합니다. 대신 마운트 포인트가 있는 볼륨이
읽기/쓰기 볼륨인 경우에도 볼륨이 복제되었으면 읽기 전용 버전을 액세스합니다.
<P>
<P>읽기/쓰기 경로를 통과하면 외부 셀의 서버 시스템에 불필요한 부하가 부과되므로
읽기/쓰기 셀 방식의 마운트 포인트를 작성하여 이 동작을 무시하는 것은
바람직하지 않습니다. 파일 서버는 읽기 전용 볼륨에 필요한 단일 콜백 대신
읽기/쓰기 볼륨으로부터 페치된 각 파일에 대해 콜백을 실행해야 합니다.
두 경우 모두 셀 자체의 관리자는 복제된 볼륨의 읽기/쓰기 버전을 액세스해야
합니다.
<A NAME="IDX6557"></A>
<A NAME="IDX6558"></A>
<A NAME="IDX6559"></A>
<P>
<P>
<P>셀의 파일 공간의 두 번째 레벨에만 셀 방식의 마운트 포인트를 작성하고 이를
사용하여 AFS 파일 공간 루트(일반적으로 <B>/afs/</B><VAR>foreign_cellname</VAR>) 바로 아래에 외부 셀의 <B>root.cell</B>
볼륨을 마운트하는 것이 일반적입니다. 마운트 포인트를 사용하면
<A HREF="auagd015.htm#HDRWQ406">데이터베이스 서버 시스템 정보 유지</A>에서 설명하는 것처럼 로컬 사용자들은 외부 셀의
파일 공간을 액세스할 수 있으며 볼륨의 루트 디렉토리의 ACL에 대해 필요한
권한이 있으며 로컬 클라이언트 시스템의 <B>/usr/vice/etc/CellServDB</B> 파일에 외부 셀에 대한 항목이 있다고 가정합니다.
<P>
<P>파일 공간의 다른 레벨에 셀 방식의 마운트 포인트를 작성하고 <B>root.cell</B>
볼륨 이외의 외부 볼륨을 마운트하는 것은 별로 적절하지 않습니다.
캐쉬 관리 프로그램은 경로 이름의 다양한 지점에 있는 셀 간을 전환하는
경우 사용자에게 혼란을 줄 수 있습니다.
<P>
<P>일반 셀 방식의 마운트 포인트를 작성하려면 <A HREF="#HDRWQ213">셀 방식 마운트 포인트를 작성하려면</A>에서
설명하는 것처럼 <B>-cell</B> 인수를 사용하여 셀 이름을
지정하십시오.
</LI></UL>
<P>마운트 포인트를 검토하려면 <A HREF="#HDRWQ211">마운트 포인트를 표시하려면</A>에서 설명하는 것처럼
<B>fs lsmount</B> 명령을 사용하십시오. 명령의 출력은
구분 표기를 사용하여 일반, 읽기/쓰기 및 셀 방식의 마운트 포인트를 식별합니다.
마운트 포인트를 제거하려면 <A HREF="#HDRWQ215">마운트 포인트를 제거하려면</A>에서 설명하는 것처럼
<B>fs rmmount</B> 명령을 사용하십시오.
<P><H3><A NAME="Header_227" HREF="auagd002.htm#ToC_227">외부 셀에 마운트 포인트 작성</A></H3>
<P>외부 셀의 파일 공간에 마운트 포인트를 작성하는 것은(로컬 셀에 외부 볼륨을
마운트하는 것과는 반대임) 로컬 파일 공간에 마운트 포인트를 작성하는 것과
동일합니다. 차이점은 <B>fs mkmount</B> 명령의 <VAR>directory</VAR>
인수가 로컬 셀이 아닌 외부 셀의 경로 이름을 지정한다는 것과 마운트 포인트를
작성하는 외부 디렉토리의 ACL에 대해 필요한 권한이 있어야 한다는 것입니다.
<B>fs mkmount</B> 명령의 <B>-cell</B> 인수는 항상 마운트 포인트를 작성할 셀이 아니라 볼륨이 위치하는
셀을 지정합니다.
<P><H3><A NAME="HDRWQ211" HREF="auagd002.htm#ToC_228">마운트 포인트를 표시하려면</A></H3>
<A NAME="IDX6560"></A>
<A NAME="IDX6561"></A>
<A NAME="IDX6562"></A>
<A NAME="IDX6563"></A>
<A NAME="IDX6564"></A>
<A NAME="IDX6565"></A>
<OL TYPE=1>
<LI><B>fs lsmount</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs lsmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>ls
</B><DD>허용되는 <B>lsmount</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>directory</VAR>
</B><DD>표시할 마운트 포인트를 명명합니다.
</DL>
</LI></OL>
<P>지정된 디렉토리가 마운트 포인트이면 출력은 다음 양식을 가집니다.
<PRE>   '<VAR>directory</VAR>' is a mount point for volume '<VAR>volume&nbsp;name</VAR>'
   
</PRE>
<P>일반 마운트 포인트의 경우 <B>abc.com</B> 셀의 클라이언트
시스템에 대해 실행된 다음 예제 명령에서처럼 숫자 기호(<TT>#</TT>)가
<VAR>volume name</VAR> 문자열 앞에 사용됩니다.
<PRE>   
   % <B>fs lsmount /afs/abc.com/usr/terry</B>
   '/afs/abc.com/usr/terry' is a mount point for volume '#user.terry'
      
</PRE>
<P>읽기/쓰기 마운트 포인트의 경우 <B>abc.com</B> 셀의 클라이언트
시스템에 대해 실행된 다음 예제 명령에서처럼 퍼센트 기호(<TT>%</TT>)가
<VAR>volume name</VAR> 문자열 앞에 사용됩니다. 셀의 관리자는 읽기/쓰기
마운트 포인트의 이름 앞에 마침표를 사용하는 규칙을 따라 왔습니다.
<PRE>   
   % <B>fs lsmount /afs/.abc.com </B>
   '/afs/.abc.com' is a mount point for volume '%root.cell'
   
</PRE>
<P>셀 방식의 마운트 포인트의 경우 <B>abc.com</B> 셀의 클라이언트
시스템에 대해 실행된 다음 예제 명령에서처럼 셀 이름과 콜론(<TT>:</TT>)이
숫자 다음에 나오고 <VAR>volume name</VAR> 문자열 앞에 사용됩니다.
<PRE>   
    % <B>fs lsmount /afs/ghi.gov </B>
   '/afs/ghi.gov' is a mount point for volume '#ghi.gov:root.cell'
   
</PRE>
<P>마운트 포인트로의 기호 연결의 경우 출력은 <B>abc.com</B>
셀의 클라이언트 시스템에 대해 실행된 다음 예제 명령에서 볼 수 있는 양식을
가집니다.
<PRE>   
   % <B>fs lsmount /afs/abc</B>
   '/afs/abc' is a symbolic link, leading to a mount point for volume '#root.cell'
   
</PRE>
<P>디렉토리가 마운트 포인트가 아니고 AFS에 있지 않으면 출력은 다음과 같이
나타납니다.
<PRE>   '<VAR>directory</VAR>' is not a mount point.
   
</PRE>
<P>출력이 뒤죽박죽되는 경우 마운트 포인트가 로컬 캐쉬에서 손상된 것일 수
있습니다. <A HREF="auagd015.htm#HDRWQ413">하나 이상의 마운트 포인트 플러쉬하기</A>에서 설명하는 것처럼
<B>fs flushmount</B> 명령을 사용하십시오. 이 명령은
강제로 캐쉬 관리 프로그램이 마운트 포인트를 다시 페치하게 합니다.
<P><H3><A NAME="HDRWQ212" HREF="auagd002.htm#ToC_229">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A></H3>
<A NAME="IDX6566"></A>
<A NAME="IDX6567"></A>
<A NAME="IDX6568"></A>
<A NAME="IDX6569"></A>
<A NAME="IDX6570"></A>
<A NAME="IDX6571"></A>
<OL TYPE=1>
<LI>마운트 포인트를 배치하려는 디렉토리의 ACL에 대해
<B>i</B>(<B>insert</B>) 및
<B>a</B>(<B>administer</B>) 권한이 있는지
확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
</LI><LI><B>fs mkmount</B> 명령을 실행하여 마운트 포인트를
작성하십시오. 읽기/쓰기 마운트 포인트를 작성하는 경우
<B>-rw</B> 플래그를 포함시키십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>>  [<B>-rw</B>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>mk
</B><DD>허용되는 <B>mkmount</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>directory</VAR>
</B><DD>작성할 마운트 포인트를 명명합니다. 동일한 이름을 가진 파일이나
디렉토리는 존재하면 안됩니다. 부분 경로 이름은 현재 작업 디렉토리에
상대적으로 해석됩니다.
<P>
<P>마운트 포인트에 대한 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에 새
마운트 포인트를 작성하려고 할 때 발생하는 장애를 피하십시오. 일반적으로
경로 이름의 두 번째 레벨의 셀 이름 앞에 마침표를 사용하여 읽기/쓰기 경로를
나타내십시오(예를 들어 <B>/afs/.abc.com</B>). 파일 경로를
통한 읽기/쓰기 및 읽기 전용 경로의 개념에 대해 좀더 살펴 보려면
<A HREF="#HDRWQ209">마운트 포인트 통과 규칙</A>을 참조하십시오.
<P><DT><B><VAR>volume name</VAR>
</B><DD><B>.backup</B> 또는 <B>.readonly</B>
확장자를 백업 또는 읽기 전용 볼륨에 포함시켜 볼륨의 전체 이름을 지정합니다.
<P><DT><B>-rw
</B><DD>읽기/쓰기 마운트 포인트를 작성합니다.
</DL>
</LI></OL>
<P><H3><A NAME="HDRWQ213" HREF="auagd002.htm#ToC_230">셀 방식 마운트 포인트를 작성하려면</A></H3>
<A NAME="IDX6572"></A>
<A NAME="IDX6573"></A>
<A NAME="IDX6574"></A>
<OL TYPE=1>
<LI>마운트 포인트를 배치하려는 디렉토리의 ACL에 대해
<B>i</B>(<B>insert</B>) 및
<B>a</B>(<B>administer</B>) 권한이 있는지
확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
</LI><LI><A NAME="LIWQ214"></A>파일 공간의 두 번째 레벨에 하나 이상의 외부
셀의 <B>root.cell</B> 볼륨을 마운트하며 셀의
<B>root.afs</B> 볼륨이 복제된 경우 ACL이 사용자에게
<B>i</B> 및 <B>a</B> 권한을 부여한 디렉토리에
<B>root.afs</B> 볼륨의 읽기/쓰기 버전에 대한
임시 마운트 포인트를 작성해야 합니다. 다음 명령은 셀의 <B>/afs/.</B><VAR>cellname</VAR>
디렉토리에 <B>new_cells</B>라는 마운트 포인트를
작성합니다(셀의 읽기/쓰기 경로에 대한 진입점).
<P>
<P><VAR>cellname</VAR>을 셀 이름으로 대체하십시오.
<P>
<PRE>   
   % <B>cd /afs/.</B><VAR>cellname</VAR>
   
   % <B>fs  mkmount  new_cells  root.afs</B>
 
   % <B>cd  new_cells</B>
   
</PRE>
</LI><LI><B>fs mkmount</B> 명령을 <B>-cell</B> 인수와 함께 실행하여 셀 방식의 마운트 포인트를 작성하십시오.
필요한 만큼 각 셀 방식의 마운트 포인트에 대해 이 명령을 반복하십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>> <B>-cell</B> &lt;<VAR>cell&nbsp;name</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>mk
</B><DD>허용되는 <B>mkmount</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>directory</VAR>
</B><DD>작성할 마운트 포인트를 명명합니다. 동일한 이름을 가진 파일이나
디렉토리는 존재하면 안됩니다. 부분 경로 이름은 현재 작업 디렉토리에
상대적으로 해석됩니다. 외부 셀의 <B>root.cell</B>
볼륨을 마운트하는 경우 이 인수의 표준 값은 셀의 완전한 인터넷 도메인
이름입니다.
<P><DT><B><VAR>volume name</VAR>
</B><DD>볼륨의 전체 이름을 지정하는 데 보통 셀 방식의 마운트 포인트의
경우 <B>root.cell</B>이 됩니다.
<P><DT><B>-cell
</B><DD>볼륨이 위치하는 셀의 완전한 인터넷 도메인 이름을 지정합니다.
</DL>
</LI><LI>단계 <A HREF="#LIWQ214">2</A>의 지침을 따른 경우
<B>vos release</B> 명령을 실행하여 <B>root.afs</B>
볼륨의 새 버전을 읽기 전용 사이트로 릴리스하십시오(이 명령을 사용하려면
사용자가 셀의 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있어야 합니다. 필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 설명하는 것처럼
<B>bos listusers</B> 명령을 실행하여 확인하십시오).
<P>
<P>또한 <B>fs checkvolumes</B> 명령을 실행하여 강제로
캐쉬 관리 프로그램이 <B>root.afs</B> 볼륨의 새 복사본을
액세스하게 하십시오. 원하는 경우 또한 <B>/afs/.</B><VAR>cellname</VAR> 디렉토리로부터 <B>new_cells</B> 마운트 포인트를
제거할 수도 있습니다.
<P>
<PRE>     
   % <B>vos release root.afs</B>
   
   %  <B>fs checkvolumes</B>
   
   % <B>cd /afs/.</B><VAR>cellname</VAR>
    
   % <B>fs rmmount new_cells</B>
   
   
</PRE>
<P>
<P>사용자가 새로 마운트된 외부 셀을 액세스하게 하려면 각 클라이언트 시스템의
로컬 <B>/usr/vice/etc/CellServDB</B> 파일에 이에 대한
항목을 작성하고 시스템을 재부트하거나 <B>fs newcell</B>
명령을 사용하여 이 항목을 직접 커널 메모리에 삽입해야 합니다.
<A HREF="auagd015.htm#HDRWQ406">데이터베이스 서버 시스템 정보 유지</A>의 지침을 따르십시오.
</LI></OL>
<P><H3><A NAME="HDRWQ215" HREF="auagd002.htm#ToC_231">마운트 포인트를 제거하려면</A></H3>
<A NAME="IDX6575"></A>
<A NAME="IDX6576"></A>
<A NAME="IDX6577"></A>
<A NAME="IDX6578"></A>
<A NAME="IDX6579"></A>
<OL TYPE=1>
<LI>마운트 포인트를 제거하려는 디렉토리의 ACL에 대해
<B>d</B>(<B>delete</B>) 권한이 있는지
확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI><B>fs rmmount</B> 명령을 실행하여 마운트 포인트를
제거하십시오. 해당 볼륨이 여전히 존재하면 이것이 유일한 마운트 포인트인
경우 그 내용을 액세스할 수 없습니다.
<P>
<PRE>   
   % <B>fs rmmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>rm
</B><DD>허용되는 <B>rmmount</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>directory</VAR>
</B><DD>제거할 마운트 포인트를 명명합니다. 부분 경로 이름은 현재
작업 디렉토리에 상대적으로 해석됩니다.
<P>
<P>마운트 포인트에 대한 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 마운트 포인트를
삭제하려고 할 때 발생하는 장애를 피하십시오. 일반적으로
경로 이름의 두 번째 레벨의 셀 이름 앞에 마침표를 사용하여 읽기/쓰기 경로를
나타내십시오(예를 들어 <B>/afs/.abc.com</B>). 파일 경로를
통한 읽기/쓰기 및 읽기 전용 경로의 개념에 대해 좀더 살펴 보려면
<A HREF="#HDRWQ209">마운트 포인트 통과 규칙</A>을 참조하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ216" HREF="auagd002.htm#ToC_232">볼륨 정보 표시</A></H2>
<A NAME="IDX6580"></A>
<A NAME="IDX6581"></A>
<P>이 절에서는 볼륨에 대한 정보를 표시하는 방법을 설명합니다. 볼륨의 이름이나
볼륨의 ID 번호를 아는 경우 VLDB 항목, 볼륨 헤더 또는 둘다를 표시하기
위한 명령이 있습니다. 다른 명령은 지정된 파일이나 디렉토리를 포함하는
볼륨의 이름이나 위치를 표시합니다.
<P>볼륨의 할당량을 표시하는 것에 대한 지침을 보려면
<A HREF="#HDRWQ234">볼륨 할당량과 현재 크기 설정 및 표시</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ217" HREF="auagd002.htm#ToC_233">VLDB 항목 표시</A></H3>
<A NAME="IDX6582"></A>
<A NAME="IDX6583"></A>
<A NAME="IDX6584"></A>
<A NAME="IDX6585"></A>
<P><B>vos listvldb</B> 명령은 사용자가 제공하는 인수 조합에
따라 볼륨에 대한 VLDB 항목을 표시합니다. 다음은 가장 가능성이 높은 경우부터
가장 낮은 경우까지를 설명한 것입니다.
<UL>
<LI>VLDB의 모든 항목을 표시하려면 인수를 제공하지 마십시오. 항목의 수에
따라 출력을 생성하는 데 시간이 오래 소요될 수 있습니다.
</LI><LI>특정 파일 서버 시스템을 볼륨의 사이트로 언급하는 모든 VLDB 항목을
표시하려면 <B>-server</B> 인수를 사용하여 시스템의 이름을
지정하십시오.
</LI><LI>임의의 파일 서버 시스템의 특정 파티션을 볼륨의 사이트로 언급하는 모든 VLDB
항목을 표시하려면 <B>-partition</B> 인수를 사용하여
파티션 이름을 지정하십시오.
</LI><LI>특정 파일 서버 시스템의 특정 파티션을 볼륨의 사이트로 언급하는
모든 VLDB 항목을 표시하려면 <B>-server</B> 및
<B>-partition</B> 인수를 함께 사용하십시오.
</LI><LI>단일 VLDB 항목을 표시하려면 <B>-name</B> 인수를 사용하여
볼륨 이름이나 ID 번호를 지정하십시오.
</LI><LI>잠겨져 있는 VLDB 항목이 있는 볼륨에 대해서만 VLDB 항목을 표시하려면
앞서 언급된 사이트 정의와 함께 <B>-locked</B> 플래그를
사용하십시오.
</LI></UL>
<A NAME="IDX6586"></A>
<A NAME="IDX6587"></A>
<P><H3><A NAME="HDRWQ218" HREF="auagd002.htm#ToC_234">VLDB 항목을 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>vos listvldb</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>vos listvldb</B>  [<B>-name</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>] [<B>-server</B> &lt;<VAR>machine&nbsp;name</VAR>>] \
                  [<B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>] [<B>-locked</B>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>listvl
</B><DD>허용되는 <B>listvldb</B>의 가장 짧은 축약형입니다.
<P><DT><B>-name
</B><DD>완전한 이름이나 볼륨 ID 번호로 하나의 볼륨을 식별합니다.
이 인수를 <B>-server</B> 또는 <B>-partition</B>
인수와 함께 사용하지 마십시오.
<P><DT><B>-server
</B><DD>파일 서버 시스템을 지정합니다. 원하는 경우 이 인수를
<B>-partition</B> 인수와 함께 사용해도 좋지만
<B>-name</B> 인수와 함께 사용하지는 않도록 하십시오.
<P><DT><B>-partition
</B><DD>파티션을 지정합니다. 원하는 경우 이 인수를 <B>-server</B> 인수와 함께 사용해도 좋지만 <B>-name</B> 인수와 함께 사용하지는 않도록 하십시오.
<P><DT><B>-locked
</B><DD>잠겨진 VLDB 항목만 표시합니다. 이 플래그를 다른 옵션과 조합해서
사용할 수 있습니다.
</DL>
</LI></OL>
<P>각 볼륨에 대한 VLDB 항목은 다음 정보를 포함합니다.
<UL>
<LI>기본 (읽기/쓰기) 볼륨 이름. 읽기 전용 및 백업 버전은 각각
<B>.readonly</B> 및 <B>.backup</B> 확장자를 가진 동일한 이름을 가집니다.
</LI><LI>읽기/쓰기에 경우 <TT>RWrite</TT>, 읽기 전용의 경우 <TT>ROnly</TT>, 백업의 경우 <TT>Backup</TT> 및 ReleaseClone의 경우
<TT>RClone</TT>이라는 필드에서 이미 존재하는 볼륨의 버전에 할당된 볼륨
ID 번호(필드가 나타나지 않으면 해당 버전의 볼륨이 존재하지 않는
것입니다). <TT>RClone</TT> 필드의 모양은 보통 릴리스 조작이 성공적으로
완료되지 못했음을 나타냅니다. <TT>Old release</TT> 및 <TT>New release</TT>
플래그는 다음에서 설명하는 하나 이상의 사이트 정의 행에도 나타납니다.
<A NAME="IDX6588"></A>
<A NAME="IDX6589"></A>
</LI><LI>볼륨의 읽기/쓰기 또는 읽기 전용 사본이 있는 사이트의 수로
문자열 <TT>number of sites -></TT> 다음에 나옵니다.
<A NAME="IDX6590"></A>
<A NAME="IDX6591"></A>
<A NAME="IDX6592"></A>
<A NAME="IDX6593"></A>
<A NAME="IDX6594"></A>
</LI><LI>볼륨의 읽기/쓰기 또는 읽기 전용 사본이 있는 각 사이트에 대한 행으로
파일 서버 시스템, 파티션 및 볼륨 유형을 지정합니다(읽기/쓰기의 경우
<TT>RW</TT> 또는 읽기 전용의 경우 <TT>RO</TT>).
백업 버전이 있는 경우 이 버전은 읽기/쓰기 사이트를 공유하는 것으로
인식됩니다. 사이트 정의에는 다음과 같은 몇몇 플래그가 사용될 수 있습니다.
<P>
<DL>
<A NAME="IDX6595"></A>
<P><DT><B><TT>Not released</TT>
</B><DD><B>vos addsite</B> 명령이 읽기 전용 사이트를 정의하는 데
사용된 이후에 <B>vos release</B> 명령이 실행되지 않았음을
나타냅니다.
<A NAME="IDX6596"></A>
<P><DT><B><TT>Old release</TT>
</B><DD><B>vos release</B> 명령이 성공적으로 완료되지
못했으며 이 사이트에 불필요한 이전 버전이 남이 있음을 나타냅니다.
<A NAME="IDX6597"></A>
<P><DT><B><TT>New release</TT>
</B><DD><B>vos release</B> 명령이 성공적으로 완료되지
못했으나 이 사이트가 올바른 새 볼륨 버전을 수신했음을 나타냅니다.
</DL>
</LI><LI>VLDB 항목이 잠겨 있으면 문자열 <TT>Volume is currently LOCKED</TT>가
나타납니다.
</LI></UL>
<P><TT>New release</TT> 및 <TT>Old release</TT> 플래그에 대한 자세한
설명을 보려면 <A HREF="#HDRWQ192">볼륨 복제(읽기 전용 볼륨 작성)</A>를 참조하십시오.
<P>이 명령의 예와 단일 볼륨에 대한 출력 결과는 다음과 같습니다.
<PRE>   
   % <B>vos listvldb user.terry</B>
   user.terry
       RWrite: 50489902    Backup: 50489904
       number of sites -> 1
          server fs3.abc.com partition /vicepc RW Site
  
</PRE>
<P><H3><A NAME="HDRWQ219" HREF="auagd002.htm#ToC_235">볼륨 헤더 표시</A></H3>
<A NAME="IDX6598"></A>
<A NAME="IDX6599"></A>
<P><B>vos listvol</B> 명령은 파일 서버 시스템의 하나 또는
전체 파티션의 모든 볼륨에 대한 볼륨 헤더를 표시합니다. <B>vos</B>
명령 인터프리터는 지정된 시스템의 볼륨 서버로부터 정보를 얻습니다.
<A HREF="#HDRWQ220">볼륨 헤더를 표시하려면</A>의 지침에 따라 <B>-fast</B>,
<B>-long</B> 또는 <B>-extended</B> 플래그
중 하나를 포함시켜 표시되는 정보의 양을 제어할 수 있습니다.
<P>단일 볼륨의 헤더만 표시하려면 <A HREF="#HDRWQ221">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A>에서
설명하는 것처럼 <B>vos examine</B> 명령을 실행하십시오.
<A NAME="IDX6600"></A>
<A NAME="IDX6601"></A>
<P><H3><A NAME="HDRWQ220" HREF="auagd002.htm#ToC_236">볼륨 헤더를 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>vos listvol</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>vos listvol</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>partition&nbsp;name</VAR>>] [<B>-fast</B>] [<B>-long</B>] [<B>-extended</B>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>listvo
</B><DD>허용되는 <B>listvol</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>볼륨 헤더를 표시할 파일 서버 시스템을 명명합니다. 이 인수를
단독으로 또는 <VAR>partition name</VAR> 인수와 함께 사용하십시오.
<P><DT><B><VAR>partition name</VAR>
</B><DD><VAR>machine name</VAR> 인수에 의해 명명되는 파일 서버 시스템의
하나의 파티션을 명명합니다. machine name 인수는 반드시 함께 사용되어야 합니다.
<P><DT><B>-fast
</B><DD>관련된 볼륨의 볼륨 ID 번호만 표시합니다. 이 플래그를
<B>-long</B> 또는 <B>-extended</B>
플래그와 함께 사용하지 마십시오.
<P><DT><B>-long
</B><DD>각 볼륨에 대한 보다 상세한 정보를 표시합니다. 이 플래그를
<B>-fast</B> 또는 <B>-extended</B>
플래그와 함께 사용하지 마십시오.
<P><DT><B>-extended
</B><DD><B>-long</B> 플래그에 의해 표시되는 모든 정보와
볼륨의 파일에 대한 읽기 및 쓰기에 관한 통계 테이블을 표시합니다.
이 플래그를 <B>-fast</B> 또는 <B>-long</B>
플래그와 함께 사용하지 마십시오.
</DL>
</LI></OL>
<P>출력은 볼륨 이름의 알파벳 순서대로 정렬되며 기본적으로 각 볼륨에 대해
단일 행으로 다음 정보가 제공됩니다.
<UL>
<LI>이름
</LI><LI>볼륨 ID 번호
<A NAME="IDX6602"></A>
</LI><LI>유형(플래그는 읽기/쓰기의 경우 <TT>RW</TT>, 읽기 전용의 경우
<TT>RO</TT>, 백업의 경우 <TT>BK</TT>임)
</LI><LI>킬로바이트 단위의 크기(<TT>1024</TT>는 1BM와 같음)
</LI><LI><B>-extended</B> 플래그가 제공된 경우 볼륨의 파일 수
<A NAME="IDX6603"></A>
</LI><LI>파일 서버 시스템의 상태로 다음 중 하나가 될 수 있습니다.
<P>
<DL>
<A NAME="IDX6604"></A>
<P><DT><B><TT>On-line</TT>
</B><DD>캐쉬 관리 프로그램에서 해당 볼륨을 완전히 액세스할 수 있습니다.
<A NAME="IDX6605"></A>
<P><DT><B><TT>Off-line</TT>
</B><DD>캐쉬 관리 프로그램에서 볼륨을 액세스할 수 없으나 손상된 것처럼
보이지는 않습니다. 이 상태는 예를 들어 볼륨이 덤프 중일 때 나타납니다.
<A NAME="IDX6606"></A>
<P><DT><B><TT>Off-line**needs salvage**</TT>
</B><DD>이 볼륨은 손상된 것처럼 보이므로 캐쉬 관리 프로그램에서 액세스할
수 없습니다. <B>bos salvage</B> 또는 <B>salvager</B> 명령을 사용하여 손상된 부분을 수정하십시오.
</DL>
</LI></UL>
<P>다음 메시지가 이전에 나열된 정보 대신 나타나면 이것은 클론이 작성되고
있는 상황과 같은 이유로 인해 캐쉬 관리 프로그램이나 <B>vos</B>
명령 인터프리터가 볼륨을 액세스할 수 없음을 나타냅니다.
<PRE>   **** Volume <VAR>volume_ID</VAR> is busy ****
</PRE>
<P>다음 메시지가 이전에 나열된 정보 대신 나타나면 이것은 볼륨이 심각하게
손상된 경우와 같은 상황에서 파일 서버가 볼륨을 접속할 수 없음을 나타냅니다.
파일 서버 시스템의 <B>/usr/afs/logs</B> 디렉토리에
있는 <B>FileLog</B> 및 <B>VolserLog</B>
로그 파일이 추가 정보를 제공할 수 있습니다. <B>bos getlog</B>
명령을 사용하여 이들 로그 파일을 표시하십시오.
<PRE>   **** Could not attach volume <VAR>volume_ID</VAR> ****
</PRE>
<P>(손상되었거나 접속할 수 없는 볼륨을 구조하는 방법에 대해서는
<A HREF="#HDRWQ232">볼륨 구조</A>를 참조하십시오.)
<P>개별 볼륨에 대한 정보는 요약 행으로 각괄호로 묶여서 표시됩니다.
출력의 첫째 행은 목록의 볼륨 수를 지정합니다.
출력의 마지막 행은 다음 예에서처럼 온라인, 오프라인 및 사용중 상태에
있는 볼륨의 수를 요약합니다.
<PRE>   
   % <B>vos listvol  fs2.abc.com /vicepb</B>
   Total number of volumes on server fs2.abc.com \
                                       partition /vicepb : 66
   sys                  1969534847 RW       1582 K On-line
   sys.backup           1969535105 BK       1582 K On-line
         .                   .     .         .   .    .
         .                   .     .         .   .    .
   user.pat             1969534536 RW      17518 K On-line
   user.pat.backup      1969534538 BK      17537 K On-line
   Total volumes onLine 66 ; Total volumes offLine 0 ;  Total busy 0
   
</PRE>
<P><B>-fast 플래그를 사용한 출력</B>
<P>
<A NAME="IDX6607"></A>
<B>-fast</B> 플래그를 포함시키면 다음 예에서처럼 숫자 순서 크기대로 정렬되는
각 볼륨의 볼륨 ID 번호만 표시됩니다. 마지막 행(온라인, 오프라인 및 사용중
볼륨의 수 요약)은 생략됩니다.
<PRE>   
   % <B>vos listvol fs3.abc.com /vicepa -f</B>
   Total number of volumes on server fs3.abc.com  \
                                       partition /vicepa: 37
   50489902
   50489904
      .
      .
   35970325
   49732810
   
</PRE>
<P><B>-long 플래그를 사용한 출력</B>
<A NAME="IDX6608"></A>
<P><B>-long</B> 플래그를 포함시키면 각 볼륨의 출력에는
다음 사항과 함께 기본 목록에 모든 정보가 포함됩니다. 이 목록의 각 항목은
별도의 출력 행에 해당합니다.
<UL>
<LI>VLDB 또는 볼륨 헤더에 의해 파생된 것이 아니라 명령이 실행될 때 명령
인터프리터에 의해 결정된 대로 볼륨을 저장하는 파일 서버 시스템 및 파티션.
<A NAME="IDX6609"></A>
<A NAME="IDX6610"></A>
<A NAME="IDX6611"></A>
<A NAME="IDX6612"></A>
<A NAME="IDX6613"></A>
<A NAME="IDX6614"></A>
<A NAME="IDX6615"></A>
<A NAME="IDX6616"></A>
</LI><LI>다양한 버전의 볼륨, 즉 읽기/쓰기(<TT>RWrite</TT>), 읽기
전용(<TT>ROnly</TT>), 백업(<TT>Backup</TT>) 및
ReleaseClone(<TT>RClone</TT>)과 연관된 볼륨 ID 번호.
이들 중 하나는 볼륨 출력의 첫째 행에 나타나는 볼륨 ID 번호와 일치합니다.
<TT>RWrite</TT>, <TT>ROnly</TT> 또는 <TT>Backup</TT> 필드의
값이 <TT>0</TT>이면 해당 유형의 볼륨이 없는 것입니다. 현재
ReleaseClone이 없으면 <TT>RClone</TT> 필드는 나타나지 않습니다.
<A NAME="IDX6617"></A>
<A NAME="IDX6618"></A>
</LI><LI>볼륨의
읽기/쓰기 사본에 할당된 최대 공간 할당량으로 <TT>MaxQuota</TT> 필드에
킬로바이트 블록 단위로 표시됩니다.
<A NAME="IDX6619"></A>
<A NAME="IDX6620"></A>
</LI><LI><TT>작성</TT> 필드에 나오는 볼륨이 작성될 날짜 및 시간.
볼륨이 <B>backup diskrestore</B>,
<B>backup volrestore</B> 또는 <B>vos restore</B>
명령을 통해 복원된 경우 이것은 복원 시간이 됩니다.
<A NAME="IDX6621"></A>
<A NAME="IDX6622"></A>
</LI><LI><TT>최종 갱신</TT> 필드에 나오는 볼륨의 내용이 마지막으로 변경된
날짜 및 시간. 읽기 전용 및 백업 볼륨의 경우 이 필드는 <TT>작성</TT>
필드의 시간 소인과 일치합니다.
<A NAME="IDX6623"></A>
<A NAME="IDX6624"></A>
</LI><LI>다음의 두 시간 중 두 번째 시간 이후에 발생한 페치 또는 저장 조작을
위해 볼륨을 액세스한 횟수
<UL>
<LI>명령이 실행된 날의 오전 12시
</LI><LI>볼륨이 위치를 변경한 마지막 시간
</LI></UL>
</LI></UL>
<P><B>-long</B> 플래그가 포함될 때 출력의 예는 다음과 같습니다.
<PRE>   
   % <B>vos listvol fs2.abc.com b -long</B>
   Total number of volumes on server fs2.abc.com 
                                       partition /vicepb: 66
         .                   .      .         .   .    .
         .                   .      .         .   .    .
   user.pat             1969534536 RW      17518 K On-line
        fs2.abc.com /vicepb
        RWrite 1969534536 ROnly 0        Backup 1969534538 
        MaxQuota      20000 K
        Creation    Mon Jun 12 09:02:25 1989
        Last Update Thu Jan  4 17:39:34 1990
        1573 accesses in the past day (i.e., vnode references)
   user.pat.backup      1969534538 BK      17537 K On-line
        fs2.abc.com /vicepb
        RWrite 1969534536 ROnly 0        Backup 1969534538 
        MaxQuota      20000 K
        Creation    Fri Jan  5 06:37:59 1990
        Last Update Fri Jan  5 06:37:59 1990
        0 accesses in the past day (i.e., vnode references)
	    .               .         .     .       .
	    .               .         .     .       .
   Total volumes onLine 66 ; Total volumes offLine 0 ; Total busy 0
   
</PRE>
<P><B>-extended 플래그를 사용한 출력</B>
<A NAME="IDX6625"></A>
<P><B>-extended</B> 플래그를 포함시키면 각 볼륨의 출력에는
<B>-long</B> 플래그를 사용했을 때 보고된 모든 정보와
다음의 통계 테이블이 포함됩니다.
<UL>
<LI><TT>Raw Read/Write Stats</TT> 테이블은 읽기 또는 쓰기를 위해 볼륨을
액세스한 회수를 요약합니다.
</LI><LI><TT>Writes Affecting Authorship</TT> 테이블에는 지정된 볼륨의 파일
및 디렉토리에 대해 수행된 쓰기 작업에 대한 정보가 포함되어 있습니다.
</LI></UL>
<P><B>-extended</B> 플래그가 포함될 때 출력의 예는 다음과 같습니다.
<PRE>   % <B>vos listvol fs3.abc.com a -extended</B>
   common.bboards   1969535592 RW    23149 K used 9401 files On-line
       fs3.abc.com /vicepa
       RWrite 1969535592 ROnly          0 Backup 1969535594
       MaxQuota      30000 K
       Creation    Mon Mar  8 14:26:05 1999
       Last Update Mon Apr 26 09:20:43 1999
       11533 accesses in the past day (i.e., vnode references)
   
                         Raw Read/Write Stats
             |-------------------------------------------|
             |    Same Network     |    Diff Network     |
             |----------|----------|----------|----------|
             |  Total   |   Auth   |   Total  |   Auth   |
             |----------|----------|----------|----------|
   Reads     |      151 |      151 |     1092 |     1068 |
   Writes    |        3 |        3 |      324 |      324 |
             |-------------------------------------------|
    
                      Writes Affecting Authorship
             |-------------------------------------------|
             |   File Authorship   | Directory Authorship|
             |----------|----------|----------|----------|
             |   Same   |   Diff   |    Same  |   Diff   |
             |----------|----------|----------|----------|
   0-60 sec  |       92 |        0 |      100 |        4 |
   1-10 min  |        1 |        0 |       14 |        6 |
   10min-1hr |        0 |        0 |       19 |        4 |
   1hr-1day  |        1 |        0 |       13 |        0 |
   1day-1wk  |        1 |        0 |        1 |        0 |
   > 1wk     |        0 |        0 |        0 |        0 |
             |-------------------------------------------|
   
</PRE>
<P><H3><A NAME="HDRWQ221" HREF="auagd002.htm#ToC_237">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A></H3>
<A NAME="IDX6626"></A>
<A NAME="IDX6627"></A>
<A NAME="IDX6628"></A>
<A NAME="IDX6629"></A>
<A NAME="IDX6630"></A>
<A NAME="IDX6631"></A>
<A NAME="IDX6632"></A>
<P><B>vos examine</B> 명령은 단일 볼륨에 대한 VLDB 및
볼륨 헤더의 정보를 표시합니다. 두 원본의 정보가 약간 중복될 수 있으므로
VLDB와 볼륨 헤더를 비교할 수 있습니다.
<P>각 볼륨 버전(읽기/쓰기, 읽기 전용 및 백업)에 대한 볼륨 헤더가 다르므로
표시할 볼륨 버전을 지정할 수 있습니다. <B>.readonly</B>
또는 <B>.backup</B> 확장자를 <VAR>volume name 또는 ID</VAR>
인수에 포함시키십시오. VLDB의 정보는 세 가지 버전에서 모두 동일합니다.
<A NAME="IDX6633"></A>
<A NAME="IDX6634"></A>
<P><H3><A NAME="HDRWQ222" HREF="auagd002.htm#ToC_238">볼륨의 VLDB 항목 및 볼륨 헤더를 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>vos examine</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>vos examine</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>e
</B><DD>허용되는 <B>examine</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 하나의 볼륨을 식별합니다.
읽기/쓰기, 읽기 전용 또는 백업 유형일 수 있습니다. 적절하게 <B>.backup</B> 또는 <B>.readonly</B> 확장자를 사용하십시오.
</DL>
</LI></OL>
<P>출력의 맨 위 부분에는 <A HREF="#HDRWQ220">볼륨 헤더를 표시하려면</A>의 지침에서 설명하는
것처럼 <B>-long</B> 플래그와 함께 <B>vos listvol</B>
명령을 사용할 때와 동일한 볼륨 헤더의 정보가 표시됩니다.
볼륨의 읽기 전용 버전을 지정하고 이 버전이 둘 이상의 사이트에 존재하는 경우
출력은 모든 경우를 포함합니다. 출력의 맨 아래 부분에는 <A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>에서
설명하는 것처럼 <B>vos listvldb</B> 명령을 사용할 때와
동일한 VLDB의 정보가 나열됩니다.
<P>다음은 그 VLDB 항목이 현재 잠겨 있는 볼륨에 대한 예입니다.
<PRE>   
   % <B>vos examine user.terry</B>
   user.terry                    536870981 RW   3459 K On-line
       fs3.abc.com /vicepa
       Write 5360870981   ROnly          0  Backup 536870983
       MaxQuota      40000 K
       Creation    Mon Jun 12 15:22:06 1989
       Last Update Fri Jun 16 09:34:35 1989
       5719 accesses in the past day (i.e., vnode references)
       RWrite: 5360870981   Backup: 536870983
       number of sites -> 1
          server fs3.abc.com partition /vicepa RW Site 
       Volume is currently LOCKED
   
</PRE>
<P><H3><A NAME="HDRWQ223" HREF="auagd002.htm#ToC_239">파일이 들어 있는 볼륨의 이름 또는 위치 표시</A></H3>
<P>이 절은 파일이나 디렉토리를 포함하는 볼륨의 이름, 볼륨 ID 번호 또는
위치를 알아내는 방법을 설명합니다.
<P>또한 볼륨에 대한 정보(예: 볼륨 이름)를 사용하여 관련된 다른 정보(예: 볼륨
위치)를 얻을 수도 있습니다.
다음 목록은 사용자에게 적절한 지침을 알려 줍니다.
<UL>
<A NAME="IDX6635"></A>
<A NAME="IDX6636"></A>
<A NAME="IDX6637"></A>
<A NAME="IDX6638"></A>
<A NAME="IDX6639"></A>
<A NAME="IDX6640"></A>
<A NAME="IDX6641"></A>
<A NAME="IDX6642"></A>
<A NAME="IDX6643"></A>
<A NAME="IDX6644"></A>
<LI>볼륨의 이름을 사용하여 기존의 모든 버전에 대한 볼륨 ID 번호를 알아
내려면 <A HREF="#HDRWQ222">볼륨의 VLDB 항목 및 볼륨 헤더를 표시하려면</A>에서 설명하는 것처럼
<B>vos examine</B> 명령을 사용하십시오.
<P>
<P>또한 이 명령을 사용하여 그 ID 번호를 제공하여 볼륨의 이름을 알아낼
수도 있습니다.
</LI><LI>볼륨의 이름이나 ID 번호를 사용하여 그 위치를 알아내려면
<A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>에서 설명하는 것처럼 <B>vos
listvldb</B> 명령을 사용하십시오.
<A NAME="IDX6645"></A>
<A NAME="IDX6646"></A>
<A NAME="IDX6647"></A>
<A NAME="IDX6648"></A>
<A NAME="IDX6649"></A>
<A NAME="IDX6650"></A>
</LI></UL>
<A NAME="IDX6651"></A>
<A NAME="IDX6652"></A>
<A NAME="IDX6653"></A>
<A NAME="IDX6654"></A>
<A NAME="IDX6655"></A>
<A NAME="IDX6656"></A>
<P><H4><A NAME="HDRWQ224">파일이 들어 있는 볼륨의 이름을 표시하려면</A></H4>
<OL TYPE=1>
<LI><B>fs listquota</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs listquota</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>lq
</B><DD>허용되는 <B>listquota</B>의 별명(그리고
<B>listq</B>는 허용되는 가장 짧은 축약형)입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>이름을 표시할 볼륨에 있는 디렉토리나 파일을 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
</DL>
</LI></OL>
<P>다음은 출력의 예입니다.
<PRE>   
   % <B>fs listquota /afs/abc.com/usr/terry</B>
   Volume Name     Quota    Used    % Used   Partition 
   user.terry      15000    5071       34%         86%   
   
</PRE>
<A NAME="IDX6657"></A>
<A NAME="IDX6658"></A>
<A NAME="IDX6659"></A>
<A NAME="IDX6660"></A>
<A NAME="IDX6661"></A>
<A NAME="IDX6662"></A>
<P><H4><A NAME="HDRWQ225">파일이 들어 있는 볼륨의 ID 번호를 표시하려면</A></H4>
<OL TYPE=1>
<LI><B>fs examine</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs examine</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>exa
</B><DD>허용되는 <B>examine</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>볼륨 ID를 표시할 볼륨에 있는 디렉토리나 파일을 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
</DL>
</LI></OL>
<P>다음 예제는 출력이 <TT>vid</TT> 필드에 볼륨 ID 번호를 보고하는 방법을
보여 줍니다.
<PRE>   
   % <B>fs examine /afs/abc.com/usr/terry</B>
   Volume status for vid = 50489902 named user.terry
   Current maximum quota is 15000
   Current blocks used are 5073
   The partition has 46383 blocks available out of 333305  
   
</PRE>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 명령의 출력에서 파티션 관련 통계가 항상 표준 UNIX <B>df</B>
명령 출력의 해당 값과 일치하는 것은 아닙니다. 이 명령에서 보고한 통계는
캐쉬 관리 프로그램이 5분 간격으로 파티션 정보에 대해 파일 서버를 폴링하므로
생성된 이후에 최대 5분까지 경과될 수 있습니다. 또한 일부 운영 체제에서
<B>df</B> 명령의 파티션 크기 보고에는 이 명령의 계산에는
포함되어 있지 않은 예약된 공간이 포함되므로 약 10%가 더 커질 수 있습니다.
</TD></TR></TABLE>
<A NAME="IDX6663"></A>
<A NAME="IDX6664"></A>
<A NAME="IDX6665"></A>
<A NAME="IDX6666"></A>
<A NAME="IDX6667"></A>
<A NAME="IDX6668"></A>
<A NAME="IDX6669"></A>
<P><H4><A NAME="Header_242">파일이 들어 있는 볼륨의 위치를 표시하려면</A></H4>
<OL TYPE=1>
<LI><B>fs whereis</B> 명령을 실행하여 파일이나 디렉토리가
들어 있는 볼륨을 저장하는 파일 서버 시스템의 이름을 표시하십시오.
<P>
<PRE>   
   % <B>fs whereis</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>whe
</B><DD>허용되는 <B>whereis</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>위치를 보고할 디렉토리 또는 파일을 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
</DL>
<P>
<P>출력은 다음 예에서처럼 해당 파일을 포함하는 볼륨이 있는 파일 서버 시스템을
표시합니다.
<P>
<PRE>   
   % <B>fs whereis /afs/abc.com/user/terry</B>
   File /afs/abc.com/usr/terry is on host fs2.abc.com
   
</PRE>
</LI><LI>또한 해당 볼륨이 있는 파티션을 알기 원하는 경우 먼저 <B>fs
listquota</B> 명령을 실행하여 볼륨의 이름을 표시하십시오.
자세한 구문을 보려면 <A HREF="#HDRWQ224">파일이 들어 있는 볼륨의 이름을 표시하려면</A>을 참조하십시오.
<P>
<PRE>   
   % <B>fs listquota</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
   
</PRE>
<P>
<P>그런 다음 <B>vos listvldb</B> 명령을 실행하십시오. 이 때
볼륨 이름을 <VAR>volume name 또는 ID</VAR> 인수로 제공하십시오.
자세한 구문이나 출력에 대한 설명을 보려면 <A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>을
참조하십시오.
<P>
<PRE>   
   % <B>vos listvldb</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
</LI></OL>
<HR><H2><A NAME="HDRWQ226" HREF="auagd002.htm#ToC_243">볼륨 이동</A></H2>
<A NAME="IDX6670"></A>
<A NAME="IDX6671"></A>
<P>다음과 같은 세 가지 주요 이유로 인해 볼륨을 이동하게 됩니다.
<UL>
<LI>디스크 또는 파일 서버 시스템을 복구하거나 교체하는 동안 다른 파티션이나
시스템에 볼륨을 일시적으로 배치하기 위해.
</LI><LI>포화 상태의 파티션에 공간을 확보하기 위해. 
<A NAME="IDX6672"></A>
<A NAME="IDX6673"></A>
<A NAME="IDX6674"></A>
<A NAME="IDX6675"></A>
<A NAME="IDX6676"></A>
포화 상태를 나타내는 한 가지
증상은 해당 볼륨이 아직 할당량에 도달하지 않은 경우에도 사용자가 파일을
저장할 수 없는 것입니다. 다음 오류 메시지가 나타나서 이러한 문제점이
발생했음을 확인해 줍니다.
<P>
<PRE>   
   afs: failed to store file (partition full)
   
</PRE>
<P>
<P><A HREF="auagd013.htm#HDRWQ323">AFS 성능 모니터 및 감사</A>에서 설명하는 것처럼 <B>scout</B>
또는 <B>afsmonitor</B> 프로그램을 사용하여 AFS 서버
파티션의 여유 공간을 추적할 수 있습니다.
</LI><LI>파일 서버 시스템은 동일한 크기의 다른 시스템보다 더 많은 볼륨을
포함하거나 자주 사용되는 파일이 많이 들어 있는 볼륨을 가지고 있으므로
과부하 상태가 됩니다.
</LI></UL>
<P>
<A NAME="IDX6677"></A>
<A NAME="IDX6678"></A>
읽기/쓰기 볼륨을 이동하려면 다음 지침에 따라 <B>vos move</B> 명령을 사용하십시오. 볼륨을 이동하려고 하기 전에
<B>vos</B> 명령 인터프리터는 목적지 파티션에 충분한
여유 공간이 있는지 확인합니다. 공간이 충분하지 않으면 이동 조작을
시도하지 않고 다음 메시지를 출력합니다.
<PRE>   
   vos: no space on target partition <VAR>destination_part</VAR> to move volume <VAR>volume</VAR>
   
</PRE>
<P>읽기 전용 볼륨을 이동하려면 <A HREF="#HDRWQ236">볼륨을 제거하고 언마운트하려면</A>에서 설명하는
것처럼 <B>vos remove</B> 명령을 실행하여 현재 사이트에서
실제로 볼륨을 제거하십시오. 그런 다음 <A HREF="#HDRWQ194">읽기/쓰기 볼륨을 복제하려면 (읽기 전용 볼륨 작성)</A>에서
설명하는 것처럼 <B>vos addsite</B> 및 <B>vos release</B> 명령을 실행하여 새 사이트를 정의하고 이 사이트에
해당 볼륨을 릴리스하십시오. 
<A NAME="IDX6679"></A>
<A NAME="IDX6680"></A>
<P>백업 볼륨은 읽기/쓰기 원본이 있는 동일한 사이트에 항상 위치하므로
읽기/쓰기 원본을 이동할 때 함께 이동하는 경우를 제외하고는 백업 볼륨을
이동할 수 없습니다. <B>vos move</B> 명령은 사용자가
읽기/쓰기 볼륨을 이동할 때 자동으로 백업 버전을 삭제합니다.
이동 조작이 완료되는 즉시 새로운 사이트에 새 백업 볼륨을 작성하려면
<A HREF="#HDRWQ205">백업 볼륨을 작성 및 마운트하려면</A>에서 설명하는 것처럼
<B>vos backup</B> 명령을 실행하십시오.
<A NAME="IDX6681"></A>
<A NAME="IDX6682"></A>
<P><H3><A NAME="Header_244" HREF="auagd002.htm#ToC_244">읽기/쓰기 볼륨을 이동하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>vos move</B> 명령을 실행하여 볼륨을 이동하십시오.
이 명령은 단일 행에 입력하십시오. 아래에서는 읽기 편리하도록 여러 행으로
표현한 것에 불과합니다.
<P>
<PRE>   
   % <B>vos move</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>  \
       &lt;<VAR>machine&nbsp;name&nbsp;on&nbsp;source</VAR>>  &lt;<VAR>partition&nbsp;name&nbsp;on&nbsp;source </VAR>>  \
       &lt;<VAR>machine&nbsp;name&nbsp;on&nbsp;destination</VAR>>  &lt;<VAR>partition&nbsp;name&nbsp;on&nbsp;destination</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>m
</B><DD>허용되는 <B>move</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>이동할 읽기/쓰기 볼륨의 이름이나 볼륨 ID 번호를 지정합니다.
<P><DT><B><VAR>machine name on source</VAR>
</B><DD>볼륨이 현재 들어 있는 파일 서버 시스템을 명명합니다.
<P><DT><B><VAR>partition name on source</VAR>
</B><DD>볼륨이 현재 들어 있는 파티션을 명명합니다.
<P><DT><B><VAR>machine name on destination</VAR>
</B><DD>볼륨을 이동할 파일 서버 시스템을 명명합니다.
<P><DT><B><VAR>partition name on destination</VAR>
</B><DD>볼륨을 이동할 파티션을 명명합니다.
</DL>
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">완료되기 전에 <B>vos move</B> 조작을 멈추지
않도록 하십시오. 왜냐하면 볼륨의 일부가 원본 및 목적지 시스템에 모두
남을 수 있기 때문입니다. 자세한 정보를 보려면 <I>AFS Administration Reference</I>에서 명령의 참조
페이지를 참조하십시오.
</TD></TR></TABLE>
</LI><LI><B>(선택적)</B> <B>vos listvldb</B> 명령을 실행하여 이동이 성공적인지 확인하십시오. <A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>에
나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>vos listvldb</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
</LI><LI>읽기/쓰기 볼륨의 이전 사이트에 백업 버전이 존재한 경우
<A HREF="#HDRWQ205">백업 볼륨을 작성 및 마운트하려면</A>에서 설명하는 것처럼 <B>vos backup</B> 명령을 실행하여 새 사이트에 새 백업을 작성하십시오.
<P>
<PRE>   
   % <B>vos backup</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
</LI></OL>
<HR><H2><A NAME="HDRWQ227" HREF="auagd002.htm#ToC_245">VLDB 및 볼륨 헤더 동기화</A></H2>
<A NAME="IDX6683"></A>
<A NAME="IDX6684"></A>
<A NAME="IDX6685"></A>
<P>AFS는 VLDB(Location Database)가 볼륨 위치를 계속 추적하므로 가시적인
파일 액세스를 제공할 수 있습니다. 캐쉬 관리 프로그램은 파일이 필요할 때
해당 파일을 포함하는 볼륨의 현재 위치를 VLDB에서 읽어 오는 볼륨 위치(VL)
서버에 접속합니다. 따라서 VLDB는 항상 파일 서버 시스템의 볼륨 상태를
정확하게 반영해야 합니다. 볼륨 서버와 VL 서버는 다음의 단계를 수행하여
<B>vos</B> 조작 중에 상태가 변경될 때 볼륨의 VLDB 항목을
자동적으로 갱신합니다.
<OL TYPE=1>
<LI><A NAME="LIWQ228"></A>VL 서버는 VLDB 항목을 잠급니다. 이 잠금을 통해
다른 조작은 볼륨 버전(읽기/쓰기, 읽기 전용 또는 백업)을 조작하지 않게
되어 복수의 동시 조작으로 유발될 수 있는 비일관성을 막을 수 있습니다.
</LI><LI><A NAME="LIWQ229"></A>VL 서버는 수행할 조작 유형을 나타내는
<I>intention 플래그</I>를 VLDB 항목에 설정합니다.
<A NAME="IDX6686"></A>
<A NAME="IDX6687"></A>
<P>
이 플래그는 내부 사용만을 목적으로 하므로 VLDB 목록에 나타나지 않습니다.
조작이 미리 종료되는 경우 이 플래그는 구조 프로그램에게 중단된 조작을
알려 줍니다(그러면 구조 프로그램은 조작을 완료하거나 볼륨의 이전의
일관된 상태로 되돌리는 데 필요한 단계를 결정합니다).
구조에 대한 자세한 정보를 보려면 <A HREF="#HDRWQ232">볼륨 구조</A>를 참조하십시오.
</LI><LI><A NAME="LIWQ230"></A>볼륨 서버는 볼륨을 처리합니다. 보통 볼륨 헤더에서
<TT>Off-line</TT> 플래그를 설정하는 데 이 플래그는 처리 중에 파일 서버
및 다른 볼륨 서버 조작에서 해당 볼륨을 액세스하지 못하게 합니다.
조작이 완료되면 볼륨은 다시 <TT>On-line</TT>으로 설정됩니다.
</LI><LI><A NAME="LIWQ231"></A>VL 서버는 VLDB 항목의 조작의 결과로 생성되는
변경사항을 기록합니다. 일단 조작이 완료되면 단계 <A HREF="#LIWQ229">2</A>에서
설정한 intention 플래그를 제거하고 단계 <A HREF="#LIWQ228">1</A>에서 설정된
잠금을 해제합니다.
</LI></OL>
<P>볼륨 서버가 볼륨을 처리하는 중에 <B>vos</B> 조작이
실패하면(단계 <A HREF="#LIWQ230">3</A>에 해당) 볼륨은 중간 상태에 그대로 남아
있으며 이를 <I>손상</I> 상태라고 합니다. 이 경우
<TT>Off-line</TT> 또는 <TT>Off-line**needs salvage**</TT> 표시자가
<B>vos examine</B> 명령의 출력 첫째 행 맨 끝에 나타납니다.
손상 상태를 수정하려면 VLDB와 볼륨 헤더를 재동기화하기 전에 구조 프로그램을
실행하십시오.
구조 지침을 보려면 <A HREF="#HDRWQ232">볼륨 구조</A>를 참조하십시오.
<P>좀더 일반적으로 보면 플래그가 설정되거나 제거되는 동안 발생하는
인터럽션은 (단계 <A HREF="#LIWQ228">1</A>, 단계 <A HREF="#LIWQ229">2</A>
또는 단계 <A HREF="#LIWQ231">4</A>에 해당) VLDB와 볼륨 헤더 간의
불일치 상태를 유발합니다. VLDB와 볼륨을 재동기화하려면 <B>vos syncvldb</B> 및 <B>vos syncserv</B> 명령을 사용하십시오. 완전한
VLDB 일관성을 이루기 위해서는 셀의 모든 파일 서버에 대해 <B>vos syncvldb</B>
명령을 실행한 다음 셀의 모든 파일 서버 시스템에 대해 <B>vos syncserv</B> 명령을 실행하는 것이 가장 좋습니다.
<A NAME="IDX6688"></A>
<A NAME="IDX6689"></A>
<A NAME="IDX6690"></A>
<P>볼륨 조작이 실패했음을 나타내는 다음과 같은 몇 가지 증상이 있습니다.
<UL>
<LI>표준 오류 스트림이나 서버 프로세스 로그 파일의 오류 메시지는 조작이
비정상적으로 종료되었음을 나타냅니다. 조작을 완료하기 전에
중단했거나(예를 들어 <B>Ctrl-c</B>와 같은 신호 사용) 조작이
실행되고 있을 때 파일 서버 시스템이나 서버 프로세스가 기능하지 않았기
때문일 것입니다. 시스템이나 프로세스가 여전히 기능하지 않는 것으로
생각되면 <A HREF="auagd009.htm#HDRWQ158">프로세스 상태와 BosConfig 파일의 정보 표시하기</A>에서 설명하는 것처럼
<B>bos status</B> 명령을 실행하십시오.
</LI><LI>이전의 실패 상태가 VLDB 항목을 잠금 상태로 두었으므로 후속
<B>vos</B> 조작은 실패합니다. 경우에 따라 볼륨이
잠겨 있다는 사실을 오류 메시지에서 보고하기도 합니다. 잠겨진 볼륨
목록을 표시하려면 <A HREF="#HDRWQ217">VLDB 항목 표시</A>에서 설명하는 것처럼
<B>vos listvldb</B> 명령에 대해 <B>-locked</B>
플래그를 사용하십시오.
<P>
<P>볼륨에 발생한 문제점이 VLDB 항목이 잠겨 있다는 것에 불과하면 전체 VLDB를
동기화할 필요가 없을 수 있습니다. 대신 <A HREF="#HDRWQ247">VLDB 항목 잠금 해제 및 잠금</A>에서
설명하는 것처럼 <B>vos unlock</B> 또는
<B>vos unlockvldb</B> 명령을 사용하십시오.
</LI><LI>이전 실패 상태가 볼륨을 offline으로 표시하고 있으므로 후속
<B>vos</B> 조작은 실패합니다. <A HREF="#HDRWQ221">볼륨의 VLDB 항목 및 볼륨 헤더 표시</A>에서
설명하는 것처럼 볼륨의 현재 상태를 확인하려면 <B>vos examine</B>
명령의 출력 첫째 행을 확인하십시오.
</LI></UL>
<A NAME="IDX6691"></A>
<A NAME="IDX6692"></A>
<A NAME="IDX6693"></A>
<A NAME="IDX6694"></A>
<A NAME="IDX6695"></A>
<P><B>vos syncvldb</B> 명령은 VLDB(Location Database)에
있는 파일 서버 시스템에 있는 모든 볼륨, 한 파티션에 있는 볼륨 또는
단일 볼륨에 대한 정보를 수정합니다. 하나 이상의 파티션에 대한 정보를
확인하면 이 명령은 볼륨 서버에 접속하여 실제 각 파티션에 있는 볼륨의 목록을
얻습니다. 그런 다음 VL 서버로부터 각 볼륨에 대한 VLDB 항목을 얻습니다.
이 명령은 필요에 따라 파티션에 있는 볼륨의 상태를 반영하도록 VLDB 항목을
변경합니다. 예를 들어 VLDB 항목이 없거나 완전하지 않은 볼륨을 찾을 때
VLDB 항목을 작성하거나 갱신합니다. 그러나 볼륨의 다른 위치를 정의하는 VLDB
항목이 이미 있거나 다른 VLDB 항목과 절충할 수 없는 충돌이 발생하면
대신 표준 오류 스트림에 충돌에 대한 메시지를 씁니다.
이 명령은 파일 서버 시스템에서 볼륨을 제거하지는 않습니다.
<P>단일 볼륨의 VLDB 항목을 확인할 때 명령은 <B>vos syncserv</B>
명령에서 호출한 조작을 자동으로 수행합니다. VLDB 항목이 지정된 볼륨
유형(읽기/쓰기, 백업 또는 읽기 전용)에 대해 올바른지 확인할 뿐 아니라
VLDB 항목에 언급된 관련 볼륨 유형이 항목에 나열된 사이트에 실제로
존재하는지도 확인합니다.
<A NAME="IDX6696"></A>
<P><B>vos syncserv</B> 명령은 VLDB 항목에 언급된 각 볼륨
유형(읽기/쓰기, 읽기 전용 및 백업)이 실제로 항목에 지정된 사이트에 존재하는지
확인합니다. 또한 파일 서버 시스템의 파티션이나 하나의 파티션에 있는
사이트를 언급하는 모든 VLDB 항목을 확인합니다. 읽기/쓰기 사이트 이외에
볼륨의 읽기 전용 버전이 있는 경우 명령은 지정된 시스템이나 파티션 이외의
사이트를 조사하는 것을 중단할 수 있습니다.
<P>이 명령은 다른 VLDB 항목과 절충할 수 없는 충돌이 없다면 VLDB의
잘못된 정보를 수정합니다. 이 경우 표준 오류 스트림에 메시지를 씁니다.
이 명령은 사이트에서 볼륨을 제거하지는 않습니다.
<A NAME="IDX6697"></A>
<A NAME="IDX6698"></A>
<A NAME="IDX6699"></A>
<A NAME="IDX6700"></A>
<P><H3><A NAME="Header_246" HREF="auagd002.htm#ToC_246">볼륨 헤더와 VLDB를 동기화하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><A NAME="LIVOL-SYNCVL"></A><B>vos syncvldb</B> 명령을 실행하여
VLDB가 시스템이나 파티션에 있는 모든 볼륨의 실제 상태 또는 한 볼륨의
상태를 반영하게 하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">VLDB를 완전히 동기화하려면 이 명령을 반복적으로 실행하고,
셀에서 각 파일 서버 시스템을 <B>-server</B> 인수로
차례대로 바꾸고 단계 <A HREF="#LIVOL-SYNCSR">3</A>을 계속하기 전에
<B>-partition</B> 및 <B>-volume</B>
인수를 생략하십시오.
</TD></TR></TABLE>
<P>
<PRE>   % <B>vos syncvldb -server</B> &lt;<VAR>machine&nbsp;name</VAR>>
[<B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>]  [<B>-volume</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>]  [<B>-verbose >></B> <VAR>file</VAR>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>syncv
</B><DD>허용되는 <B>syncvldb</B>의 가장 짧은 축약형입니다.
<P><DT><B>-server
</B><DD>VLDB 항목을 확인할 볼륨이 들어 있는 파일 서버 시스템을 명명합니다.
<B>-volume</B> 인수도 제공하는 경우 이 인수는 볼륨이 실제로
위치하는 시스템을 명명해야 합니다.
<P><DT><B>-partition
</B><DD>VLDB 항목을 확인할 볼륨이 들어 있는 파티션(<B>-server</B>
인수에서 지정하는 파일 서버 시스템에 위치)을 식별합니다. 일반적으로
서버 시스템의 모든 볼륨에 대한 VLDB 항목이 수정되거나(<B>-volume</B>
인수를 제공하지 않는 경우) 파티션이 <B>-volume</B> 인수에서
명명하는 볼륨을 실제로 가지고 있는지 보장할 필요가 없도록 이 인수를
생략하는 것이 가장 바람직합니다.
<P><DT><B>-volume
</B><DD>VLDB 항목을 확인할 단일 볼륨의 이름이나 볼륨 ID 번호를 지정합니다.
<P><DT><B><B>-verbose >></B> <VAR>file</VAR>
</B><DD>명령을 실행하는 AFS 또는 시스템의 로컬 디스크에 있을 수 있는
<VAR>file</VAR>이라는 파일에 대한 상세한 추적을 지시합니다. 이 명령은
표준 출력 스트림에 많은 양의 출력을 쓰기도 합니다. 파일에 출력을 쓰면
출력 결과를 좀 더 주의깊게 검토할 수 있습니다.
</DL>
</LI><LI><A NAME="LIVOL-SYNCSR"></A><B>vos syncserv</B> 명령을 실행하여
지정된 사이트에서 VLDB가 버전을 나열하는 각 볼륨을 검토하십시오.
<P>
<P><TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">VLDB를 완전히 동기화하려면 이 명령을 반복적으로 실행하고,
셀에서 각 파일 서버 시스템을 <VAR>machine name</VAR> 인수로 차례대로 바꾸고
<VAR>partition name</VAR> 인수는 생략하십시오.
</TD></TR></TABLE>
<P>
<PRE>   % <B>vos syncserv</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>partition&nbsp;name</VAR>>] [<B>-v >></B> <VAR>file</VAR>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>syncs
</B><DD>허용되는 <B>syncserv</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>확인할 각 VLDB 항목에 언급된 파일 서버 시스템을 명명합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>확인할 각 VLDB 항목에 언급된 파티션을 식별합니다. 전체 VLDB를
동기화하는 경우 이 인수를 생략하십시오.
<P><DT><B>-v >> <I><VAR>file</VAR></I>
</B><DD>명령을 실행하는 AFS 또는 시스템의 로컬 디스크에 있을 수 있는
<VAR>file</VAR>이라는 파일에 대한 상세한 추적을 지시합니다. 이 명령은
표준 출력 스트림에 많은 양의 출력을 쓰기도 합니다. 파일에 출력을 쓰면
출력 결과를 좀 더 주의깊게 검토할 수 있습니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ232" HREF="auagd002.htm#ToC_247">볼륨 구조</A></H2>
<A NAME="IDX6701"></A>
<A NAME="IDX6702"></A>
<A NAME="IDX6703"></A>
<A NAME="IDX6704"></A>
<A NAME="IDX6705"></A>
<A NAME="IDX6706"></A>
<A NAME="IDX6707"></A>
<A NAME="IDX6708"></A>
<P>볼륨 서버나 파일 서버가 볼륨의 데이터를 처리하는 동안 예상치 못한 인터럽션이
발생하여 VLDB 및 볼륨 헤더의 정보 간의 불일치를 발생하는 데서 그치지 않고
볼륨을 중간 상태(<I>손상</I>)로 남겨둘 수 있습니다.
예를 들어 파일에 변경사항을 저장하는 조작(이전 데이터를 새 데이터로
덮어씀)이 실패할 경우 디스크에서 이전 데이터와 새 데이터가 혼합된 상태로
존재할 수 있습니다.
<P>볼륨 서버나 파일 서버가 예상치 못한 상태에서 종료되었으므로 조작이 중단되는
경우 BOS 서버는 자동으로 <B> fs</B> 프로세스의 모든
구성요소를 종료하고 구조 프로그램을 호출합니다. 구조 프로그램은 불일치
상태를 확인하여 수정합니다. 그러나 경우에 따라 다음과 같이 분류되는
증상을 나타내는 경우가 있습니다. 이러한 유형의 증상은 문제점을 작성할만큼
충분히 심각한 손상 상태를 나타내지만 파일 서버 구성요소가 실패될만큼
심각한 증상은 아닙니다. 이러한 경우 직접 <B>bos salvage</B>
명령을 실행하여 구조 프로그램을 호출할 수 있습니다.
<UL>
<LI><B>증상:</B> 파일이 <B>ls</B> 명령의
출력에 나타나지만 파일을 액세스하려는 시도는 파일이 존재하지 않음을 나타내는
메시지를 표시하며 실패합니다.
<P>
<P><B>가능한 원인:</B>
볼륨 서버나 파일 서버는 파일 작성 조작 중간에, 디렉토리 구조가 변경된
후에, 실제로 데이터를 저장하기 전에 종료되었습니다(다른 가능한
원인은 디렉토리의 ACL이 사용자가 파일을 액세스하는 데 필요한
권한을 부여하지 않거나 프로세스, 시스템 또는 네트워크 작동 중단 상태가
발생한 것입니다. 파일이 손상되었다고 가정하기 전에 이러한 원인이 있는지
확인해 보십시오).
<P>
<P><B>구조 프로그램 해결 방법:</B> 디렉토리 구조에서 파일의
항목을 제거하십시오.
</LI><LI><B>증상:</B> <B>vos examine</B> 및 <B>vos listvol</B> 명령의 출력에서 볼륨이 <TT>Off-line</TT>로 설정되어 있거나
볼륨 액세스 시도가 실패했습니다.
<P>
<P><B>가능한 원인:</B> 두 파일 또는 파일의 두 버전이 중단된 조작으로 인해
동일한 디스크 블록을 공유하게 됩니다. 파일 서버 및 볼륨 서버는 보통
이러한 유형의 손상은 매우 심각할 수 있으므로 이러한 손상을 나타내는 볼륨에
접속하는 것을 거부합니다. 볼륨 서버나 파일 서버가 이 볼륨에 접속했으나
영향 받는 디스크 블록의 상태를 확실히 모르는 경우 이 볼륨에 더 많은
데이터를 쓰려고 시도합니다. 쓰기를 수행할 수 없을 때 데이터를 유실됩니다.
이 결과는 연속적으로 발생하여 파티션의 모든 데이터를 손실할 수 있습니다.
<P>
<P><B>구조 프로그램 해결 방법:</B> 전체 파티션을 손실하기 전에
손상 받은 디스크 블록에서 데이터를 삭제하십시오.
</LI><LI><B>증상:</B> <B>vos listvol</B> 명령에
의해 각 볼륨에 대해 보고된 크기 통계를 토대로 사용자가 기대한 것보다
더 적은 여유 공간이 파티션에 있습니다.
<P>
<P><B>가능한 원인:</B> 고립된 파일 및 디렉토리가 있습니다. 고립된 요소는 그 상위 요소로
작동할 수 있는(파일 트리에서 상위 항목) 디렉토리에 의해 참조되지 않으므로
완전히 액세스가 불가능합니다. 고립된 요소는 서버 파티션에서 공간을 차지한다고
해도 볼륨 크기 계산에(또는 할당량 계산에) 포함되지 않습니다.
<P>
<P><B>구조 프로그램 해결 방법:</B> 기본적으로 발견된 고립된
요소의 수와 이들이 차지하는 공간의 대략적인 킬로바이트 수를 보고하는
메시지를 <B>/usr/afs/logs/SalvageLog</B> 파일에
출력하십시오. <B>-orphans</B> 인수를 사용하여 고립된 요소를
제거하거나 추가할 수 있습니다. <A HREF="#HDRWQ233">볼륨을 구조하려면</A>을 참조하십시오.
</LI></UL>
<P>이러한 증상을 확인하면 손상 상태가 확산되기 전에 <B>bos salvage</B>
명령을 사용하여 구조 프로그램을 호출하십시오(이 명령이 볼륨에 대해
작동되기는 하지만 BOS 서버가 볼륨 서버 및 파일 서버의 종료와 재시작을
구조 프로그램에 따라 조정해야 하므로 <B>bos</B> 집합에
속해 있습니다. 이 명령은 구조 프로그램이 시작되기 전에 이들 서버를 종료하고
구조 조작이 끝날 때 이들 서버를 자동으로 재시작합니다).
<P>파일 서버 시스템에 저장된 모든 AFS 데이터는 하나 이상의 파티션에 대한
구조 작업 중에 액세스할 수 없습니다. 하나의 볼륨만 구조하는 경우 해당
볼륨만 액세스할 수 없습니다.
<P>하나 이상의 파티션을 처리할 때 이 명령은 손상된 읽기/쓰기 볼륨에 대한
일관된 상태를 복원해 줍니다. 읽기 전용 또는 백업 볼륨의 경우 다음과 같이
볼륨 헤더만 검토합니다.
<UL>
<LI>볼륨 헤더가 손상된 경우 구조 프로그램은 볼륨을 완전히 제거하고 로그 파일
<B>/usr/afs/logs/SalvageLog</B>에 제거 내용을 기록합니다.
<B>vos release</B> 또는 <B>vos
backup</B> 명령을 실행하여 읽기 전용 또는 백업 볼륨을 다시 작성할 수 있습니다.
</LI><LI>볼륨 헤더가 손상되지 않았으면 구조 프로그램은 볼륨을 건너뜁니다(내용에
손상된 부분이 있는지 확인하지 않음). 그러나 파일 서버가 초기화될 때 손상
상태를 확인하면 볼륨을 추가하거나 온라인 상태로 설정하는 것을 거부하기도
합니다. 이 경우 <B>vos remove</B> 또는 <B>vos zap</B>
명령을 실행하여 볼륨을 제거하는 것이 가장 간단한 방법입니다.
그런 다음 <B>vos release</B> 또는 <B>vos
backup</B> 명령을 실행하여 다시 작성할 수 있습니다.
</LI></UL>
<P>다음과 같이 <B>bos salvage</B> 명령의 인수들을 조합해서
다른 수의 볼륨을 구조할 수 있습니다.
<UL>
<LI>파일 서버 시스템의 모든 볼륨을 구조하려면 <B>-server</B> 인수와 <B>-all</B> 플래그를 함께 사용하십시오.
</LI><LI>한 파티션의 모든 볼륨을 구조하려면 <B>-server</B> 및 <B>-partition</B> 인수를 함께 사용하십시오.
</LI><LI>하나의 읽기/쓰기 볼륨만 구조하려면 <B>-server</B>, <B>-partition</B> 및 <B>-volume</B>
인수를 함께 사용하십시오. BOS 서버가 단일 볼륨의 구조 작업 중에는 파일 서버 및
볼륨 서버 프로세스를 종료하지 않으므로 캐쉬 관리 프로그램은 해당 볼륨만
액세스할 수 없습니다. <B>-volume</B> 인수와 함께 읽기 전용 또는
백업 볼륨을 지정하지 마십시오. 대신 <B>vos remove</B> 또는
<B>vos zap</B> 명령을 사용하여 볼륨을 제거하십시오.
그런 다음 <B>vos release</B> 또는 <B>vos backup</B>
명령을 사용하여 볼륨의 새 사본을 작성하십시오.
</LI></UL>
<P>구조 프로그램은 항상 실행 중인 파일 서버 시스템의 <B>/usr/afs/logs/SalvageLog</B> 파일에 추적 내용을 씁니다. 다른 파일에 추적 내용을 기록하려면(AFS
또는 <B>bos salvage</B> 명령을 실행하는 시스템의 로컬
디스크에) <B>-file</B> 인수를 사용하여 파일을 명명하십시오.
또는 <B>/usr/afs/logs/SalvageLog</B> 파일에 추적 내용이
기록될 때 추적 결과를 표준 출력 스트림에 표시하려면
<B>-showlog</B> 플래그를 포함시키십시오.
<P>기본적으로 복수의 구조 프로그램 서브프로세스가 병렬로 실행되는 데 최대
네 개의 파티션 각각에 대해서는 하나씩, 네 개 이상의 파티션에 대해서는
네 개의 서브프로세스가 실행됩니다. 병렬로 실행되는 서브프로세스의 수를
늘리거나 줄이려면 <B>-parallel</B> 인수 값에 대해 양의
정수값을 제공하십시오.
<P>하나의 물리적 디스크에 둘 이상의 서버 파티션이 있으면 구조 프로그램은 기본적으로
파티션을 순차적으로 구조하여 한 파티션에서 다른 파티션으로 디스크 헤드가
자주 이동되는 비효율성을 피합니다. 그러나 이러한 전략은 파티션이 여러
디스크에 걸쳐 있는 논리 볼륨으로 구성된 경우에는 별로 이상적이지 않을 수
있습니다. 강제로 구조 프로그램이 병렬로 논리 볼륨을 구조하게 하려면
<B>-parallel</B> 인수의 값으로 <B>all</B>을
제공하십시오. 구조되는 논리 프로세스의 수에 따라 병렬로 실행될 서브프로세스의
수를 지정하려면 양의 정수를 제공하고(예를 들어 다섯 개의 서브프로세스의 경우
<B>-parallel 5all</B>) 네 개까지 서브프로세스를
실행하려면 해당 정수를 생략하십시오.
<P>구조 프로그램은 실행될 때 임시 파일을 작성하여 기본적으로 이 임시 파일을
구조하는 파티션에 씁니다. 파일의 수는 매우 클 수 있으며 파티션이 너무
꽉 차서 이들 파일을 저장할 수 없는 경우 구조 프로그램은 구조 조작을
완료하지 않고 종료됩니다(항상 종료되기 전에 임시 파일을 제거함).
다른 구조 프로그램 서브프로세스는 임시 파일을 저장할 충분한 공간이 있는
다른 모든 파티션을 다 구조할 때까지 동시에 계속 실행됩니다. 중단된 구조
조작을 완료하려면 해당 파티션에 대해 이 명령을 다시 실행하고
<B>-tmpdir</B> 인수를 추가하여 임시 파일 경로를 충분한 공간이
있는 로컬 디스크로 다시 지정하십시오.
<P><B>-orphans</B> 인수는 구조 프로그램이 구조 중인 서버
파티션에서 찾은 고립된 파일 및 디렉토리를 처리하는 방식을 제어합니다.
<I>고립된</I> 요소는 그 상위 요소로 작동할 수 있는(파일
공간에서 상위 항목) 디렉토리의 vnode에 의해 참조되지 않으므로 완전히
액세스가 불가능합니다. 고립된 오브젝트는 서버 파티션의 공간을 차지하지만
볼륨 할당량을 계산할 때 추가되지 않습니다.
<P>구조 작업 중에 <B>bos status</B> 명령의 출력은
<B>fs</B> 프로세스에 대해 다음의 보조 상태를 보고합니다.
<PRE>   
   Salvaging file system
   
</PRE>
<A NAME="IDX6709"></A>
<A NAME="IDX6710"></A>
<P><H3><A NAME="HDRWQ233" HREF="auagd002.htm#ToC_248">볼륨을 구조하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos salvage</B> 명령을 실행하여 하나 이상의 볼륨을
구조하십시오.
<P>
<PRE>   
   % <B>bos salvage  -server</B> &lt;<VAR>machine&nbsp;name</VAR>> 
[<B>-partition</B> &lt;<VAR>salvage&nbsp;partition</VAR>>]  \
                  [<B>-volume</B> &lt;<VAR>salvage&nbsp;volume&nbsp;number&nbsp;or&nbsp;volume&nbsp;name</VAR>>]  \
                  [<B>-file</B> <VAR>salvage&nbsp;log&nbsp;output&nbsp;file</VAR>]  [<B>-all</B>]  [<B>-showlog</B>]  \
                  [<B>-parallel</B> &lt;<VAR>#&nbsp;of&nbsp;max&nbsp;parallel&nbsp;partition&nbsp;salvaging</VAR>>]  \ 
                  [<B>-tmpdir</B> &lt;<VAR>directory&nbsp;to&nbsp;place&nbsp;tmp&nbsp;files</VAR>>]  \ 
                  [<B>-orphans</B> &lt;<B>ignore</B> | <B>remove</B> | <B>attach</B>>] 
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>-server
</B><DD>볼륨을 구조할 파일 서버 시스템을 명명합니다. 이 인수는
<B>-all</B> 플래그, <B>-partition</B> 인수 또는 <B>-partition</B>과
<B>-volume</B> 인수 둘 다와 함께 사용할 수 있습니다.
<P><DT><B>-partition
</B><DD>모든 볼륨을 구조할 단일 파티션을 명명합니다. <B>-server</B> 인수를 이 인수와 함께 사용해야 합니다.
<P><DT><B>-volume
</B><DD>구조할 한 읽기/쓰기 볼륨의 이름이나 볼륨 ID 번호를 지정합니다.
이 인수를 <B>-server</B> 및 <B>-partition</B> 인수와 함께 사용하십시오.
<P><DT><B>-file
</B><DD>구조 작업의 추적 결과를 쓸 파일과 서버 시스템의 <B>/usr/afs/logs/SalvageLog</B> 파일의 완전한 경로 이름을 지정합니다. 파일 경로 이름이 로컬이면
추적 결과는 <B>bos salvage</B> 명령이 실행된 시스템의
로컬 디스크에 있는 지정된 파일에 기록됩니다. <B>-volume</B> 인수가 포함되면 파일은 구조되는 볼륨에 있지 않은 AFS인
경우에도 AFS에 위치할 수 있습니다. 이 인수를 <B>-showlog</B> 플래그와 함께 사용하지 마십시오.
<P><DT><B>-all
</B><DD><B>-server</B> 인수에 의해 명명된 시스템의 모든
파티션에 있는 모든 볼륨을 구조합니다.
<P><DT><B>-showlog
</B><DD>표준 출력 스트림에 구조 조작의 추적 결과를 표시하고 이를
<B>/usr/afs/logs/SalvageLog</B> 파일에 씁니다.
<P><DT><B>-parallel
</B><DD>병렬로 실행될 구조 프로그램 서브프로세스의 최대 수를 지정합니다.
다음 세 가지 중 하나를 제공하십시오.
<UL>
<LI>범위 <B>1</B> - <B>32</B>의 정수.
<B>1</B> 값은 단일 구조 프로그램 서브프로세스가 순차적으로
파티션을 구조함을 의미합니다.
</LI><LI>여러 물리적 디스크에 걸쳐 있는 논리적 볼륨 형태로 포맷된 파티션에서
병렬로 네 개까지의 구조 프로그램 서브프로세스를 실행하기 위한 문자열
<B>all</B>. 이러한 논리적 볼륨에 대해서만 이 값을 사용하십시오.
</LI><LI>논리적 볼륨으로 포맷된 파티션에서 병렬로 지정된 수의 구조 프로그램
서브프로세스를 실행하기 위한 범위 <B>1</B> - <B>32</B>의 정수가 바로 뒤에 붙는 문자열 <B>all</B>(간격 없음).
이러한 논리적 볼륨에 대해서만 이 값을 사용하십시오.
</LI></UL>
<P>
<P>
<P>BOS 서버는 파티션 수보다 더 많은 수의 구조 프로그램 서브프로세스를
절대 시작하지 않으며 항상 단일 볼륨을 구조하기 위해서는 하나의 프로세스만
시작합니다.
이 인수가 생략되면 네 개까지의 구조 프로그램 서브프로세스가 동시에 실행됩니다.
<P><DT><B>-tmpdir
</B><DD>구조 프로그램 프로세스가 실행될 때 임시 파일을 쓰는 논리 디스크
디렉토리의 전체 경로 이름을 지정합니다. 기본적으로 현재 구조 중인 파티션에
임시 파일을 씁니다.
<P><DT><B>-orphans
</B><DD>구조 프로그램이 고립된 파일 및 디렉토리를 처리하는 방식을 제어합니다.
다음의 세 값 중 하나를 선택하십시오.
<P>
<DL>
<P><DT><B>ignore
</B><DD>디스크에 고립된 오브젝트를 그대로 두지만 발견된 고립된 요소의 수와
이들이 차지하는 공간의 대략적인 킬로바이트 수를 보고하는 메시지를
<B>/usr/afs/logs/SalvageLog</B> 파일에 출력합니다. 이것은
<B>-orphans</B> 인수를 생략할 때 기본값입니다.
<P><DT><B>remove
</B><DD>고립된 오브젝트를 제거하고 제거된 고립된 요소의 수와 이들이 차지하는
공간의 대략적인 킬로바이트 수를 보고하는 메시지를 <B>/usr/afs/logs/SalvageLog</B> 파일에 출력합니다.
<P><DT><B>attach
</B><DD>볼륨의 루트 디렉토리의 vnode에 고립된 오브젝트에 대한 참조를
작성하여 고립된 오브젝트를 추가합니다. 각 오브젝트의 실제 이름을 현재
잃어버렸으므로 구조 프로그램은 다음 양식에 따라 각각에 이름을 지정합니다.
<P>
<DL>
<DD><P>파일의 경우 <B>_ _ORPHANFILE_ _.</B><VAR>index</VAR>
<DD><P>디렉토리의 경우 <B>_ _ORPHANDIR_ _.</B><VAR>index</VAR>
</DL>
<P>
<P>
<P>여기서 <VAR>index</VAR>는 각 오브젝트를 고유하게 식별하는 2자리 숫자입니다.
고립된 오브젝트는 볼륨 할당량을 차지하며 볼륨 루트 디렉토리에 대해 실행된
<B>ls</B> 명령의 출력에도 나타납니다.
</DL>
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ234" HREF="auagd002.htm#ToC_249">볼륨 할당량과 현재 크기 설정 및 표시</A></H2>
<A NAME="IDX6711"></A>
<A NAME="IDX6712"></A>
<P>모든 AFS 볼륨은 볼륨의 크기를 제한하는 연관된 <VAR>할당량</VAR>을 가지고
있습니다. 새로 작성된 볼륨의 기본 할당량은 5,000 킬로바이트 블록(5 MB보다
약간 작음)입니다. 볼륨이 그 할당량에 도달하면 파일 서버는 새 파일이나
디렉토리를 작성하려는 시도를 거부합니다. 응용프로그램이 꽉 찬 볼륨의
기존 파일에 데이터를 쓰는 경우 파일 서버는 정의된 과잉 상태(기본적으로
1MB)를 허용합니다(<B>fileserver</B> 명령의 <B>-spare</B> or <B>-pctspare</B> 인수를 사용하면 기본 과잉 상태를 변경할 수 있습니다.
<I>AFS Administration Reference</I>에서 명령 참조 페이지를 참조하십시오).
<P>볼륨을 작성할 때 5000 KB가 넘는 할당량을 설정하려면 <A HREF="#HDRWQ185">읽기/쓰기 볼륨 작성</A>에서
설명하는 것처럼 <B>vos create</B> 명령에
<B>-maxquota</B> 인수를 포함시키십시오. 기존 볼륨의
할당량을 수정하려면 다음에서 설명하는 것처럼 <B>fs setquota</B> 또는
<B>fs setvol</B> 명령을 실행하십시오.
기존 볼륨의 할당량을 현재 크기보다 더 작게 설정하지 마십시오.
<P>보통 볼륨 크기가 작을수록 관리하기가 더 쉬워집니다.
로드 밸런스를 위해 볼륨을 이동해야 하는 경우 다른 파티션에서 작은 볼륨을
위한 여유 공간을 찾는 일이 더 쉽습니다. 볼륨이 작을 경우 이동 작업이 보다
빠르게 진행되므로 이동을 방해할 수 있는 작동 중단 상태나 다른 오류가
발생할 가능성이 줄어듭니다. AFS는 여러 다른 AFS 릴리스마다 달라질 수
있는 최대 볼륨 크기를 지원합니다. 사용 중인 버전에 대해서는 <I>AFS 릴리스 노트</I>를
참조하십시오. 또한 하나의 볼륨이 여러 파티션이나 논리적 볼륨에 걸쳐 있을 수
없으므로 파티션이나 논리적 볼륨의 크기에 따라 볼륨 크기가 제한됩니다.
<P>일반적으로 모든 볼륨이 최대 할당량에 도달한 경우 실제로 채울 수 있는
볼륨보다 더 많은 볼륨을 추가하여 파티션을 과도하게 채우는 것이 안전합니다.
그러나 셀에서 어느 정도까지 볼륨을 과도하게 채울 수 있는가는 경험을 통해서만
알 수 있습니다.
이것은 볼륨에 할당하는 할당량의 종류(특히 시스템 볼륨보다 갑자기 커질 확률이 높은
사용자 볼륨)와 사람들이 할당량과 비교하여 생성하고 저장하는 정보의 양에
따라 달라질 수 있습니다.
<P>다음에서 설명하는 것처럼 볼륨의 할당량을 표시하는 여러 가지 명령이
있습니다. 이들 명령은 각 명령이 생성하는 관련 정보의 양에서 차이를 나타냅니다.
<P><H3><A NAME="Header_250" HREF="auagd002.htm#ToC_250">단일 볼륨에 대한 할당량을 설정하려면</A></H3>
<A NAME="IDX6713"></A>
<A NAME="IDX6714"></A>
<A NAME="IDX6715"></A>
<A NAME="IDX6716"></A>
<A NAME="IDX6717"></A>
<OL TYPE=1>
<LI>사용자가 <B>system:administrators</B> 그룹에 속하는지
확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ587">system:administrators 그룹 구성원을 표시하려면</A>에서 자세히 설명되어 있는
<B>pts membership</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>pts membership system:administrators</B>
   
</PRE>
</LI><LI><B>fs setquota</B> 명령을 실행하여 볼륨의 최대 할당량을
설정하십시오.
<P>
<PRE>   
   % <B>fs setquota</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
<B>-max</B> &lt;<VAR>max&nbsp;quota&nbsp;in&nbsp;kbytes</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sq
</B><DD>허용되는 <B>setquota</B>의 별명입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>지정된 할당량을 설정할 볼륨에 있는 파일 또는 디렉토리를 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
<P>
<P>파일 또는 디렉토리에 대한 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨을
변경하려고 할 때 발생하는 장애를 피하십시오. 일반적으로
경로 이름의 두 번째 레벨의 셀 이름 앞에 마침표를 사용하여 읽기/쓰기 경로를
나타내십시오(예를 들어 <B>/afs/.abc.com</B>). 파일 경로를
통한 읽기/쓰기 및 읽기 전용 경로의 개념에 대해 좀더 살펴 보려면
<A HREF="#HDRWQ209">마운트 포인트 통과 규칙</A>을 참조하십시오.
<P><DT><B><VAR>max quota in kbytes</VAR>
</B><DD>킬로바이트 블록(<B>1024</B>가 1MB임)으로 표현되는
볼륨 할당량을 설정합니다. 값 <B>0</B>은 제한없는 할당량을
부여하지만 파티션의 크기에는 절대 제한이 적용됩니다.
<VAR>dir/file path</VAR> 인수를 생략하는 경우(현재 작업 디렉토리가 있는
볼륨에 할당량을 설정하기 위해) <B>-max</B> 스위치를
포함시켜야 합니다.
</DL>
</LI></OL>
<P><H3><A NAME="Header_251" HREF="auagd002.htm#ToC_251">하나 이상의 볼륨에 대한 최대 할당량을 설정하려면</A></H3>
<A NAME="IDX6718"></A>
<A NAME="IDX6719"></A>
<A NAME="IDX6720"></A>
<A NAME="IDX6721"></A>
<OL TYPE=1>
<LI>사용자가 <B>system:administrators</B> 그룹에 속하는지
확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ587">system:administrators 그룹 구성원을 표시하려면</A>에서 자세히 설명되어 있는
<B>pts membership</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>pts membership system:administrators</B>
   
</PRE>
</LI><LI><B>fs setvol</B> 명령을 실행하여 하나 이상의 볼륨에
대한 할당량을 설정하십시오.
<P>
<PRE>   
   % <B>fs setvol</B> [&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>] <B>-max</B> &lt;<VAR>disk&nbsp;space&nbsp;quota&nbsp;in&nbsp;1K&nbsp;units</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sv
</B><DD>허용되는 <B>setvol</B>의 별명입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>지정된 할당량을 설정할 각 볼륨에 있는 파일 또는 디렉토리를 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
<P><DT><B><VAR>disk space quota in 1K units</VAR>
</B><DD>킬로바이트 블록(<B>1024</B>가 1MB임)으로 표현되는
각 볼륨의 최대 할당량을 설정합니다. 값 <B>0</B>은 제한없는
할당량을 부여하지만 파티션의 크기에는 절대 제한이 적용됩니다.
</DL>
</LI></OL>
<A NAME="IDX6722"></A>
<A NAME="IDX6723"></A>
<A NAME="IDX6724"></A>
<A NAME="IDX6725"></A>
<P><H3><A NAME="Header_252" HREF="auagd002.htm#ToC_252">사용된 퍼센트 할당량을 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>fs quota</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs quota</B> [&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>q
</B><DD>허용되는 <B>quota</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>사용된 퍼센트 할당량을 표시할 각 볼륨에 있는 디렉토리나 파일을 명명합니다.
부분 경로 이름은 이 인수가 생략되었을 때 기본 디렉토리인 현재 작업
디렉토리에 상대적으로 해석됩니다.
</DL>
</LI></OL>
<P>다음 예제는 이 명령이 생성한 출력을 보여 줍니다.
<PRE>   
   % <B>fs quota /afs/abc.com/usr/terry</B>
   34% of quota used.
   
</PRE>
<A NAME="IDX6726"></A>
<A NAME="IDX6727"></A>
<A NAME="IDX6728"></A>
<A NAME="IDX6729"></A>
<A NAME="IDX6730"></A>
<A NAME="IDX6731"></A>
<P><H3><A NAME="Header_253" HREF="auagd002.htm#ToC_253">할당량, 현재 크기 및 기타 정보를 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>fs listquota</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs listquota</B>
[&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>lq
</B><DD><B>listquota</B>의 별명입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>볼륨 이름 및 현재 공간 사용도와 함께 할당량을 표시할 각 볼륨에 있는
디렉토리나 파일을 명명합니다. 부분 경로 이름은 이 인수가 생략되었을 때
기본 디렉토리인 현재 작업 디렉토리에 상대적으로 해석됩니다.
</DL>
</LI></OL>
<P>다음 예에서 보여주는 것처럼 출력은 볼륨의 이름, 그 할당량과 현재 크기(모두
킬로바이트 블록 단위로), 사용된 퍼센트 할당량 및 사용된 볼륨의 호스트
파티션에 있는 공간의 백분율을 보고합니다.
<PRE>   
   % <B>fs listquota /afs/abc.com/usr/terry</B>
   Volume Name     Quota    Used    % Used   Partition 
   user.terry      15000    5071       34%         86%   
   
</PRE>
<A NAME="IDX6732"></A>
<A NAME="IDX6733"></A>
<A NAME="IDX6734"></A>
<A NAME="IDX6735"></A>
<A NAME="IDX6736"></A>
<A NAME="IDX6737"></A>
<A NAME="IDX6738"></A>
<P><H3><A NAME="Header_254" HREF="auagd002.htm#ToC_254">할당량, 현재 크기 및 추가 파티션 정보를 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>fs examine</B> 명령을 실행하십시오.
<P>
<PRE>   
   % <B>fs examine</B>
[&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>exa
</B><DD>허용되는 <B>examine</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>할당량 정보와 호스트 파티션에 대한 정보를 표시할 각 볼륨에 있는
디렉토리나 파일을 명명합니다. 부분 경로 이름은 이 인수가 생략되었을 때
기본 디렉토리인 현재 작업 디렉토리에 상대적으로 해석됩니다.
</DL>
</LI></OL>
<P>다음 예에서 보여주는 것처럼 출력은 볼륨의 볼륨 ID 번호와 이름, 그 할당량과
현재 크기(모두 킬로바이트 블록 단위로), 볼륨 호스트 파티션에서 킬로바이트
블록의 총 수와 이중 사용 가능한 블록의 수를 보고합니다.
<PRE>   
   % <B>fs examine /afs/abc.com/usr/terry</B>
   Volume status for vid = 50489902 named user.terry
   Current maximum quota is 15000
   Current blocks used are 5073
   The partition has 46383 blocks available out of 333305   
   
</PRE>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 명령의 출력에서 파티션 관련 통계가 항상 표준 UNIX <B>df</B>
명령 출력의 해당 값과 일치하는 것은 아닙니다. 이 명령에서 보고한 통계는
캐쉬 관리 프로그램이 5분 간격으로 파티션 정보에 대해 파일 서버를 폴링하므로
생성된 이후에 최대 5분까지 경과될 수 있습니다. 또한 일부 운영 체제에서
<B>df</B> 명령의 파티션 크기 보고에는 이 명령의 계산에는
포함되어 있지 않은 예약된 공간이 포함되므로 약 10%가 더 커질 수 있습니다.
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ235" HREF="auagd002.htm#ToC_255">볼륨 및 마운트 포인트 제거</A></H2>
<A NAME="IDX6739"></A>
<A NAME="IDX6740"></A>
<A NAME="IDX6741"></A>
<A NAME="IDX6742"></A>
<A NAME="IDX6743"></A>
<P>사이트에서 볼륨을 제거하고 VLDB에서 그 레코드를 제거하려면
<B>vos remove</B> 명령을 사용하십시오. 이 명령을 사용하면
다음의 세 가지 유형의 볼륨 중 하나를 제거할 수 있습니다. 그 결과는 유형마다
다릅니다.
<UL>
<LI><B>.readonly</B> 또는 <B>.backup</B>
확장자 없이 볼륨의 기본 이름을 지정하여 읽기/쓰기 볼륨을 지정하는 경우
이 명령은 볼륨이 있는 파티션에서 읽기/쓰기 볼륨과 연관된 백업 볼륨을 모두
제거합니다. 
<A NAME="IDX6744"></A>
<A NAME="IDX6745"></A>
하나의 읽기/쓰기 사이트만 있을 수 있으므로
<B>-server</B> 및 <B>-partition</B> 인수를
제공할 필요가 없습니다. 사이트 정보도 VLDB 항목에서 제거되며 사이트
계수(<B>vos examine</B> 및 <B>vos listvldb</B>
명령에 의해 <TT>number of sites</TT>로 보고)는 1씩 줄어듭니다. 읽기/쓰기
및 백업 볼륨 ID 번호는 더 이상 <B>vos examine</B> 및
<B>vos listvldb</B> 명령의 출력에 나타나지 않으나
내부적으로는 보존됩니다. 읽기 전용 사이트는 있는 경우에 이 명령의 영향을
받지 않으나 읽기/쓰기 사이트가 다시 정의되어야만 변경될 수 있습니다.
전체 VLDB 항목은 읽기 전용 생트가 없는 경우 제거됩니다.
<P>
<P>남아 있는 읽기 전용 사본이 없는 경우 볼륨의 마운트 포인트를 제거하여
볼륨 내용에 대한 액세스 시도를 막는 것이 가장 바람직합니다. 읽기 전용
볼륨의 사본이 남아 있는 경우 마운트 포인트를 제거하지 마십시오.
</LI><LI><B>.readonly</B> 확장자를 이름에 포함시켜 읽기 전용
볼륨을 지정한 경우 이 볼륨은 저장되어 있는 파티션에서 제거되며 VLDB 항목에서
해당 사이트 정보가 제거됩니다. <B>vos examine</B> 및
<B>vos listvldb</B> 명령에서 <TT>number of sites</TT>로
보고한 사이트 계수는 제거하는 각 볼륨에 따라 1씩 줄어듭니다.
<A NAME="IDX6746"></A>
<P>
<P>
<P>둘 이상의 읽기 전용 사이트가 있는 경우 <B>-server</B>
인수(및 선택적으로 <B>-partition</B> 인수)를 포함시켜
볼륨을 제거할 사이트를 지정해야 합니다. 하나의 읽기 전용 사이트만 있는 경우
볼륨 이름으로도 충분합니다. 이 경우 읽기/쓰기 볼륨이 존재하지 않으면
전체 VLDB 항목이 제거됩니다.
<P>
<P>읽기 전용 볼륨을 제거할 때, 특히 볼륨의 읽기/쓰기 버전이 여전히 존재할 때
볼륨의 마운트 포인트를 제거하는 것은 별로 적절하지 않습니다. 읽기/쓰기
버전이 더 이상 존재하지 않는 경우 <A HREF="#HDRWQ236">볼륨을 제거하고 언마운트하려면</A>의
단계 <A HREF="#LIWQ239">5</A>에서 설명하는 것처럼 마운트 포인트를
제거하십시오.
</LI><LI><B>.backup</B> 확장자를 포함시켜 백업 볼륨을 지정한
경우 이 볼륨은 저장되어 있는 파티션에서 제거되며 VLDB 항목에서 해당
사이트 정보가 제거됩니다. 하나의 백업 사이트만 있을 수 있으므로
<B>-server</B> 및 <B>-partition</B> 인수를 제공할 필요가 없습니다. 백업 볼륨 ID 번호는
<B>vos examine</B> 또는 <B>vos listvldb</B>
명령의 출력에 더 이상 나타나지 않지만 내부적으로는 보존됩니다.
<P>
<P>표준 구성에서는 사용자 볼륨의 백업 버전에 대한 별도의 마운트 포인트가 있습니다.
존재하지 않는 볼륨의 내용을 액세스하려는 시도를 막기 위해 해당 마운트 포인트를
제거하도록 하십시오.
</LI></UL>
<P><H3><A NAME="Header_256" HREF="auagd002.htm#ToC_256">기타 제거 명령</A></H3>
<A NAME="IDX6747"></A>
<P><B>vos remove</B> 명령은 파티션에서 볼륨의 VLDB 항목과
볼륨 헤더 및 모든 데이터를 자동적으로 제거하므로 볼륨을 제거하는 적절한
방법으로 사용됩니다. VLDB 항목이나 볼륨 헤더가 없는 경우 나머지 요소만
제거하는 다른 명령을 사용하는 것이 필요할 수도 있습니다. VLDB 항목과
볼륨 헤더가 모두 존재하는 정상적인 경우에는 이들 명령을 사용하지 마십시오.
왜냐하면 VLDB 항목과 볼륨 헤더 간에 불일치가 발생할 수 있기 때문입니다.
명령 구문에 대한 자세한 정보를 보려면 <I>AFS Administration Reference</I>에서 해당 참조 페이지를
참조하십시오.
<P><B>vos zap</B> 명령은 VLDB 항목이 더 이상 존재하지 않는
볼륨 헤더 및 볼륨 데이터를 제거함으로써 사이트에서 볼륨을 제거합니다.
<A NAME="IDX6748"></A>
<A NAME="IDX6749"></A>
<P>
<B>vos listvol</B> 명령이 볼륨 헤더를 표시하지만
<B>vos examine</B> 또는 <B>vos listvldb</B>
명령이 VLDB 항목을 찾을 수 없는 경우에는 VLDB 항목이 없다고 말할 수 있습니다.
<B>vos syncvldb</B> 및 <B>vos syncserv</B>
명령은 볼륨 헤더를 절대 제거하지 않으므로 불일치를 해결하려면 이 명령을
실행해야 합니다.
<P><B>vos remsite</B> 명령은 파일 서버 시스템의 볼륨에는 영향을
미치지 않으면서 VLDB에서 읽기 전용 사이트 정의를 제거합니다.
<A NAME="IDX6750"></A>
<A NAME="IDX6751"></A>
<P>
실수로 <B>vos addsite</B> 명령을 실행하여 읽기 전용 사이트를
정의했으나 아직 <B>vos release</B> 명령을 실행하여
사이트로 볼륨을 릴리스하지 않았으면 이 명령을 사용하십시오. 실제로 사이트에
볼륨을 릴리스했으면 <B>vos remove</B> 명령을 대신 사용하십시오.
<P><B>vos delentry</B> 명령은 사용자가 지정하는 볼륨을
언급하는 전체 VLDB 항목을 제거합니다. 
<A NAME="IDX6752"></A>
<A NAME="IDX6753"></A>
파일 서버 시스템에 볼륨의 버전이
실제로 존재하는 경우 이들 버전은 영향을 받지 않습니다. 이 명령은
볼륨 제거 내용이 VLDB에 기록되지 않았다는 사실을 사용자가 알고
있으며(사용자는 긴급 상황 중에는 <B>vos zap</B> 명령을 사용했을
것임) <B>vos syncvldb</B> 및 <B>vos syncserv</B>
명령을 사용하여 전체 VLDB를 재동기화하는데 시간을 소비하지 않으려고
할 때 유용합니다.
<P><H3><A NAME="HDRWQ236" HREF="auagd002.htm#ToC_257">볼륨을 제거하고 언마운트하려면</A></H3>
<A NAME="IDX6754"></A>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>볼륨의 마운트 포인트를 제거하는 경우 상위 디렉토리의 ACL에 대한
<B>d</B>(<B>delete</B>) 권한이 있는지 확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI><A NAME="LIWQ237"></A><B>(선택적)</B> 나중에 볼륨을 복원하려는
경우 볼륨을 파일이나 테이프로 덤프하십시오. 볼륨의 내용을 파일로 복사하려면
<A HREF="#HDRWQ240">볼륨 덤프 및 복원</A>의 지시에 따라 <B>vos dump</B>
명령을 사용하십시오. 그런 다음 타사의 백업 유틸리티나 UNIX <B>tar</B> 명령과 같은 보존 유틸리티를 사용하여 파일을 테이프로 복사할 수 있습니다.
<P>
<P>또는 AFS 백업 시스템을 사용하여 테이프 사본을 작성하십시오. 이 경우
중요한 볼륨만 포함하는 임시 볼륨 집합을 작성하는 것이 편리할 수 있습니다.
임시 볼륨 집합은 백업 데이터베이스에 기록되지 않으므로 한 번만 사용하는
볼륨 집합에 대한 레코드로 데이터베이스를 복잡하게 만들지 마십시오.
지침을 보려면 <A HREF="auagd012.htm#HDRWQ301">덤프 작성하기</A>를 참조하십시오.
<A NAME="IDX6755"></A>
<A NAME="IDX6756"></A>
</LI><LI><A NAME="LIWQ238"></A><B>vos remove</B> 명령을 실행하여 볼륨을
제거하십시오. 복수의 사이트에서 읽기 전용 볼륨을 제거하는 경우 각 볼륨에 대해
이 명령을 반복하십시오.
<P>
<PRE>   
   % <B>vos remove</B> [<B>-server</B> <VAR>machine&nbsp;name</VAR>>]  [<B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>]  \
                <B>-id</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>remo
</B><DD>허용되는 <B>remove</B>의 가장 짧은 축약형입니다.
<P><DT><B>-server
</B><DD>볼륨이 위치하는 파일 서버 시스템을 지정합니다. 이 인수는
<B>-id</B> 인수가 복수의 사이트에 존재하는 읽기 전용 볼륨을
명명할 때만 필요합니다.
<P><DT><B>-partition
</B><DD>볼륨이 위치하는 <VAR>machine name</VAR>의 파티션을 명명합니다.
이 인수는 <B>-id</B> 인수가 복수의 사이트에 존재하는
읽기 전용 볼륨을 명명할 때만 필요합니다. 이 인수와 함께
<B>-server</B> 인수를 제공하십시오.
<P><DT><B>-id
</B><DD>완전한 이름이나 볼륨 ID 번호로 제거할 볼륨을 식별합니다. 읽기
전용 또는 백업 볼륨을 이름에 따라 식별하는 경우 적절한
확장자(<B>.readonly</B> 또는 <B>.backup</B>)를
포함시키십시오.
</DL>
<A NAME="IDX6757"></A>
<A NAME="IDX6758"></A>
</LI><LI><A NAME="LIWQ239"></A>볼륨의 마지막 기존 버전을 제거하는 경우
<B>fs rmmount</B> 명령을 실행하여 해당 마운트 포인트를
제거하십시오. <A HREF="#HDRWQ236">볼륨을 제거하고 언마운트하려면</A>에 나타난 지시를 따르십시오.
<P>
<P>일반적인 방법으로 마운트된 백업 볼륨을 제거하는 경우(읽기/쓰기 볼륨의
루트 디렉토리의 하위 디렉토리에) 이 단계에서 원본 볼륨의 마운트 포인트를
제거하는 것은 백업 볼륨의 마운트 포인트를 제거하는 것으로 충분합니다.
완전히 구분된 디렉토리에 백업 볼륨을 마운트한 경우 백업 볼륨의 마운트 포인트에
대해 이 단계를 반복해야 합니다.
<P>
<PRE>   
   % <B>fs rmmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
</LI><LI><B>(선택적)</B> 단계 <A HREF="#LIWQ237">3</A>에서
덤프 파일을 작성한 경우 이를 테이프로 옮기십시오. 선호되는 방법은
<A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및 <A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>에서 설명하는 것처럼
AFS 백업 시스템을 사용하는 것입니다.
</LI></OL>
<HR><H2><A NAME="HDRWQ240" HREF="auagd002.htm#ToC_258">볼륨 덤프 및 복원</A></H2>
<A NAME="IDX6759"></A>
<A NAME="IDX6760"></A>
<P><B>vos dump</B> 명령을 사용하여 볼륨을
<I>덤프</I>하면 그 내용이 ASCII 형식으로 변환되고
사용자가 지정한 파일에 기록됩니다. <B>vos restore</B> 명령은
덤프 파일을 지정된 파일 서버 시스템에 적절한 볼륨 형식으로 변환한 후
볼륨에 추가합니다.
<P><H3><A NAME="Header_259" HREF="auagd002.htm#ToC_259">볼륨 덤프에 대하여</A></H3>
<A NAME="IDX6761"></A>
<A NAME="IDX6762"></A>
<A NAME="IDX6763"></A>
<A NAME="IDX6764"></A>
<A NAME="IDX6765"></A>
<A NAME="IDX6766"></A>
<P>볼륨을 덤프하는 것은 다음을 포함하여 여러 상황에서 유용할 수 있습니다.
<UL>
<LI>타사의 백업 유틸리티를 사용하여 볼륨을 테이프로 백업하려고 할 때.
이러한 유형의 백업 조작을 용이하게 하기 위해 <B>vos dump</B> 명령은 명명된 파이프로 백업할 수 있습니다. 그 대신 AFS 백업
시스템을 사용하는 경우에 대한 정보를 보려면 <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및
<A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
</LI><LI>셀에서 볼륨을 제거하는 경우(소유자가 셀을 떠나는 것이 원인이 될 수
있음). <B>vos dump</B> 명령을 사용하면 백업 시스템의 오버헤드를
늘리지 않으면서 보관을 위해 사본을 작성할 수 있습니다. 볼륨 제거에 대한
자세한 정보를 보려면 <A HREF="#HDRWQ235">볼륨 및 마운트 포인트 제거</A>를 참조하십시오.
</LI><LI>보관을 위해 비 AFS 서버 파이션에 볼륨의 사본을 작성한 다음 실제 볼륨을
다른 시스템으로 이동하거나 해당 볼륨이 있는 파티션에 대해 유지보수 타스크를
수행하려 할 수 있습니다.
</LI><LI>손상된 읽기/쓰기 볼륨을 바꿀 필요가 있습니다. 볼륨의 손상되지 않은
읽기 전용 또는 백업 버전이 있는 경우 이를 덤프하고 읽기/쓰기 볼륨으로
데이터를 복원한 다음 손상된 내용을 덮어쓰십시오.
</LI><LI>볼륨의 내용을 다른 셀로 복사하거나 옮길 수 있습니다.
AFS에서 동일한 셀에 속하는 파일 서버 시스템 간의 볼륨 이동만 지원하므로
<B>vos move</B> 명령은 사용할 수 없습니다.
</LI><LI>볼륨의 내용에 대한 또 다른 읽기/쓰기 사본을 가질 수 있습니다. 두 번째
볼륨은 원래 볼륨과 다른 이름을 가져야 합니다. 두 볼륨의 내용을 동일하게
유지하려면 두 볼륨을 수동으로 갱신해야 합니다. AFS는 읽기/쓰기 볼륨을 이러한
방식으로 동기화하기 위한 기능은 제공하지 않습니다.
</LI><LI>특정 날짜 이후의 수정 시간 소인을 가지는 파일 및 디렉토리 사본을
볼륨에 작성할 수 있습니다. <B>vos dump</B> 명령은
다음 지침의 단계 <A HREF="#LIWQ241">3</A>에서 설명하는 것처럼 점층적
덤프 파일을 작성할 수 있습니다.
</LI></UL>
<A NAME="IDX6767"></A>
<A NAME="IDX6768"></A>
<A NAME="IDX6769"></A>
<P><B>vos dump</B> 명령을 사용하여 명령을 실행할 때 볼륨의
완전한 내용을 포함하는 <I>전체 덤프</I>를 작성하거나
사용자가 지정한 날짜 및 시간보다 나중 날짜가 찍힌 수정 시간 소인이 있는
파일 및 디렉토리만 포함하는 <I>점층적 덤프</I>를 작성할
수 있습니다 (<B>ls -l</B> 명령에 의해 표시). 다음
지침의 단계 <A HREF="#LIWQ241">3</A>을 참조하십시오.
<P>볼륨을 덤프할 경우 VLDB 항목이 변경되지 않고 파일 서버 시스템에서 그 상태에
영구히 영향을 미치지는 않지만 덤프 조작 중에 볼륨의 내용을 액세스할 수
없습니다. 볼륨에 대한 액세스 작업을 방해하지 않으려면
<B>vos backup</B> 또는 <B>vos backupsys</B>
명령을 실행하여 새로운 백업 버전을 작성한 후에 볼륨의 백업 버전을
덤프하는 것이 가장 바람직합니다.
<P>덤프를 기록할 파일 이름을 제공하지 않으면 <B>vos dump</B>
명령이 출력 경로를 표준 출력 스트림으로 지정합니다. 원하는 경우 출력을
<B>vos restore</B> 명령으로 직접 파이프할 수 있습니다.
<P>볼륨 덤프 파일이 ASCII 형식이므로 <B>cat</B> 명령과 같은
명령이나 문서 편집기를 사용하여 그 내용을 읽을 수 있습니다.
그러나 덤프 파일에는 영숫자 상관 관계가 없는 특수 문자가 포함되는 경우가
있어서 일부 표시 프로그램에서 문제를 유발할 수 있습니다.
<P>기본적으로 <B>vos</B> 명령 인터프리터는 VLDB(Location Database)를
확인하여 볼륨의 위치를 알아내므로
<B>-server</B> 및 <B>-partition</B>
인수가 필요하지 않습니다. <B>-id</B> 인수가 복수의 사이트에
위치하는 읽기 전용 볼륨을 식별하는 경우 이 명령은 여러 사이트 중
하나(보통 <B>vos examine</B> 또는 <B>vos listvldb</B> 명령에서 보고된 대로 볼륨의 VLDB 항목에 나열된 첫째
사이트)의 버전을 덤프합니다. 특정 사이트에서 읽기 전용 볼륨을 덤프하려면
<B>-server</B> 및 <B>-partition</B>
인수를 사용하여 덤프할 사이트를 지정하십시오. VLDB 조회를 완전히 무시하려면
<B>-id</B> 인수에 대한 값으로 볼륨 ID 번호(볼륨 이름 대신)와
<B>-server</B> 및 <B>-partition</B> 인수를
함께 제공하십시오. 이렇게 하면 VLDB 항목이 없는 볼륨을 덤프할 수 있습니다.
<A NAME="IDX6770"></A>
<A NAME="IDX6771"></A>
<P><H3><A NAME="Header_260" HREF="auagd002.htm#ToC_260">볼륨을 덤프하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>덤프 파일을 작성하는 데 필요한 권한이 있는지 확인하십시오.
AFS에 덤프 파일을 추가하는 경우 해당 파일 디렉토리의 ACL에 대해
<B>i</B>(<B>insert</B>) 권한이 있어야 합니다.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI><A NAME="LIWQ241"></A><B>vos dump</B> 명령을 실행하여
볼륨을 덤프하십시오.
<P>
<PRE>   
   % <B>vos dump -id</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>> [<B>-time</B> &lt;<VAR>dump&nbsp;from&nbsp;time</VAR>>] 
[<B>-file</B> &lt;<VAR>arg</VAR>>]  [<B>-server</B> &lt;<VAR>server</VAR>>]  [<B>-partition</B> &lt;<VAR>partition</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>-id
</B><DD>완전한 이름이나 볼륨 ID 번호로 덤프할 볼륨을 식별합니다. 읽기 전용
또는 백업 버전을 덤프하려는 경우 그 볼륨 ID 번호를 지정하거나 적절한
확장자(<B>.readonly</B> 또는 <B>.backup</B>)를
이름에 추가하십시오.
<P>
<P>볼륨 위치에 대한 일반적인 VLDB 조회를 무시하려면 볼륨 ID 번호를 제공하고
이 인수를 <B>-server</B> 및 <B>-partition</B> 인수와 함께 사용하십시오.
<P><DT><B>-time
</B><DD>덤프가 덤프 또는 점층적 형태 중 어떤 것인지 지정합니다. 전체 덤프를
작성하려면 이 인수를 생략하십시오. 그렇지 않으면 다음의 세 가지 값 중 하나를
제공하십시오.
<UL>
<LI>전체 덤프를 작성하기 위한 값 <B>0</B>.
</LI><LI>지정된 날짜에서 자정(오전 12시) 이후의 수정 시간 소인이 찍힌 파일과 디렉토리만 포함하는
점층적 덤프를 작성하기 위한 형식 <I>mm</I><B>/</B><I>dd</I><B>/</B><I>yyyy</I>(월, 일, 년)의
날짜. 연도에 사용할 수 있는 값은 <B>1970</B> - <B>2037</B>입니다. 더 높은 값은 표준 UNIX 표현에서
사용할 수 있는 가장 최근 연도가 2038년이므로 사용할 수 없습니다.
명령 인터프리터는 최대값보다 더 나중의 날짜는 자동으로 줄입니다.
예로서 <B>01/13/1999</B>를 들 수 있습니다.
</LI><LI>지정된 날짜와 시간보다 더 나중의 수정 시간 소인이 찍힌 파일과
디렉토리만 포함하는 점층적 덤프를 작성하기 위한 형식 <B>"</B><I>mm</I><B>/</B><I>dd</I><B>/</B><I>yyyy</I> <I>hh</I><B>:</B><I>MM</I><B>"</B>의 날짜 및 시간.
이 날짜 형식은 날짜만 사용했을 때와 동일합니다. 시간은 24시간 형식의
시간 및 분(<I>hh</I>:<I>MM</I>)처럼
표현하십시오(예: <B>20:30</B>은 8:30 p.m.임).
전체 표현식에는 공백이 들어 있으므로 큰 따옴표(" ")로 묶으십시오.
예를 들면 <B>"01/13/1999 22:30"</B>과 같습니다.
</LI></UL>
<P><DT><B>-file
</B><DD>덤프를 쓸 파일의 경로 이름을 지정합니다. 파일은 덤프되는 볼륨에
있지 않은 경우에도 AFS에 위치할 수 있습니다. 부분 경로 이름은 현재
작업 디렉토리에 상대적으로 해석됩니다. 덤프 경로를 표준 출력 스트림으로
지정하려면 이 인수를 생략하십시오.
<P><DT><B>-server
</B><DD>볼륨이 위치하는 파일 서버 시스템을 지정합니다. 이 인수와 함께
<B>-partition</B> 인수를 제공하십시오.
<P><DT><B>-partition
</B><DD>볼륨이 위치하는 파티션을 지정합니다. 이 인수와 함께
<B>-server</B> 인수를 제공하십시오.
</DL>
</LI></OL>
<P><H3><A NAME="Header_261" HREF="auagd002.htm#ToC_261">볼륨 복원에 대하여</A></H3>
<A NAME="IDX6772"></A>
<A NAME="IDX6773"></A>
<P>세 가지 유형의 볼륨(읽기/쓰기, 읽기 전용 또는 백업) 중 하나를 덤프할 수
있으나 <B>vos restore</B> 명령을 사용하여 덤프 파일을
읽기/쓰기 볼륨으로서만 파일 시스템에 복원할 수 있습니다. 이 명령은
ASCII에서 복원된 버전을 저장하는 파일 서버 시스템에 적절한 볼륨 형식으로
덤프 파일의 내용을 자동으로 변환합니다.
<B>vos dump</B> 명령을 사용할 때처럼 타사의 백업 유틸리티와의
상호 작용을 용이하게 해 주는 명명된 파이프를 통해 덤프 파일을 복원할 수
있습니다.
<P>두 가지 기본 방법 중 하나로 덤프 파일의 내용을 복원할 수 있습니다.
두 경우 모두 점층적 덤프를 복원하기 전에 전체 덤프를 복원해야 합니다.
그런 다음 복원하는 점층적 덤프는 전체 덤프 이후에 작성되어야 합니다.
둘 이상의 점층적 덤프가 있는 경우 작성된 순서대로 복원해야 합니다.
<UL>
<LI>지정한 위치에 새 이름을 가진 완전히 새로운 볼륨으로 볼륨 데이터를 복원할
수 있습니다. <A HREF="#HDRWQ242">새 볼륨으로 덤프를 복원하고 마운트하려면</A>을 참조하십시오.
<P>
<P>볼륨 서버가 자동으로 볼륨 번호를 할당하게 하는 것이 가장 바람직하지만
볼륨을 복원할 때 볼륨 ID 번호를 지정할 수 있습니다. 볼륨 ID 번호를 지정하는
가장 일반적인 이유는 볼륨의 VLDB 항목이 특정 이유로 인해 사라진다는 것입니다.
그러나 이전의 읽기/쓰기 볼륨 ID 번호를 알고 있으면 재사용할 수 있습니다.
</LI><LI>기존의 볼륨(보통 이전에 덤프한 볼륨)에 볼륨 데이터를 복원하고 그 내용을
덮어쓸 수 있습니다. 이것은 이전 볼륨이나 볼륨 클론 중 하나로부터 생성된
버전으로 이들 볼륨을 대체할 수 있게 하므로 현재 내용이 손상되었거나
올바르지 않을 때 편리합니다. <A HREF="#HDRWQ244">덤프 파일을 복원하고 기존 볼륨을 덮어쓰려면</A>을 참조하십시오.
<P>
<P><B>-overwrite</B> 인수를 제공하여 볼륨 내용을 변경하려고
한다는 사실을 미리 확인하고 전체 또는 점층적 덤프 중 어떤 것을 복원할지
지정하십시오. <B>-overwrite</B> 인수를 생략하면 볼륨 서버는
다음 프롬프트를 생성하여 기존의 볼륨을 전체(<B>f</B>)
또는 점층적(<B>i</B>) 덤프로 덮어쓸지 확인합니다.
<P>
<PRE>   
   Do you want to do a full/incremental restore or abort? [fia](a):
   
</PRE>
<P>
<P><B>-file</B> 인수를 사용하여 명명하는 대신 표준 출력
스트림을 통해 덤프 파일에 파이프할 경우 볼륨 서버가 프롬프트를 표시할
공간이 없으므로 <B>-overwrite</B> 인수를 포함시켜야
합니다.
<P>
<P><B>-server</B> 및 <B>-partition</B> 인수를
사용하여 새 사이트를 지정함으로써 볼륨을 전체 덤프로 덮어쓸 때 볼륨을
새 사이트로 옮길 수 있습니다. 점층적 덤프를 복원할 때는 볼륨을 이동할
필요가 없습니다.
</LI></UL>
<P><B>vos restore</B> 명령은 <B>vos examine</B> 및 <B>vos listvol</B> 명령의 출력에
포함된 <TT>Creation</TT> 필드에 보고된 것처럼 볼륨 헤더에서 복원된 볼륨의
작성 날짜를 복원 조작의 시간으로 설정합니다.
<A NAME="IDX6774"></A>
<A NAME="IDX6775"></A>
<P><H3><A NAME="HDRWQ242" HREF="auagd002.htm#ToC_262">새 볼륨으로 덤프를 복원하고 마운트하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>덤프 파일을 읽고 새 볼륨을 마운트하는 데 필요한 권한이 있는지
확인하십시오. 덤프 파일이 AFS에 있는 경우 해당 디렉토리의 ACL에 대해
<B>r</B>(<B>read</B>) 권한이 있어야 합니다.
새 볼륨을 마운트하려는 디렉토리의 ACL에 대해 <B>i</B>(<B>insert</B>) 및
<B>a</B>(<B>administer</B>) 권한이 있어야
합니다.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI>새 볼륨에 대한 사이트(파일 서버 시스템의 디스크 파티션)를
선택하십시오.
셀이 다른 유형의 볼륨을 다른 파일 서버 시스템에 그룹화하는 경우
사용자의 결정이 달라질 수 있습니다. 다른 기준을 충족하는 가장 공간이
많은 파티션에 볼륨을 추가하는 것이 타당할 것입니다. 파일 서버 시스템의
파티션에서 사용할 수 있는 공간의 양을 표시하려면 <A HREF="#HDRWQ185">읽기/쓰기 볼륨 작성</A>에서
설명하는 것처럼 <B>vos partinfo</B> 명령을 사용하십시오.
<P>
<PRE>   
   % <B>vos partinfo</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>partition&nbsp;name</VAR>>]
   
</PRE>
</LI><LI><A NAME="LIWQ243"></A><B>vos restore</B> 명령을 실행하여
새 볼륨을 작성하고 덤프 파일을 작성한 볼륨에 복원하십시오.
이 명령은 단일 행에 입력하십시오. 아래에서는 읽기 편리하도록 여러 행으로
표현한 것에 불과합니다.
<P>
<PRE>   
   % <B>vos restore</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>partition&nbsp;name</VAR>>  \
                 &lt;<VAR>name&nbsp;of&nbsp;volume&nbsp;to&nbsp;be&nbsp;restored</VAR>>   \
                 [<B>-file</B> &lt;<VAR>dump&nbsp;file</VAR>>]
[<B>-id</B> &lt;<VAR>volume&nbsp;ID</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD>허용되는 <B>restore</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>새 볼륨을 작성할 파일 서버 시스템을 명명합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>새 볼륨을 작성할 파티션을 명명합니다.
<P><DT><B><VAR>name of volume to be restored</VAR>
</B><DD>새 읽기/쓰기 볼륨을 명명합니다. 여기에는 아직 VLDB 항목이 있으면
안됩니다. 최대 22자까지 사용할 수 있습니다.
<P><DT><B>-file
</B><DD>복원할 덤프 파일입니다. 부분 경로 이름은 현재 작업 디렉토리에
상대적으로 해석됩니다. 파이프를 사용하여 표준 출력 스트림로부터 덤프 파일을
읽을 경우 이 인수를 생략하십시오.
<P><DT><B>-volume
</B><DD>새 볼륨의 ID 번호를 지정합니다. 더 이상 존재하지 않는 볼륨을
복원하려고 하거나 이미 가지고 있는 볼륨 ID 번호를 사용하려는 경우에만
이 인수를 사용하십시오.
</DL>
<A NAME="IDX6776"></A>
<A NAME="IDX6777"></A>
</LI><LI><B>fs mkmount</B> 명령을 실행하여 새 볼륨을 마우트하고
그 내용을 액세스 가능하게 하십시오. <A HREF="#HDRWQ212">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A>에 나타난
지시를 따르십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>>
   
</PRE>
</LI><LI><B>(선택적)</B> <B>fs lsmount</B> 명령을
실행하여 마운트 포인트가 올바른 볼륨을 참조하는지 확인하십시오.
<A HREF="#HDRWQ211">마운트 포인트를 표시하려면</A>에 나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>fs lsmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
</LI></OL>
<A NAME="IDX6778"></A>
<A NAME="IDX6779"></A>
<P><H3><A NAME="HDRWQ244" HREF="auagd002.htm#ToC_263">덤프 파일을 복원하고 기존 볼륨을 덮어쓰려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>덤프 파일을 읽는 데 필요한 권한이 있는지 확인하십시오. 덤프 파일이
AFS에 있는 경우 해당 디렉토리의 ACL에 대한 <B>r</B>(<B>read</B>)
권한이 있어야 합니다.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI>덤프 파일의 내용을 읽기/쓰기 볼륨에 복원하고 현재 내용을 덮어쓰십시오.
볼륨은 현재의 볼륨 ID 번호를 그대로 유지합니다.
이 명령은 단일 행에 입력하십시오. 아래에서는 읽기 편리하도록 여러 행으로
표현한 것에 불과합니다.
<P>
<PRE>   
   % <B>vos restore</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>partition&nbsp;name</VAR>>  \
                 &lt;<VAR>name&nbsp;of&nbsp;volume&nbsp;to&nbsp;be&nbsp;restored</VAR>>   \
                 [<B>-file</B> &lt;<VAR>dump &nbsp;file</VAR>>]  \
                 <B>-overwrite</B> &lt;<B>full</B> | <B>incremental</B>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD>허용되는 <B>restore</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>볼륨이 이미 존재하는 파일 서버 시스템이나 볼륨을 이동할 시스템을
명명합니다. 두 번째의 경우 <B>-overwrite</B> 인수의 값은
<B>full</B>이어야 합니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>볼륨이 이미 존재하는 파티션이나 볼륨을 이동할 파티션을
명명합니다. 두 번째의 경우 <B>-overwrite</B> 인수의 값은
<B>full</B>이어야 합니다.
<P><DT><B><VAR>name of volume to be restored</VAR>
</B><DD>덤프 파일의 내용으로 덮어쓸 읽기/쓰기 볼륨을 명명합니다.
<P><DT><B>-file
</B><DD>복원할 덤프 파일입니다. 부분 경로 이름은 현재 작업 디렉토리에
상대적으로 해석됩니다. 파이프를 사용하여 표준 출력 스트림으로부터
덤프 파일을 읽을 경우 이 인수를 생략하십시오. 이 경우
<B>-overwrite</B> 인수를 제공해야 합니다.
<P><DT><B>-overwrite
</B><DD>기존 볼륨을 덮어쓰려고 하는지 미리 확인하고 복원하는 덤프 파일의
유형을 지정합니다. 다음 값 중 하나를 제공하십시오.
<UL>
<LI>전체 덤프 파일을 복원하는 경우 <B>f</B>
또는 <B>full</B>
</LI><LI>점층적 덤프 파일을 복원하는 경우 <B>i</B> 또는
<B>incremental</B>. 이 값은 사용자가 볼륨을 복원 중인
동안 볼륨을 이동하려고 할 때는 사용할 수 없습니다.
</LI><LI>복원 조작을 종료하기 위한 <B>a</B>
</LI></UL>
</DL>
</LI><LI>볼륨이 복제되면 <B>vos release</B> 명령을 실행하여
새로 복원된 내용을 읽기 전용 사이트로 릴리스하십시오. <A HREF="#HDRWQ192">볼륨 복제(읽기 전용 볼륨 작성)</A>에
나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>vos release</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
</LI><LI><B>vos backup</B> 명령을 실행하여 볼륨의 새 백업
버전을 작성하십시오. <A HREF="#HDRWQ201">백업 볼륨 작성</A>에 나타난 지시를 따르십시오.
<P>
<PRE>   
   % <B>vos backup</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
</LI></OL>
<HR><H2><A NAME="HDRWQ245" HREF="auagd002.htm#ToC_264">볼륨 이름 변경</A></H2>
<A NAME="IDX6780"></A>
<A NAME="IDX6781"></A>
<A NAME="IDX6782"></A>
<A NAME="IDX6783"></A>
<P><B>vos rename</B> 명령을 사용하면 볼륨 이름을 변경할 수
있습니다.
예를 들어 사용자 볼륨 이름에 대해 <B>user.</B><VAR>username</VAR>
규칙을 사용하고 있으며 사용자 이름을 변경하는 경우에는 사용자의 홈 볼륨
이름을 변경하는 것이 좋습니다. (사용자 이름 변경에 대한 자세한 지침을
보려면 <A HREF="auagd018.htm#HDRWQ518">사용자 이름 변경</A>을 참조하십시오.)
<P>
<A NAME="IDX6784"></A>
<A NAME="IDX6785"></A>
<A NAME="IDX6786"></A>
<B>vos rename</B> 명령은 읽기/쓰기 볼륨 이름에만 사용할 수
있으나 연관된 읽기 전용 및 백업 볼륨의 이름도 자동으로 변경합니다.
다음에서 설명하는 것처럼 이름 변경을 반영하는 새 이름으로 볼륨의 현재
마운트 포인트를 바꾸어야 합니다.
<A NAME="IDX6787"></A>
<A NAME="IDX6788"></A>
<P><H3><A NAME="HDRWQ246" HREF="auagd002.htm#ToC_265">볼륨의 이름을 변경하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>볼륨의 마운트 포인트를 대체하고 있는 디렉토리에 대해
<B>a</B>(<B>administer</B>), <B>d</B>(<B>delete</B>)
및 <B>i</B>(<B>insert</B>) 액세스 권한이 있는지
확인하십시오.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI><LI><A NAME="LIVOL-REN"></A><B>vos rename</B> 명령을 실행하여
볼륨 이름을 변경하십시오.
<P>
<PRE>   
   % <B>vos rename</B> &lt;<VAR>old&nbsp;volume&nbsp;name</VAR>> &lt;<VAR>new&nbsp;volume&nbsp;name</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>ren
</B><DD>허용되는 <B>rename</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>old volume name</VAR>
</B><DD>읽기/쓰기 볼륨의 현재 이름입니다.
<P><DT><B><VAR>new volume name</VAR>
</B><DD>볼륨의 새 이름입니다. 22자까지 사용할 수 있습니다.
</DL>
<P>
<P>지정된 현재 볼륨에 대해 VLDB(Location Database) 항목이 있으면
명령은 다음의 오류 메시지를 나타내며 실패합니다.
<P>
<PRE>   
   vos: Could not find entry for volume <VAR>old_volume_name</VAR>. 
   
</PRE>
<A NAME="IDX6789"></A>
<A NAME="IDX6790"></A>
</LI><LI><B>fs rmmount</B> 명령을 실행하여 볼륨의 이전 이름을
참조하는 마운트 포인트를 제거하십시오. <A HREF="#HDRWQ215">마운트 포인트를 제거하려면</A>에 나타난
지시를 따르십시오.
<P>
<PRE>   
   % <B>fs rmmount</B> &lt;<VAR>directory</VAR>>
   
</PRE>
<A NAME="IDX6791"></A>
<A NAME="IDX6792"></A>
</LI><LI><B>fs mkmount</B> 명령을 실행하여 볼륨의 새 이름을
나타내는 마운트 포인트를 작성하십시오. <A HREF="#HDRWQ212">일반 또는 읽기/쓰기 마운트 포인트를 작성하려면</A>에 나타난
지시를 따르십시오.
<P>
<PRE>   
   % <B>fs mkmount</B> &lt;<VAR>directory</VAR>> &lt;<VAR>volume&nbsp;name</VAR>> [<B>-rw</B>]
    
</PRE>
</LI></OL>
<HR><H2><A NAME="HDRWQ247" HREF="auagd002.htm#ToC_266">VLDB 항목 잠금 해제 및 잠금</A></H2>
<P><A HREF="#HDRWQ227">VLDB 및 볼륨 헤더 동기화</A>에서 자세히 설명하는 것처럼 VL(Volume Location) 서버는
볼륨 서버가 볼륨에 대한 작업을 수행하기 전에 볼륨의 VLDB(Volume Location Database)
항목을 잠급니다. 잠긴 VLDB 항목이 있는 볼륨에는 어떠한 조작도 영향을
미칠 수 없으므로 이와 같은 잠금은 하나의 볼륨에 대한 여러 동시 조작으로부터
발생할 수 있는 불일치 또는 손상을 막아 줍니다.
<A NAME="IDX6793"></A>
<A NAME="IDX6794"></A>
<A NAME="IDX6795"></A>
<A NAME="IDX6796"></A>
<A NAME="IDX6797"></A>
<A NAME="IDX6798"></A>
<P>VLDB 항목이 잠겨 있는지 확인하려면 <A HREF="#HDRWQ218">VLDB 항목을 표시하려면</A>에서
설명하는 것처럼 <B>vos listvldb</B> 명령을 실행하십시오.
이 명령은 잠긴 항목만 표시하는 <B>-locked</B> 플래그를
가집니다. VLDB 항목이 잠겨 있으면 문자열 <TT>Volume is currently LOCKED</TT>가
볼륨 출력의 마지막 행에 나타납니다.
<P>VLDB 항목을 직접 잠그려면 <B>vos lock</B> 명령을 사용하십시오.
이것은 볼륨에 문제가 발생한 것으로 생각되고 문제점을 조사하는 동안
볼륨이 변경되지 않게 하려는 경우에 유용합니다.
<P>잠긴 VLDB 항목의 잠금을 해제하려면 단일 VLDB 항목의 잠금을 해제하는
<B>vos unlock</B> 명령을 실행하거나 많은 항목의 잠금을
해제할 수 있는 <B>vos unlockvldb</B> 명령을 실행하십시오.
이것은 볼륨 조작이 미리 실패하고 VLDB 항목이 잠금 상태로 남아 있을 때
유용하지만 사용자가 장애로 인해 발생한 문제를 해결할 수는 없습니다.
<A NAME="IDX6799"></A>
<A NAME="IDX6800"></A>
<P><H3><A NAME="Header_267" HREF="auagd002.htm#ToC_267">VLDB 항목을 잠그려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>vos lock</B> 명령을 실행하여 항목을 잠그십시오.
<P>
<PRE>   
   % <B>vos lock</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>lo
</B><DD>허용되는 <B>lock</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 잠글 볼륨을 식별합니다.
이것은 볼륨의 세 가지 버전 중 하나가 될 수 있습니다.
</DL>
</LI></OL>
<A NAME="IDX6801"></A>
<A NAME="IDX6802"></A>
<P><H3><A NAME="Header_268" HREF="auagd002.htm#ToC_268">단일 VLDB 항목의 잠금을 해제하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>vos unlock</B> 명령을 실행하여 항목의 잠금을
해제하십시오.
<P>
<PRE>   % <B>vos unlock</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>unlock
</B><DD>전체를 입력해야 합니다.
<P><DT><B><VAR>volume name 또는 ID</VAR>
</B><DD>완전한 이름이나 볼륨 ID 번호로 잠금을 해제할 볼륨을 식별합니다.
이것은 볼륨의 세 가지 버전 중 하나가 될 수 있습니다.
</DL>
</LI></OL>
<A NAME="IDX6803"></A>
<A NAME="IDX6804"></A>
<P><H3><A NAME="Header_269" HREF="auagd002.htm#ToC_269">복수의 VLDB 항목의 잠금을 해제하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>vos unlockvldb</B> 명령을 실행하여 원하는 항목의
잠금을 해제하십시오.
<P>
<PRE>   
   % <B>vos unlockvldb</B> [&lt;<VAR>machine&nbsp;name</VAR>>] [&lt;<VAR>partition&nbsp;name</VAR>>]
   
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>unlockv
</B><DD>허용되는 <B>unlockvldb</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>파일 서버 시스템을 지정합니다. 사이트 정의에서 시스템을 언급하는
모든 VLDB 항목의 잠금을 해제하려면 이 인수를 단독으로 제공하십시오.
이 인수와 <VAR>partition name</VAR> 인수를 모두 생략하면 모든 VLDB 항목의
잠금이 해제됩니다.
<P><DT><B><VAR>partition name</VAR>
</B><DD>파티션을 지정합니다. 사이트 정의에서 파티션을 언급하는
모든 VLDB 항목의 잠금을 해제하려면 이 인수를 단독으로 제공하십시오.
이 인수와 <VAR>machine name</VAR> 인수를 모두 생략하면 모든 VLDB 항목의
잠금이 해제됩니다.
</DL>
</LI></OL>
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd009.htm">이전 페이지</A> &#124; <A HREF="auagd011.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B> 
<!-- Begin Footer Records  ========================================== -->
<P><HR><B> 
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved 
</B> 
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
