<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    --> 
<BODY bgcolor="ffffff"> 
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<HR><H1><A NAME="HDRWQ283" HREF="auagd002.htm#ToC_320">AFS 데이터 백업 및 복원</A></H1>
<P>이 장에 있는 명령에서는 AFS 데이터를 백업 및 복원하고, 백업
데이터베이스를 관리하는 방법에 대해 설명합니다. 여기에서는 사용자가
이미 <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A>에 있는 명령을 수행하여 모든 백업 시스템
구성요소들을 구성한 것으로 가정합니다.
<HR><H2><A NAME="HDRWQ284" HREF="auagd002.htm#ToC_321">명령어 요약</A></H2>
<P>이 장에서는 표시된 명령을 사용하여 다음 타스크를 수행하는 방법에 대해
설명합니다.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">대화식 모드 전환
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup (interactive)</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">대화식 모드 종료
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>(backup) quit</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">대화식 모드에서의 작업 나열
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>(backup) jobs</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">대화식 모드에서 작업 취소
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>(backup) kill</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">테이프 조정자 시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>butc</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">테이프 조정자 정지
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%">&lt;<B>Ctrl-c</B>>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">테이프 조정자 상태 확인
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup status</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">데이터 백업
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup dump</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">덤프 레코드 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup dumpinfo</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">볼륨의 덤프 히스토리 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup volinfo</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">테이프 내용 검색
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup scantape</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">볼륨 복원
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup volrestore</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">파티션 복원
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup diskrestore</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">볼륨 그룹 복원
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup volsetrestore</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">백업 데이터베이스 통합 확인
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup dbverify</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">백업 데이터베이스에서 손상부분 복구
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup savedb</B> 및
<B>backup restoredb</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="70%">백업 데이터베이스에서 덤프 세트 삭제
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="30%"><B>backup deletedump</B>
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ286" HREF="auagd002.htm#ToC_322">백업 시스템의 인터페이스 사용</A></H2>
<A NAME="IDX6974"></A>
<P>백업 동작을 수행할 때, 3개의 백업 시스템 구성요소과 동작합니다.
<UL>
<LI><B>backup</B> 집합에서 명령을 실행하여 백업 동작을
시작합니다. <B>backup</B> 2진 파일에 액세스할 수 있는
AFS 클라이언트나 서버 시스템의 명령 쉘에서 명령을 실행(또는 쉘
스크립트에서 명령을 호출)할 수 있습니다. 일반 구성에서 2진 파일은
서버 시스템에서는 <B>/usr/afs/bin</B> 디렉토리에,
클라이언트 시스템에서는 <B>/usr/afsws/etc</B>
디렉토리에 있습니다.
<P>
<P>집합에서는 대화식 모드를 제공하며, 이 모드에서는 백업 서버 및 볼륨
위치(VL) 서버로의 영구적 연결을 통해 여러 명령을 실행할 수 있습니다.
대화식 모드에는 여러 개의 편리한 기능들이 있습니다. 자세한 설명과
명령에 대해서는 <A HREF="#HDRWQ288">대화식 및 일반 명령 모드 사용</A>의 내용을 참조하십시오.
<P>
<P>몇몇 운영 체제에는 자신의 <B>backup</B> 명령이 들어
있음을 기억하십시오. 그러한 운영 체제를 실행하여 원하는 <B>backup</B> 2진 파일에 액세스하는 지 확인하는 시스템을 구성해야 합니다.
</LI><LI>테이프 장치 또는 백업 데이터 파일과의 읽기 또는 쓰기를 호출하는
백업 동작을 수행하려면, 해당 테이프 조정자 시스템으로의 전용 연결을
개설하고 장치나 파일을 처리하는 테이프 조정자(<B>butc</B>)
프로세스를 시작해야 합니다.
<B>butc</B> 프로세스는 동작을 수행하는 동안 또는
실행할 수 있는 동안은 전용 연결을 통해 계속해서 수행해야 합니다.
자세한 설명과 그 명령에 대해서는 <A HREF="#HDRWQ291">테이프 조정자 프로세스 시작 및 정지</A>의 내용을
참조하십시오.
</LI><LI>백업 서버(<B>buserver</B>) 프로세스는 데이터베이스
서버 시스템에서 실행되어야 하며, 이는 대부분의 백업 동작시 백업
데이터베이스에 있는 정보에 액세스하거나 변경되어야 하기 때문입니다.
<I>AFS 빠른 시작</I>에서는 백업 서버를 구성하는 방법에 대해 설명합니다.
</LI></UL>
<P>영속적인 백업 시스템의 성능을 위해서는 3개 2진 파일의 AFS 작성
레벨(<B>backup</B>, <B>butc</B> 및
<B>buserver</B>)이 일치해야 합니다. 작성 레벨
명령 및 표시에 대해서는 <A HREF="auagd008.htm#HDRWQ117">2진 파일의 빌드 레벨 표시</A>의
내용을 참조하십시오.
<P><H3><A NAME="HDRWQ287" HREF="auagd002.htm#ToC_323">로컬 수퍼유저 루트로서 또는 외부 셀에서 백업 동작 수행</A></H3>
<A NAME="IDX6975"></A>
<A NAME="IDX6976"></A>
<A NAME="IDX6977"></A>
<P>기본적으로 백업 동작에 참여하는 볼륨과 백업 데이터베이스는 테이프
조정자 시스템과, <B>backup</B> 명령을 실행한
시스템 모두에 있는 <B>/usr/vice/etc/ThisCell</B>
파일에서 지정한 셀에 속하는 서버 시스템에 있어야 합니다.
또한 대부분의 <B>backup</B> 명령들을 실행하려면, 로컬
셀의 <B>/usr/afs/etc/UserList</B> 파일에 나열된 ID에
대한 AFS 토큰이 있어야 합니다(편의를 위해 셀에 있는 모든 서버
시스템에서 같음).
그러나 외부 셀에서 볼륨 또는 백업 데이터베이스에 대해 백업 동작을
수행하거나, 특권이 부여된 AFS 대신 로컬 수퍼유저 <B>root</B>로서 로그인하고 있는 동안 백업 동작을 수행할 수 있습니다.
<P>로컬 셀에서 시스템을 사용하여 외부 셀에 있는 볼륨에 대해 백업 동작을
수행하려면, 테이프 조정자와 <B>backup</B> 명령 해석기
모두에 대한 실행 셀로서 외부 셀을 지정해야 합니다. 다음 두 방법 중
하나를 사용하십시오. 어느 방법이든, 외부 셀의
<B>/usr/afs/etc/UserList</B> 파일에 나열된 관리자로서
토큰을 가지고 있어야 합니다.
<UL>
<LI><B>backup</B> 명령 및 <B>butc</B> 명령을 실행하기 전에, 명령 쉘 모두에서 AFSCELL 환경
변수를 외부 셀 이름으로 설정하십시오.
</LI><LI><B>-cell</B> 인수를 <B>butc</B> 및 모든 <B>backup</B> 명령에 삽입하십시오.
<B>backup(interactive)</B> 명령에 인수를 삽입하면,
이는 대화식 세션 동안 실행된 모든 명령에 적용됩니다.
</LI></UL>
<P>관리 AFS 토큰 없이 백업 동작을 수행하려면, 테이프 조정자 시스템과,
<B>backup</B> 명령을 실행하는 시스템 모두에서 로컬
수퍼유저 <B>root</B>로서 로그온해야 합니다.
이 시스템 모두가 서버 시스템이거나, 적어도 다른 서버 시스템에 있는
파일과 일치하는 <B>/usr/afs/etc/KeyFile</B> 파일이
있어야 합니다. 그런 다음 <B>-localauth</B> 인수를
<B>butc</B> 명령과 모든 <B>backup</B> 명령(또는 <B>backup (interactive)</B> 명령)에
삽입하십시오.
테이프 조정자와 <B>backup</B> 명령 해석기는 로컬
<B>/usr/afs/etc/KeyFile</B> 파일에서 키 버전 번호가
가장 큰 서버 암호화 키를 사용하여 서버 티켓을 생성하며, 이를 백업
서버, 볼륨 서버 및 로컬 <B>/usr/afs/etc/ThisCell</B> 파일에서 명명된 셀에 속하는 VL 서버에 제공합니다. 티켓은
만료되지 않습니다.
<P>같은 명령에서 <B>-cell</B>과 <B>-localauth</B> 옵션을 결합할 수 없습니다. 또한 각각은 AFSCELL
환경 변수나 <B>/usr/vice/etc/ThisCell</B> 파일에서
정의된 로컬 셀 설정값을 덮어쓰기합니다.
<P><H3><A NAME="HDRWQ288" HREF="auagd002.htm#ToC_324">대화식 및 일반 명령 모드 사용</A></H3>
<A NAME="IDX6978"></A>
<A NAME="IDX6979"></A>
<P><B>backup</B> 명령 집합에서는 <I>대화식 모드</I>를 제공하며, 여기에서는 백업 서버 및(VL) 서버에
대한 영속적인 연결을 통해 여러 명령을 실행할 수 있습니다.
대화식 모드에서는 다음 기능을 제공합니다.
<UL>
<LI><TT>backup></TT> 프롬프트는 일반 명령 쉘 프롬프트를 대체합니다.
</LI><LI>명령 이름에서 초기 <B>backup</B> 문자열을
삭제합니다. 동작 코드와 옵션 이름만을 입력하십시오.
</LI><LI><B>backup</B> 집합에 속하지 않는 명령은 실행할 수
없습니다.
</LI><LI>대화식 모드로 전환하면서 다른 AFS ID를 가정하거나 외부 셀을
지정하는 경우, 이것은 대화식 세션 동안 실행된 모든 명령에 적용됩니다.
<A HREF="#HDRWQ287">로컬 수퍼유저 루트로서 또는 외부 셀에서 백업 동작 수행</A>을 참조하십시오.
</LI><LI>쉘 메타문자들을 큰 따옴표로 묶을 필요는 없습니다.
</LI></UL>
<A NAME="IDX6980"></A>
<A NAME="IDX6981"></A>
<P>대화식 모드에서 백업 동작을 시작할 때, 백업 시스템은
<I>작업 ID 번호</I>를 지정합니다.
<B>(backup) jobs</B> 명령으로 현재 및 보류중인
동작들의 목록을 표시할 수 있으며, 이 명령들은
<A HREF="#HDRWQ289">대화식 모드에서 보류중이거나 실행중인 작업 표시하기</A>에 있습니다(일반 모드와 대화식 모드에서,
테이프 조정자는 <B>backup</B> 명령으로 시작한
각각의 동작에 <I>타스크 ID 번호</I>를 지정합니다.
<B>backup status</B> 명령으로 타스크 ID 버호를 추적할
수 있습니다. <A HREF="#HDRWQ291">테이프 조정자 프로세스 시작 및 정지</A>의 내용을 참조하십시오).
<P>대화식 모드에서 <B>(backup) kill</B> 명령으로 동작을
취소할 수 있으며, 이 명령은 <A HREF="#HDRWQ290">대화식 모드에서 동작 취소하기</A>에 있습니다.
그러나 덤프 동작은 인터럽트하지 않는 것이 좋으며, 이는 그 결과 발생한
덤프가 불완전할 수 있고, 복원 동작을 인터럽트하면 볼륨이 불일치
상태에 놓이거나 심지어 서버 시스템에서 이들을 완전히 제거할 수 있기
때문입니다.
자세한 설명은 <A HREF="#HDRWQ296">데이터 백업</A> 및
<A HREF="#HDRWQ306">데이터 복원 및 복구</A>의 내용을 참조하십시오.
<P><B>(backup) jobs</B> 및 <B>(backup) kill</B> 명령들은 대화식 모드에서만 사용할 수 있으며, 일반 명령
모드에서는 동일한 기능이 없습니다.
<A NAME="IDX6982"></A>
<A NAME="IDX6983"></A>
<A NAME="IDX6984"></A>
<A NAME="IDX6985"></A>
<P><H3><A NAME="Header_325" HREF="auagd002.htm#ToC_325">대화식 모드 들어가기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오. 대화식 모드에 들어가는 것
자체에 특권이 필요한 것은 아니지만, 다른 대부분의
<B>backup</B> 명령에서는 필요하며, 모드에 들어갈 때
가정하는 AFS ID는 그 모드내에서 실행하는 모든 명령에 적용됩니다.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>시스템 프롬프트에서 <B>backup (interactive)</B>
명령을 실행하십시오. <TT>backup></TT> 프롬프트가 나타납니다.
<A HREF="#HDRWQ287">로컬 수퍼유저 루트로서 또는 외부 셀에서 백업 동작 수행</A>에서 설명한 바와 같이
<B>-localauth</B>와 <B>-cell</B> 옵션 중 하나만을 포함시킬 수 있습니다.
<P>
<PRE>   %
<B>backup</B>
   backup>
</PRE>
</LI></OL>
<A NAME="IDX6986"></A>
<A NAME="IDX6987"></A>
<A NAME="IDX6988"></A>
<A NAME="IDX6989"></A>
<P><H3><A NAME="Header_326" HREF="auagd002.htm#ToC_326">대화식 모드 종료하기</A></H3>
<P><B></B>
<OL TYPE=1>
<LI><TT>backup></TT> 프롬프트에서 <B>quit</B>
명령을 실행하십시오.
명령에 성공하면 명령 쉘 프롬프트가 다시 나타나며, 보유중이거나 현재
실행중인 작업이 없을 경우에만 나타납니다. 보유중이거나 실행중인
작업을 표시하고 취소하려면, <A HREF="#HDRWQ289">대화식 모드에서 보류중이거나 실행중인 작업 표시하기</A> 및
<A HREF="#HDRWQ290">대화식 모드에서 동작 취소하기</A>에 있는 명령을 수행하십시오.
<P>
<PRE>   backup> <B>quit</B>
   %
</PRE>
</LI></OL>
<A NAME="IDX6990"></A>
<A NAME="IDX6991"></A>
<A NAME="IDX6992"></A>
<A NAME="IDX6993"></A>
<A NAME="IDX6994"></A>
<A NAME="IDX6995"></A>
<P><H3><A NAME="HDRWQ289" HREF="auagd002.htm#ToC_327">대화식 모드에서 보류중이거나 실행중인 작업 표시하기</A></H3>
<OL TYPE=1>
<LI><TT>backup></TT> 프롬프트에서 <B>jobs</B>
명령을 실행하십시오.
<P>
<PRE>   backup> <B>jobs</B>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>j
</B><DD><B>jobs</B>의 축약명입니다.
</DL>
</LI></OL>
<P>출력에는 항상 <B>backup</B> 명령 해석기가 다음
형식으로 현재의 대화식 세션동안 사용하는 토큰의 만기 날짜 및 시간이
포함됩니다.
<PRE>   <VAR>date</VAR>   <VAR>time</VAR>: TOKEN EXPIRATION
</PRE>
<P>스케줄된 덤프 동작에 대해 지정한 실행 날짜와 시간이
<I>date time</I>보다 이후이면, 각 행(다음 구문에서
설명된 바와 같이)은 이 행 바로 아래 표시되어 현재 토큰이 사용할 수
없음을 나타냅니다.
<P>대화식 모드에 들어갈 때 <B>backup</B> 명령 실행시
<B>-localauth</B> 플래그가 들어있으면, 행은 대신
다음과 같습니다.
<PRE>   :  TOKEN NEVER EXPIRES
</PRE>
<P>스케줄된 덤프 동작 항목의 형식은 다음과 같습니다.
<PRE>   Job <VAR>job_ID</VAR>:  <VAR>timestamp</VAR>:  dump  <VAR>volume_set</VAR>  <VAR>dump_level</VAR>
</PRE>
<P>여기서
<DL>
<P><DT><B><VAR>job_ID</VAR>
</B><DD>백업 시스템이 지정된 작업 ID 번호입니다.
<P><DT><B><VAR>timestamp</VAR>
</B><DD>덤프 동작이 시작되는 날짜와 시간을 나타내며, 이것의 형식은
<I>월</I>/<I>일</I>/<I>연</I> <I>시</I>:<I>분</I>(24시간
포맷)입니다.
<P><DT><B><VAR>volume_set</VAR>
</B><DD>덤프할 볼륨 세트를 나타냅니다.
<P><DT><B><VAR>dump_level</VAR>
</B><DD>덤프 동작을 수행할 덤프 레벨을 나타냅니다.
</DL>
<P>유형이 다른 보류중 또는 실행중인 동작 행의 형식은 다음과 같습니다.
<PRE>   Job <VAR>job_ID</VAR>:  <VAR>operation</VAR>  <VAR>status</VAR>
</PRE>
<P>여기서
<DL>
<P><DT><B><VAR>job_ID</VAR>
</B><DD>백업 시스템이 지정된 작업 ID 번호입니다.
<P><DT><B><VAR>operation</VAR>
</B><DD>테이프 조정자가 수행하는 동작을 나타내며, 이것은 표시된
명령으로 시작됩니다.
<P>
<DL>
<P><DT><B><TT>Dump</TT> <TT>(</TT><VAR>dump name</VAR><TT>)</TT>
</B><DD><B>backup dump</B> 명령으로 시작됩니다. <VAR>dump
name</VAR>의 형식은 다음과 같습니다.
<P>
<P><VAR>volume_set_name</VAR><B>.</B><VAR>dump_level_name</VAR>
<P><DT><B><TT>Restore</TT>
</B><DD><B>backup diskrestore</B>, <B>backup volrestore</B> 또는
<B>backup volsetrestore</B> 으로 시작됩니다.
<P><DT><B><TT>Labeltape</TT> <TT>(</TT><VAR>tape_label</VAR><TT>)</TT>
</B><DD><B>backup labeltape</B> 명령으로 시작됩니다. <VAR>tape_label</VAR>은 <B>backup labeltape</B> 명령의
<B>-name</B> 또는 <B>-pname</B>
인수에서 지정한 이름입니다.
<P><DT><B><TT>Scantape</TT>
</B><DD><B>backup scantape</B> 명령으로 시작됩니다.
<P><DT><B><TT>SaveDb</TT>
</B><DD><B>backup savedb</B> 명령으로 시작됩니다.
<P><DT><B><TT>RestoreDb</TT>
</B><DD><B>backup restoredb</B> 명령으로 시작됩니다.
</DL>
<P><DT><B><VAR>status</VAR>
</B><DD>다음 메시지 중 하나에서 작업의 현재 상태를 나타냅니다.
메시지가 표시되지 않으면, 작업은 여전히 보류중이거나 종료된
것입니다.
<P>
<DL>
<P><DT><B><VAR>number</VAR> <TT>Kbytes, volume</TT> <VAR>volume_name</VAR>
</B><DD>덤프 동작을 실행하는 경우, 이제까지 테이프나 백업 데이터 파일이
사용한 킬로바이트 수와, 현재 덤프하는 볼륨을 나타냅니다.
<P><DT><B><VAR>number</VAR> <TT>Kbytes, restore.volume</TT>
</B><DD>복원 동작을 실행하는 경우, 이제까지 테이프나 백업 데이터
파일에서 AFS로 복사한 사용한 킬로바이트 수를 나타냅니다.
<P><DT><B><TT>[abort requested]</TT>
</B><DD><B>(backup) kill</B> 명령이 실행되었지만,
종료 신호가 아직 테이프 조정자에 도달하지 않았습니다.
<P><DT><B><TT>[abort sent]</TT>
</B><DD>동작이 <B>(backup) kill</B> 명령에 의해
취소되었습니다. 일단 백업 시스템이 큐에서 동작을 제거하거나 실행을
정지시키면, 명령의 출력에 전혀 나타나지 않습니다.
<P><DT><B><TT>[butc contact lost]</TT>
</B><DD><B>backup</B> 명령 해석기는 테이프 조정자에
도달할 수 없습니다. 메시지는 동작을 처리하는 테이프 조정자가
종료되었거나, 동작을 실행하는 동안 실패했거나 또는 테이프 조정자에
대한 연결이 시간종료되었음을 의미할 수 있습니다.
<P><DT><B><TT>[done]</TT>
</B><DD>테이프 조정자가 동작을 종료했습니다.
<P><DT><B><TT>[drive wait]</TT>
</B><DD>지정된 테이프 드라이브를 사용하지 않게 될 때 까지 동작이
대기합니다.
<P><DT><B><TT>[operator wait]</TT>
</B><DD>테이프 조정자는 백업 운용자가 드라이브에 테이프를 넣기를
기다립니다.
</DL>
</DL>
<A NAME="IDX6996"></A>
<A NAME="IDX6997"></A>
<A NAME="IDX6998"></A>
<A NAME="IDX6999"></A>
<A NAME="IDX7000"></A>
<P><H3><A NAME="HDRWQ290" HREF="auagd002.htm#ToC_328">대화식 모드에서 동작 취소하기</A></H3>
<OL TYPE=1>
<LI><TT>backup></TT> 프롬프트에서 <B>jobs</B>
명령을 실행하여 취소하려는 동작의 작업 ID 번호를 알 수 있습니다.
자세한 내용은 <A HREF="#HDRWQ289">대화식 모드에서 보류중이거나 실행중인 작업 표시하기</A>를 참조하십시오.
<P>
<PRE>   backup> <B>jobs</B>
</PRE>
</LI><LI><B>(backup) kill</B> 명령을 실행하여 동작을 취소하십시오.
<P>
<PRE>   backup> <B>kill</B> &lt;<VAR>job&nbsp;ID&nbsp;or&nbsp;dump&nbsp;set&nbsp;name</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>k
</B><DD><B>kill</B>의 축약명입니다.
<P><DT><B><VAR>job ID 또는 dump set name</VAR>
</B><DD><B>jobs</B> 명령에서 처럼 취소할 동작의 작업 ID 번호나
덤프 동작의 경우는 <VAR>volume_set_name</VAR>.<VAR>dump_level_name</VAR>
형식으로 된 덤프 이름을 지정합니다.
</DL>
</LI></OL>
<P><H3><A NAME="HDRWQ291" HREF="auagd002.htm#ToC_329">테이프 조정자 프로세스 시작 및 정지</A></H3>
<A NAME="IDX7001"></A>
<P>테이프 장치 또는 백업 데이터 파일에서 읽기 또는 쓰기를 수행하는
백업 동작을 수행하려면, 드라이브나 파일을 처리하는 테이프
조정자(<B>butc</B>) 프로세스를 시작해야 합니다.
이 절에서는 테이프 조정자 테이프를 시작, 정지 및 상태를 확인하는
방법에 대해 설명합니다. 이러한 명령을 사용하려면, 이미 테이프 조정자
시스템이 구성되어 있고 <A HREF="auagd011.htm#HDRWQ261">테이프 조정자 시스템 및 테이프 장치 구성</A>에서처럼 백업
데이터베이스에서 테이프 조정자 항목을 작성했어야 합니다.
<P>
<A NAME="IDX7002"></A>
<A NAME="IDX7003"></A>
테이프 조정자는 수행하는 각 동작에 <I>타스크 ID 번호</I>를 지정합니다. 번호는 대화식 모드에서
<B>backup</B> 명령 해석기가 지정한 작업 ID 번호와
다릅니다(대화식 모드에 대해서는 <A HREF="#HDRWQ288">대화식 및 일반 명령 모드 사용</A>에서
설명함). 테이프 조정자는 화면 추적과, 그 로그 및 오류 파일을 기록하는
메시지에서 타스크 ID 번호를 보고합니다. 타스크 조정자의 실행중이거나
보류중인 동작의 타스크 ID 번호를 보려면, <B>backup status</B> 명령을 실행하십시오.
<A NAME="IDX7004"></A>
<A NAME="IDX7005"></A>
<A NAME="IDX7006"></A>
<P><H3><A NAME="HDRWQ292" HREF="auagd002.htm#ToC_330">테이프 조정자 프로세스 시작하기</A></H3>
<OL TYPE=1>
<LI>테이프 조정자가 볼륨 데이터와 백업 데이터베이스에 액세스하는
셀의 <B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
<P>
<P>또는, <A HREF="#LIWQ293">3</A> 단계에서 로컬 수퍼유저
<B>root</B>로서 파일 서버 시스템에 로그인할 수 있습니다.
</LI><LI>로컬 <B>/usr/afs/backup</B> 디렉토리에 있는
테이프 조정자의 로그 및 오류 파일로 기록할 수 있는 지
확인하십시오(<B>TE_</B><VAR>device_name</VAR> 및
<B>TL_</B><VAR>device_name</VAR> 파일). 로그 및 오류
파일이 아직 없으면, 파일을 <B>/usr/afs/backup</B> 디렉토리에 삽입하고 기록할 수 있어야 합니다.
</LI><LI><A NAME="LIWQ293"></A>테이프 장치를 구동시키거나 로컬 디스크에 백업
데이터 파일이 있는 테이프 조정자 시스템으로의 연결을
개설하십시오(<B>telnet</B> 또는
<B>rlogin</B>과 같은 명령을 사용하여).
테이프 조정자는 테이프 조정자가 요청을 받아 실행하는 동안
개설된 채로 남아 있어야 하는 연결이나 창을 사용합니다.
<P>
<P>다음 단계에서 <B>-localauth</B> 플래그를
<B>butc</B> 명령에 삽입하려면, 로컬 수퍼유저
<B>루트</B>로서 로그인하십시오.
</LI><LI><A NAME="LIWQ294"></A><B>butc</B> 명령을 실행하여 테이프
조정자를 시작하십시오. <A HREF="#HDRWQ287">로컬 수퍼유저 루트로서 또는 외부 셀에서 백업 동작 수행</A>에서 설명한 바와
같이 <B>-localauth</B>와 <B>-cell</B>
옵션 중 하나만을 포함시킬 수 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port&nbsp;offset</VAR>>]  [<B>-debuglevel</B> &lt;<VAR>trace&nbsp;level</VAR>>]  \
          [<B>-cell</B> &lt;<VAR>cellname</VAR>>] [<B>-noautoquery</B>] [<B>-localauth</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>butc
</B><DD>모두를 입력해야 합니다.
<P><DT><B><VAR>port offset</VAR>
</B><DD>테이프 조정자의 포트 오프셋 번호를 지정합니다. 기본값 <B>0</B>이 적합하지 않으면 이 인수를 제공해야 합니다.
<P><DT><B>-debuglevel
</B><DD>테이프 조정자가 표준 출력 스트림(stdout)으로 기록하는 추적
메시지의 유형을 지정합니다. 다음 3개 값 중 하나를 제공하거나, 이
인수를 생략하여 기본 유형의 메시지를
표시하십시오(<B>0</B> 값을 설정하는 것과 같음).
<UL>
<LI><B>0</B>: 테이프 조정자는 백업 운용자와 통신하는
데 필요한 최소 갯수의 메시지만을 생성하며, 여기에는 동작 오류나 시작
또는 완료를 나타내는 메시지와 추가 테이프 삽입을 위한 프롬프트도
포함됩니다.
</LI><LI><B>1</B>: 레벨 <B>0</B>에서
표시되는 메시지뿐만 아니라, 테이프 조정자는 덤프 또는 복원되는 각
볼륨의 이름도 표시합니다.
</LI><LI><B>2</B>: 레벨 <B>0</B>과
<B>1</B>에서 표시되는 메시지와 함께, 테이프 조정자는
로그 파일(<B>/usr/afs/backup/TL_</B><VAR>device_name</VAR>)로
기록하는 모든 메시지들을 표시합니다.
</LI></UL>
<P><DT><B><VAR>cellname</VAR>
</B><DD>백업 동작을 수행하는 셀의 이름입니다(관련 볼륨이 들어있고 백업
서버 프로세스가 수행중인 셀). 이 인수를 생략하면, 테이프 조정자가
로컬 <B>/usr/vice/etc/ThisCell</B> 파일에서 정의된
대로 그 홈 셀을 사용합니다. 이 인수와
<B>-localauth</B> 플래그를 함께 사용하지 마십시오.
<P><DT><B>-noautoquery
</B><DD>각 동작에 필요한 첫번째 테이프용으로 테이프 조정자의
프롬프트를 사용할 수 없도록 합니다. 이 플래그의 장점과 결과에 대한
설명은 <A HREF="auagd011.htm#HDRWQ278">초기 테이프에서 탐색 또는 프롬프트 삭제</A>의 내용을 참조하십시오.
<P><DT><B>-localauth
</B><DD>로컬 <B>/usr/afs/etc/KeyFile</B> 파일에서
키를 사용하여 서버 티켓을 생성합니다. <B>butc</B>
프로세스는 독점 인증을 수행하는 동안 백업 서버, 볼륨 서버 및 VL
서버에 제공합니다.
이 플래그를 포함시키려면 파일 서버 시스템에 로컬 수퍼유저
<B>루트</B>로서 로그인해야 하며, 이것을 <B>-cell</B> 인수와 결합시킬 수 없습니다.
</DL>
</LI></OL>
<A NAME="IDX7007"></A>
<P><H3><A NAME="Header_331" HREF="auagd002.htm#ToC_331">테이프 조정자 프로세스 정지하기</A></H3>
<OL TYPE=1>
<LI>테이프 조정자에 대한 전용 연결을 통해
&lt;<B>Ctrl-c</B>>와 같은 인터럽트 신호를 입력하십시오.
</LI></OL>
<A NAME="IDX7008"></A>
<A NAME="IDX7009"></A>
<A NAME="IDX7010"></A>
<P><H3><A NAME="HDRWQ295" HREF="auagd002.htm#ToC_332">테이프 조정자 프로세스의 상태 확인하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>backup status</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>backup status</B> [&lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>st
</B><DD><B>status</B>의 축약명입니다.
<P><DT><B><VAR>TC port offset</VAR>
</B><DD>테이프 조정자의 포트 오프셋 번호를 지정합니다. 기본값 <B>0</B>이 적합하지 않으면 이 인수를 제공해야 합니다.
</DL>
</LI></OL>
<P>다음 메시지에서는 테이프 조정자가 현재 동작을 수행하고 있지 않음을
나타냅니다.
<PRE>   Tape coordinator is idle
</PRE>
<P>그렇지 않으면 출력에는 실행중인 동작 또는 보류중인 동작에 대한 다음
형식의 메시지가 포함됩니다.
<PRE>   Task <VAR>task_ID</VAR>:  <VAR>operation</VAR>:   <VAR>status</VAR>
</PRE>
<P>여기서
<DL>
<P><DT><B><VAR>task_ID</VAR>
</B><DD>테이프 조정자가 지정한 타스크 ID 번호입니다. 이것은
테이프 조정자의 포트 오프셋 번호로 시작됩니다.
<P><DT><B><VAR>operation</VAR>
</B><DD>테이프 조정자가 수행하는 동작을 나타내며, 이것은 표시된 명령으로
시작됩니다.
<UL>
<LI><TT>Dump</TT> (<B>backup dump</B> 명령)
</LI><LI><TT>Restore</TT> (<B>backup diskrestore</B>,
<B>backup volrestore</B> 또는 <B>backup
volsetrestore</B> 명령)
</LI><LI><TT>Labeltape</TT> (<B>backup labeltape</B> 명령)
</LI><LI><TT>Scantape</TT> (<B>backup scantape</B> 명령)
</LI><LI><TT>SaveDb</TT> (<B>backup savedb</B> 명령)
</LI><LI><TT>RestoreDb</TT> (<B>backup restoredb</B> 명령)
</LI></UL>
<P><DT><B><VAR>status</VAR>
</B><DD>작업의 현재 상태가 다음 메시지 중 하나임을 나타냅니다.
<P>
<DL>
<P><DT><B><VAR>number</VAR> <TT>Kbytes transferred, volume</TT> <VAR>volume_name</VAR>
</B><DD>덤프 동작을 실행하는 경우, 이제까지 테이프나 백업 데이터 파일이
복사한 킬로바이트 수와, 현재 덤프하는 볼륨을 나타냅니다.
<P><DT><B><VAR>number</VAR> <TT>Kbytes, restore.volume</TT>
</B><DD>복원 동작을 실행하는 경우, 이제까지 테이프나 백업 데이터
파일에서 AFS로 복사한 사용한 킬로바이트 수를 나타냅니다.
<P><DT><B><TT>[abort requested]</TT>
</B><DD><B>(backup) kill</B> 명령이 실행되었지만,
종료 신호가 아직 테이프 조정자에 도달하지 않았습니다.
<P><DT><B><TT>[abort sent]</TT>
</B><DD>동작이 <B>(backup) kill</B> 명령에 의해
취소되었습니다. 일단 백업 시스템이 큐에서 동작을 제거하거나 실행을
정지시키면, 명령의 출력에 전혀 나타나지 않습니다.
<P><DT><B><TT>[butc contact lost]</TT>
</B><DD><B>backup</B> 명령 해석기는 테이프 조정자에
도달할 수 없습니다. 메시지는 동작을 처리하는 테이프 조정자가
종료되었거나, 동작을 실행하는 동안 실패했거나 또는 테이프 조정자에
대한 연결이 시간종료되었음을 의미할 수 있습니다.
<P><DT><B><TT>[done]</TT>
</B><DD>테이프 조정자가 동작을 종료했습니다.
<P><DT><B><TT>[drive wait]</TT>
</B><DD>지정된 테이프 드라이브를 사용하지 않게 될 때 까지 동작이
대기합니다.
<P><DT><B><TT>[operator wait]</TT>
</B><DD>테이프 조정자는 백업 운용자가 드라이브에 테이프를 넣기를
기다립니다.
</DL>
</DL>
<HR><H2><A NAME="HDRWQ296" HREF="auagd002.htm#ToC_333">데이터 백업</A></H2>
<A NAME="IDX7011"></A>
<A NAME="IDX7012"></A>
<A NAME="IDX7013"></A>
<A NAME="IDX7014"></A>
<A NAME="IDX7015"></A>
<A NAME="IDX7016"></A>
<A NAME="IDX7017"></A>
<A NAME="IDX7018"></A>
<A NAME="IDX7019"></A>
<A NAME="IDX7020"></A>
<A NAME="IDX7021"></A>
<A NAME="IDX7022"></A>
<P>이 절에서는 <B>backup dump</B> 명령을 사용하여 AFS
데이터를 테이프나 백업 데이터 파일로 백업하는 방법에 대해 설명합니다.
명령에서는 사용자가 백업 시스템의 개념에 대해 이해하고 있고 이미
<A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A>에 있는 명령에 따라 백업 시스템을 구성한
것으로 가정합니다.
특히 다음을 수행했어야 합니다.
<UL>
<LI>데이터를 테이프로 덤프할 것인 지 또는 백업 데이터 파일로 덤프할
것인 지 여부 결정과, 테이프 조정자 시스템과 테이프 조정자
프로세스 구성. <A HREF="auagd011.htm#HDRWQ261">테이프 조정자 시스템 및 테이프 장치 구성</A> 및
<A HREF="auagd011.htm#HDRWQ282">백업 데이터 파일로 데이터 덤프</A>의 내용 참조.
</LI><LI>함께 덤프하려는 볼륨이 들어있는 볼륨 정의.
<A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>를 참조하십시오.
</LI><LI>볼륨 세트를 덤프하려는 덤프 계층에서 덤프 레벨 정의. 증분 덤프
레벨인 경우, 상위 레벨에서 이전에 덤프를 작성했어야 합니다.
<A HREF="auagd011.htm#HDRWQ267">덤프 계층 정의 및 표시</A>를 참조하십시오.
</LI><LI>장치 구성 파일 작성. 그러한 파일은 테이프 스태커, 주크 박스 장치
또는 백업 데이터 파일에 필요합니다. 또한 이를 사용하여 백업 시스템의
자동화 기능을 구성할 수도 있습니다. <A HREF="auagd011.htm#HDRWQ275">백업 프로세스 자동화 및 효율성 증대</A>를 참조하십시오.
</LI></UL>
<P>덤프 동작을 수행하는 가장 기본적인 방법은 해당 테이프 조정자를 사용할
수 있게 되면 단일 볼륨 세트의 초기 덤프를 작성하는 것이며, 이 때
필요한 인수만을 <B>backup dump</B> 명령에 제공합니다.
명령어는 <A HREF="#HDRWQ301">덤프 작성하기</A>에 있습니다.
명령에는 여러가지 선택적인 인수들이 있으며, 사용자들은 이를 사용하여
백업 프로시듀어의 효율성과 유연성을 증대시킬 수 있습니다.
<UL>
<LI>이미 다른 덤프가 들어있는 테이프 세트 끝에 덤프를 첨부하려면,
<B>-append</B> 인수를 삽입하십시오. 그렇지 않으면,
백업 시스템이 초기 덤프를 작성합니다. 덤프를 추가하면 사용자의 전체
용량을 사용할 수 있고 다른 유용한 기능들을 사용할 수 있게 됩니다.
자세한 설명은 <A HREF="#HDRWQ299">기존 덤프 세트로 덤프 추가</A>의 내용을 참조하십시오.
</LI><LI>앞으로 실행할 하나 이상의 덤프 동작을 스케줄하려면,
<B>-at</B> 인수를 삽입하십시오. 자세한 설명과 명령에
대해서는 <A HREF="#HDRWQ300">덤프 스케줄</A>의 내용을 참조하십시오.
</LI><LI>하나의 <B>backup dump</B> 명령으로 덤프 동작들을
시작하려면, <B>-file</B> 인수를 포함시켜 명령을
나열한 파일의 이름을 지정하십시오. 설명과 명령에 대해서는
<A HREF="#HDRWQ299">기존 덤프 세트로 덤프 추가</A> 및 <A HREF="#HDRWQ300">덤프 스케줄</A>의 내용을 참조하십시오.
</LI><LI>실제로 볼륨들을 덤프하지 않고 덤프에 포함시킬 볼륨 목록을
생성하려면, 실제 명령에 사용할 다른 인수와 <B>-n</B>
플래그를 결합하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ297" HREF="auagd002.htm#ToC_334">백업 동작을 보다 효과적으로 작성하기</A></H3>
<A NAME="IDX7023"></A>
<P>덤프 동작을 보다 효과적이고, 오류 가능성을 줄이며, 사용자에게 좀 더
유용하게 만드는 여러 방법이 있습니다. 이들 중 몇몇은 필요한 경우
데이터 복원 프로세스를 단순화시킵니다.
<UL>
<LI>읽기/쓰기 또는 읽기 전용 버전의 볼륨들을 덤프하지 않는 것이
좋습니다. 이는 다른 사용자나 프로세스가 덤프되는 동안 볼륨에 액세스할
수 있기 때문입니다. 대신, 덤프 동작이 시작되기 바로 전에 덤프할 각
볼륨의 백업 버전을 작성하고 백업 버전을 덤프하십시오. 백업 버전을
작성하면 잠시 동안 소스 볼륨을 사용할 수 없게 됩니다(다른 프로세스의
액세스 시도는 봉쇄되지만 실패하지 않는 동안).
백업 볼륨 작성을 자동화하기 위해, 하나 이상의 서버 시스템에 있는
<B>/usr/afs/local/BosConfig</B> 파일에서 <B>cron</B> 프로세스를 작성할 수 있으며, 덤프 동작이 시작되기 전에
충분한 간격으로 그 시작 시간을 설정합니다.
<B>-localauth</B> 인수를 <B>vos
backup</B> 또는 <B>vos backupsys</B> 명령에 포함시켜
관리 토큰없이 이를 수행할 수 있도록 합니다.
명령에 대해서는 <A HREF="auagd009.htm#HDRWQ162">새 프로세스를 작성 및 시작하려면</A>의 내용을 참조하십시오.
</LI><LI><B>backup dump</B> 명령 행에서 사용자가 지정한
볼륨 세트, 덤프 레벨 및 테이프 조정자 포트 오프셋은 백업
데이터베이스에서 제대로 정의되어야 합니다. 백업 시스템은 덤프 동작을
시작하기 전에 데이터베이스를 확인하고, 필요한 엔티티가 누락되어
있으면 즉시 명령을 중단합니다. 필요하면 표시된 명령을 사용하십시오.
<UL>
<LI>볼륨 세트를 표시하려면, <A HREF="auagd011.htm#HDRWQ266">볼륨 세트 및 볼륨 항목 표시하기</A>에서
설명된 것처럼 <B>backup listvolsets</B> 명령을
사용하십시오.
</LI><LI>덤프 레벨을 표시하려면, <A HREF="auagd011.htm#HDRWQ271">덤프 계층 표시하기</A>에서 설명한
것처럼 <B>backup listdumps</B> 명령을 사용하십시오.
</LI><LI>포트 오프셋을 표시하려면, <A HREF="auagd011.htm#HDRWQ264">구성된 테이프 조정자 목록 표시하기</A>에서
설명한 것처럼 <B>backup listhosts</B> 명령을 사용하십시오.
</LI></UL>
</LI><LI>특권이 부여된 관리 ID에 해당하는 유효한 토큰을 <B>backup dump</B> 명령이 실행될 때와 덤프 동작이 실제로 수행될 때
모두 백업 시스템에서 사용할 수 있어야 합니다(필요한 특권에 대한
완전한 설명은 <A HREF="auagd011.htm#HDRWQ260">백업 수행자에게 관리 특권 부여</A>의 내용을 참조하십시오).
이것은 스케줄된 덤프에 대한 특별한 사항입니다. 한가지 대안은
<B>backup</B> 명령(또는 이들을 호출하는 스크립트)과
<B>butc</B> 명령을 서버 시스템에서 실행하고,
<B>-localauth</B> 인수를 명령에 삽입하는 것입니다.
이런 경우, 프로세스는 로컬 <B>/usr/afs/etc/KeyFile</B>
파일에서 키 버전 번호가 가장 높은 키를 사용하여 결코 만료되지 않는
토큰을 생성합니다. 그렇지 않으면, 만기되기 전에 토큰을 갱신하는
방법을 사용하거나 토큰에 긴 활동기간을 부여하는 방법을 사용해야
합니다. 어느 경우이든, 물리적으로 시스템을 보호하여 토큰에 잘못
액세스하지 않도록 그리고 허가없이 네트워크에 액세스하지 않도록
보호해야 합니다. 보호는 동작 도중 운용자가 있을 때보다 더 강력해야
합니다.
</LI><LI>테이프 조정자의 <B>/usr/afs/backup/tapeconfig</B> 파일과 테이프 레이블에 가능한 정확한 테이프 용량과 파일표시
크기값을 기록합니다. 정확하지 않을 경우 발생할 수 있는 내용에
관한 제안값과 설명에 대해서는 <A HREF="auagd011.htm#HDRWQ258">tapeconfig 파일 구성</A>의
내용을 참조하십시오.
</LI><LI>무인 덤프에 여러 테이프가 필요하면, 테이프 스태커나 주크 박스를
정확하게 구성하고 호출할 테이프 마운트 스크립트를 장치의
<B>CFG_</B><VAR>device_name</VAR> 파일에 기록하여 이
테이프들을 정렬하여 제공하십시오. 명령에 대해서는 <A HREF="auagd011.htm#HDRWQ277">장치의 테이프 마운트 및 마운트해제 루틴 호출</A>의 내용을 참조하십시오.
</LI><LI>백업 시스템의 자동화 기능을 사용하도록 테이프 장치나 백업 데이터
파일의 <B>CFG_</B><VAR>device_name</VAR> 파일을
구성할 수 있습니다. <A HREF="auagd011.htm#HDRWQ275">백업 프로세스 자동화 및 효율성 증대</A>를 참조하십시오.
</LI><LI>일반(비대화식) 모드에서 <B>backup</B> 명령을
실행할 때, 명령 쉘 프롬프트는 동작이 완료할 때 까지 리턴하지 않습니다.
추가로 연결을 개설하지 않도록 하려면, 대화식 모드에서
<B>backup dump</B> 명령을 실행하십시오. 특히 덤프
스케줄 동작에 <B>-at</B> 인수를 삽입하는 경우.
</LI><LI>증분 덤프는 사용하는 레벨 바로 위에 있는 덤프 레벨에서 덤프가
작성될 경우 가장 매끄럽게 진행됩니다. 백업 시스템이 바로 상위
레벨에서 작성된 덤프에 대한 백업 데이터베이스 레코드를 발견하지
못하면, 계층에서 한 계층 위에서 작성된 덤프를 찾고, 필요하면 전체
덤프 레벨까지 계속됩니다. 발견한 최하위 유효 상위 덤프보다 1레벨
아래에서 증분 덤프를 작성하거나, 필요하면 전체 덤프라도 작성합니다.
이 알고리즘을 사용하면 덤프가 마지막 덤프 이후 변경된 모든 데이터들을
캡처하지만 두 가지 단점이 있습니다. 첫째, 백업 시스템이 유효한 상위
덤프를 데이터베이스에서 탐색하려면 여분의 시간이 소요됩니다. 둘째,
이후 덤프 패턴은 덤프가 예상된 덤프 레벨에서 수행되지 않았으므로
데이터를 복원해야 하는 운용자에게 혼동을 줄 수 있습니다.
<P>
<P>바로 상위 레벨에 덤프가 존재하도록 하는 가장 쉬운 방법은 미리 정의된
스케줄대로 항상 덤프 동작을 수행하는 것입니다. 상위 덤프가 있는 지
체크하기 위해 <B>backup dumpinfo</B> 명령(<A HREF="#HDRWQ303">덤프 레코드 표시하기</A>에서 설명한 바와 같이)을
실행하고 출력에서 이를 탐색할 수 있습니다. 또는 상위 덤프에 있는
것으로 알고있는 볼륨에 대해 <B>backup volinfo</B> 명령(<A HREF="#HDRWQ304">볼륨의 덤프 히스토리 표시하기</A>에서 설명한 바와 같이)을
실행하십시오.
</LI><LI>제공된 덤프 세트를 덤프할 때와 같은 계층(같은 전체 레벨의
하위)에서 항상 덤프 레벨을 사용하십시오. 다른 계층에 있는 레벨
사이를 변경하면 데이터를 복원해야 하거나 덤프 레코드를 읽어야 할
경우 혼동될 수 있습니다. 또한 변경된 데이터가 임의 덤프에서 캡처되지
않거나, 하나 이상의 덤프로 과다하게 백업될 수 있습니다.
</LI><LI>AFS 테이프 이름 대신 영구적 테이프 이름을 사용하십시오. AFS
테이프 이름의 고정된 포맷에서 허용된 것보다 좀 더 설명적으로
영구적 이름을 작성할 수 있으며, 테이프에 AFS 테이프 이름만 있는
경우 기본적으로 백업 시스템이 수행하는 이름 체크 단계를 통과할 수도
있습니다. 테이프 조정자가 항상 체크를 통과하도록 구성할 수 있습니다.
AFS 테이프 이름에 대해 사용할 수 있는 포맷 설명과 명령에 대해서는
<A HREF="auagd011.htm#HDRWQ280">AFS 테이프 이름 체크 삭제</A>의 내용을 참조하십시오.
</LI><LI>덤프를 테이프로 기록하는 경우, 모든 테이프 장치가 호환될 수
있으면(압축 비율도 같고, 같은 유형의 테이프를 읽을 수 있음) 복원
동작이 가장 간단합니다. 호환되지 않는 장치를 사용해야 하는 경우,
적어도 각 계층에서 같은 위치의 덤프 레벨에서 수행된 모든
덤프들 끼리는 호환되는 장치를 사용하십시오(전체 덤프 레벨에서 수행된
모든 덤프에 대한 호환가능한 장치, 레벨 1 증가된 덤프 레벨에서 수행된
모든 덤프에 대한 호환가능한 장치 등등). <B>backup diskrestore</B>
및 <B>backup volsetrestore</B> 명령에서
<B>-portoffset</B> 인수를 사용하면 여러 포트 오프셋
번호들을 사용할 수 있지만, 전체 덤프 모두를 복원할 때는 첫번째 나열된
포트 오프셋을 사용하고, 레벨 1 덤프 모두를 복원할 경우는 두 번째 포트
오프셋, 이런 순서로 사용합니다.
계층에서 동일 깊이에서 덤프를 작성할 때 호환되는 테이프 장치들을
사용하지 않았으면, <B>backup volrestore</B> 명령을
사용하여 한번에 하나의 볼륨을 복원해야 합니다.
</LI><LI>어떤 경우, 작성된 대화식 세션의 구문내에만 존재하는
<I>임시</I> 볼륨 세트를 사용할 수 있으며, 이는
백업 데이터베이스에서 작성된 레코드가 없기 때문입니다.
볼륨을 영구적으로 제거하기 위해 테이프로 덤프할 경우가 그런
경우입니다(소유자가 셀을 제거하려 하므로). 이런 경우, 한번만
사용하는 볼륨 세트 레코드로 백업 데이터베이스를 채우지 않고도 관심있는
볼륨만 들어있는 볼륨 항목을 정의할 수 있습니다.
</LI><LI>백업 시스템이 볼륨 또는 VLDB(Location Database)에
액세스하지 못하도록 할 수 있는 네트워크, 시스템 또는 서버 프로세스
문제점이 있음을 알게 되면 덤프 동작을 수행하지 마십시오. 백업
시스템이 액세스할 수 없는 볼륨에 액세스하기 위해 자동으로 반복
시도하는 경우라도, 덤프 동작에는 기타 시간에 소요되고 어떤 경우는
계속하는 방법에 대한 지시를 받기 위해 완전히 정지하는 경우도
있습니다. 뿐만 아니라 백업 시스템의 최종 액세스 시도가 실패하고
볼륨이 덤프에서 삭제되면, 이를 백업하는 데 또 다른 과정을 수행해야
합니다(즉, 방금 설명한 과정은 정지된 덤프 동작 다음에 옵니다).
백업 시스템이 액세스 시도를 반복하는 방법에 대한 자세한 설명은
<A HREF="#HDRWQ298">덤프 프로세스에 대한 구성 선택사항의 영향</A>의 내용을 참조하십시오.
</LI><LI>덤프 동작이 완료되면 즉시 백업 시스템이 작성한 로그를
검토하십시오. 특히 무인으로 수행되는 경우, 다른 문제점들 가운데
백업에 실패한 볼륨의 이름을 지정합니다. 백업 서버는 데이터베이스
서버 시스템의 로컬 디스크에 있는 <B>/usr/afs/logs/BackupLog</B>
파일로 기록하고, <B>bos getlog</B> 명령을 사용하여
원하는 이를 원격으로 읽을 수도 있습니다. 그 명령에 대해서는
<A HREF="auagd009.htm#HDRWQ173">서버 프로세스 로그 파일 표시</A>의 내용을 참조하십시오. 테이프
조정자는 수행중인 시스템이 있는 로컬
<B>/usr/afs/backup</B> 디렉토리의 두 파일로
기록합니다. <B>TE_</B><VAR>device_name</VAR> 파일은 오류를 기록하고, <B>TL_</B><VAR>device_name</VAR> 파일은 추적과 오류 메시지 모두를 기록합니다.
</LI><LI>덤프 동작이 정지되지 않도록 합니다(예를 들어 대화식 모드에서
<B>(backup) kill</B> 명령을 실행하여), 이는 혼동할
가능성을 보여주기 때문이고, 인터럽트에서 복구하려면 또 다른 노력이
필요하기 때문입니다. 덤프 동작이 인터럽트되면, 정지 신호를 받기 전에
백업된 볼륨들이 테이프나 백업 데이터 파일에서 완료되고 복구 동작에
사용할 수 있게 됩니다. 백업 데이터베이스에서 볼륨의 덤프 히스토리에
대한 레코드는 백업된 덤프 레벨과 그 시기를 정확하게 표시합니다.
레코드를 표시하려면 <A HREF="#HDRWQ304">볼륨의 덤프 히스토리 표시하기</A>에서 처럼
<B>backup volinfo</B> 명령을 사용하십시오.
<P>
<P>그러나, 덤프의 백업 데이터베이스 레코드에서는 볼륨이 누락되었음을
나타내는 표시가 없으므로, <A HREF="#HDRWQ303">덤프 레코드 표시하기</A>에서 처럼
<B>backup dumpinfo</B> 명령을 사용하십시오.
덤프 동작이 정지되기 전에 백업되지 않은 볼륨에 대해 처리하려면 다음
방법 중 하나를 선택해야 합니다(실제로, 제어불능으로 인해 덤프 동작이
정지되면 같은 결정을 해야 합니다).
<UL>
<LI>아무런 동작도 수행할 수 없습니다. 다음 정규 스케줄된 덤프 동작이
볼륨을 백업할 때 까지 기다립니다. 이 때, 백업 시스템은 해당 레벨에서
자동으로 덤프하여 볼륨이 마지막으로 덤프된 이후 변경된 모든
데이터들을 덤프에서 캡처하도록 합니다. 그러나,
다음 덤프 동작 이전에 볼륨을 복원하지 않도록 하는 것은 위험할 수 있습니다.
복원이 필요하면, 마지막으로 볼륨을 덤프에 포함시켰던 상태로만 볼륨을
복원할 수 있습니다. 이 때 이후 볼륨의 모든 변경사항들은 잃게 됩니다.
</LI><LI>전체 덤프를 버리고 덤프 동작을 다시 실행할 수 있습니다. 덤프를
버리려면, <B>backup labeltape</B> 명령을 사용하여
테이프나 백업 데이터 파일에 레이블을 다시 시작하십시오. 이것은
백업 데이터베이스에서 연관된 모든 레코드들을 자동으로 제거합니다.
명령에 대해서는 <A HREF="auagd011.htm#HDRWQ272">테이프 레이블 기록 및 읽기</A>의 내용을 참조하십시오.
백업 버전의 볼륨이 작성된 이후 오랜 시간이 지난 경우, 소스 볼륨 중
일부는 변경될 수 있습니다. 그런 경우, 덤프 동작을 다시 수행하기 전에
이에 대해 <B>vos backup</B> 또는 <B>vos
backupsys</B> 명령을 다시 실행하십시오.
</LI><LI>누락된 볼륨이 들어있는 새로운 볼륨을 작성하고 이를 전체 덤프
레벨에서 덤프할 수 있습니다(증분 덤프 레벨을 지정하더라도, 백업
시스템은 사용자가 지정한 레벨의 맨 위 계층에서 전체 덤프 레벨을
사용합니다. 이는 새로운 볼륨 세트의 일부로서 이들 볼륨을 백업하기
전에는 아무 것도 없기 때문입니다). 다음 번에 원래 볼륨 세트를 덤프할
때, 백업 시스템은 원래 백업 세트의 일부로서 볼륨을 마지막 덤프할 때
사용되었던 레벨 바로 아래에서 누락된 볼륨을 자동으로 덤프합니다.
</LI></UL>
</LI></UL>
<P><H3><A NAME="HDRWQ298" HREF="auagd002.htm#ToC_335">덤프 프로세스에 대한 구성 선택사항의 영향</A></H3>
<A NAME="IDX7024"></A>
<P>이 절에서는 백업 프로세스에 대한 개요를 제공하며, 기본값으로 그리고
구성 선택사항의 결과로서 각 단계에서 발생한 내용에 대해 설명합니다.
여기에는 장치 고유 <B>CFG_</B><VAR>device_name</VAR>
파일에 들어있는 구성 명령문도 포함됩니다. 투명성을 위해, 초기 덤프를
작성한 단일 <B>backup dump</B> 명령의 진행사항을
추적합니다. 덤프 추가 또는 스케줄시 프로시듀어에 있어서 약간의
차이점에 대해서는 <A HREF="#HDRWQ299">기존 덤프 세트로 덤프 추가</A> 또는
<A HREF="#HDRWQ300">덤프 스케줄</A>의 내용을 참조하십시오.
<P>구체적인 예제로서, 다음 설명에서는 <B>/weekly/mon/tues/wed</B> 덤프 레벨에서 볼륨 세트 <B>user</B>의 덤프를
추적합니다.
<B>user</B> 볼륨 세트에는 모든 사용자 볼륨의 백업
버전에 대응되는 하나의 볼륨 항목이 있습니다.
<PRE>   <B>.*    .*    user.*\.backup</B>
</PRE>
<P>덤프 레벨은 다음 덤프 계층에 속합니다.
<PRE>   /weekly
          /mon
              /tues
                   /wed
                       /thurs
                             /fri
</PRE>
<OL TYPE=1>
<LI><A NAME="LIBKOV-BUTC"></A><B>butc</B> 명령을 실행하여
테이프 조정자가 덤프 동작의 처리를 시작합니다. 테이프 조정자는
<B>backup dump</B> 명령을 실행할 때 실행되지 않아도
되지만, <A HREF="#LIBKOV-VOLMATCHES">3</A>가 완료되어 덤프에 포함시킬
덤프 목록을 승인할 때에는 활동하고 있어야 합니다. 조정 문제점을
예방하려면, <B>backup dump</B> 명령을 실행하기 전에
테이프 조정자를 시작하는 것이 가장 좋습니다.
<P>
<P>테이프 조정자가 시작되면, <B>butc</B> 명령행에서 지정한
포트 오프셋 항목을 로컬 <B>/usr/afs/backup/tapeconfig</B> 파일에서 읽습니다.
항목에서는 사용할 장치명을 지정하고, 테이프 조정자는 이에 액세스할 수
있는 지 확인합니다. 또한 장치의 구성 파일
<B>/usr/afs/backup/CFG_</B><VAR>device_name</VAR>이
있으면 그 파일도 읽습니다. 파일에 있는 명령어가 덤프 동작에 미치는
영향에 대해서는 <A HREF="#LIBKOV-READCFG">6</A> 단계를 참조하십시오.
</LI><LI><B>backup dump</B> 명령을 실행하여, 볼륨 세트,
덤프 레벨 및 <A HREF="#LIBKOV-BUTC">1</A> 단계에서
<B>butc</B> 명령에 대해 지정했던 것과 같은 포트
오프셋을 지정합니다.
백업 시스템은 정확한 백업 데이터베이스 레코드가 있는 지 확인하고,
없으면 오류 메시지로 동작을 정지시킵니다.
<P>
<P>대화식 모드에서 명령을 실행하는 경우, 백업 시스템은 동작에 작업
ID 번호를 지정하며, 이 작업 ID 번호를 사용하여 동작의 상태를
체크하거나 <B>(backup) jobs</B> 또는
<B>(backup) kill</B> 명령 각각을 사용하여 이를 정지할
수 있습니다. 그 명령에 대해서는 <A HREF="#HDRWQ289">대화식 모드에서 보류중이거나 실행중인 작업 표시하기</A> 및
<A HREF="#HDRWQ290">대화식 모드에서 동작 취소하기</A>의 내용을 참조하십시오.
</LI><LI><A NAME="LIBKOV-VOLMATCHES"></A>백업 시스템은 VL 서버에 대해 작업하여, 볼륨
세트의 볼륨 항목에서 정의된 이름 및 위치 범주에 대응되는 볼륨 목록을
VLDB에서 생성합니다. 볼륨이 하나 이상의 볼륨 항목에 대응되면, 백업
시스템은 덤프에 볼륨의 데이터 사본 하나만이 포함될 수 있도록
복제본들은 무시합니다.
<P>
<P>복원 동작중 테이프 교환 횟수를 줄이기 위해, 백업 시스템은 서버
시스템과 파티션별로 볼륨을 정렬하고, 덤프 동작중에는 다음 파티션으로
이동되기 전에 특정 파티션에 저장된 모든 볼륨 데이터들을 기록합니다.
<P>
<P>앞에서 설명한 바와 같이, 볼륨을 읽기/쓰기하는 대신 백업하여 덤프 도중
사용자가 데이터에 액세스할 수 있도록 하는 것이 좋습니다. 이를
위해서는, 볼륨 항목 정의에 있는 볼륨명에
<B>.backup</B> 접미어를 명시적으로 삽입해야 합니다.
명령과, 다중 볼륨에 대응하는 볼륨 항목 정의법에 대해서는
<A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>의 내용을 참조하십시오.
<P>
<P>예에서, 50개의 볼륨이 <B>user</B> 볼륨 세트 기준에
맞고, 여기에는 <B>user.pat.backup</B>, <B>user.terry.backup</B> 및 <B>user.smith.backup</B>이
포함되는 것으로 가정합니다.
</LI><LI><A NAME="LIBKOV-CLONEDATE"></A>그런 다음 백업 시스템은 <B>backup dump</B>
명령행에서 지정했던 덤프 레벨을 덤프 계층에서 검색합니다. 전체 레벨인
경우, 현재 동작에서 백업 시스템은 <A HREF="#LIBKOV-VOLMATCHES">3</A>
단계에서 확보한 목록의 모든 볼륨에 있는 데이터 전체를 백업합니다.
<P>
<P>덤프 레벨이 증분 레벨인 경우, 백업 시스템은 백업 데이터베이스에서
각 볼륨의 덤프 히스토리를 읽고 가장 최근에 이 볼륨 세트의 일부로서
볼륨이 백업될 때 사용되었던 경로이름에 있는 상위 레벨을 알게 됩니다.
보통의 경우, 현재 덤프 레벨의 바로 위 상위 레벨입니다.
<P>
<P>볼륨의 증분 덤프에는 볼륨이 상위 덤프내에 포함되었던 이후 변경된
데이터만이 포함됩니다. 포함될 수 있는 데이터를 결정하기 위해, 백업
시스템은 볼륨의 <I>클론 날짜</I> 개념을 사용합니다.
읽기/쓰기 볼륨의 클론 날짜는 백업 시스템이 볼륨의 내용을 덤프에
복사하기 전에 볼륨을 잠금시킵니다. 백업 볼륨의 클론 날짜는 읽기/쓰기
소스 볼륨을 복제하여 작성했던 동작 완료 시간입니다(<B>vos backup</B>
또는 <B>vos backupsys</B> 명령으로 시작했던 동작).
읽기 전용 볼륨의 클론 날짜는 덤프 동작 이전에 가장 최근에 완료했던
릴리즈 동작 시간(<B>vos release</B> 명령으로 시작됨)입니다.
<P>
<P>좀 더 정확하게 증분 덤프에는 상위 덤프에 포함된 볼륨의 클론
날짜(<I>상위 클론 날짜</I>)와 현재 덤프에 포함될 볼륨
날짜(<I>현재 클론 날짜</I>) 사이에서 시간소인이
수정되었던 데이터만이 포함됩니다.
<P>
<P>볼륨의 상위 덤프는 바로 상위 레벨에서 작성된 덤프라는 일반 규칙에도
예외는 있습니다.
<UL>
<LI>마지막 덤프시 볼륨이 없었습니다. 이런 경우, 백업 시스템은
자동으로 전체 덤프를 수행합니다.
</LI><LI>볼륨이 마지막 덤프시 볼륨 세트의 이름 및 위치 기준에 맞지
않습니다. 이런 경우, 백업 시스템은 최근 백업(전체 또는 증분)한
경우라도 다른 볼륨 세트의 일부로서 전체 덤프를 자동으로 수행합니다.
이것은 특히 볼륨을 자주 이동하는 경우 위치 대신 이름으로 볼륨 항목을
정의하는 인수입니다.
</LI><LI>볼륨이 몇몇 이유로 바로 상위 레벨에 있는 덤프에 포함되지
않았습니다(아마도 프로세스, 시스템 또는 네트워크 액세스가 백업
시스템이 이에 액세스하지 못하도록 함). 이런 경우, 백업 시스템은
볼륨에 포함된 마지막 덤프 동작 시간으로 클론 날짜를 설정합니다.
볼륨이 현재 레벨의 경로이름에 있는 레벨에서 수행된 덤프에 포함되지
않았으면, 백업 시스템은 전체 덤프를 수행합니다.
</LI></UL>
<P>
<P>예에서, 현재 덤프 레벨은 <B>/weekly/mon/tues/wed</B>입니다. <B>user.pat.backup</B> 및 <B>user.terry.backup</B> 볼륨들은 <B>/weekly/mon/tues</B> 레벨에서 어제
화요일 수행된 덤프에 포함되었습니다. 백업 시스템은 상위 클론 날짜로서
화요일 오전 3:00를 사용하며, 이것은 백업 버전이 화요일의 덤프 동작
바로 전에 작성된 시간입니다. 그러나 화요일 덤프에는
<B>user.smith.backup</B> 볼륨이 포함되지 않습니다.
덤프에 포함된 마지막 시간은 <B>/weekly/mon</B> 레벨, 월요일입니다. 백업 시스템은 상위 클론 날짜를
월요일 오전 2:47으로 사용하며, 이것은 월요일 덤프 동작 이전에 볼륨의
백업 버전이 작성되었던 때입니다.
</LI><LI>증분 백업을 수행하는 경우, 백업 시스템은 볼륨 서버에 대해
작업하여 상위 클론 날짜와 현재 클론 날짜 사이에서 변경된(시간소인이
변경된) 각 볼륨에 있는 모든 파일 목록을 준비합니다. 덤프에는 그러한
모든 파일의 완전한 내용이 포함됩니다. 파일이 변경되지 않았으면,
덤프에는 이에 대한 위치지정자 스텁만이 포함됩니다.
덤프에는 이전 덤프 이후 변경 여부에 관계없이
볼륨내의 완전한 디렉토리 구조 사본이 포함됩니다.
<P>
<P>마지막 덤프 이후 볼륨에 변경된 데이터가 없으면, 백업 시스템은 볼륨을
완전히 생략합니다. 테이프 조정자와 로그 파일에서 다음 메시지를
생성합니다.
<P>
<PRE>   Volume <VAR>volume_name</VAR> (<VAR>volume_ID</VAR>) not dumped - has not been modified 
      since last dump.
</PRE>
</LI><LI><A NAME="LIBKOV-READCFG"></A>테이프 조정자는 데이터 백업을 준비합니다.
<B>CFG_</B><VAR>device_name</VAR> 파일이 있으면,
<A HREF="#LIBKOV-BUTC">1</A> 단계에서 이미 이를 읽었습니다. 다음
목록에서는 파일에 있는 명령어가 이 때 테이프 조정자의 동작을
지시하는 방법에 대해 설명합니다.
<P>
<DL>
<P><DT><B>FILE
</B><DD>이 명령이 <B>YES</B>로 설정되면, 테이프 조정자는
데이터를 백업 데이터 파일로 기록합니다.
<B>tapeconfig</B> 파일에 있는 <VAR>device_name</VAR>
필드에서는 덤프가 제대로 동작하기 위해 파일 이름을 지정해야 합니다.
백업 데이터 파일 구성과 그 명령에 대해서는 <A HREF="auagd011.htm#HDRWQ282">백업 데이터 파일로 데이터 덤프</A>의
내용을 참조하십시오.
<P>
<P><B>NO</B>로 설정되어 있거나 파일에 없으면, 테이프
조정자는 테이프 장치로 기록합니다.
<P><DT><B>MOUNT 및UNMOUNT
</B><DD>파일에 <B>MOUNT</B> 명령문이 있으면, 테이프
조정자에 새로운 테이프가 필요할 때 마다 표시된 스크립트나 프로그램을
호출하여 장치의 테이프 드라이브에서 테이프를 마운트합니다. 테이프
스태커나 주크 박스 기능을 이용하여 테이프를 자동 교체하려면
<B>MOUNT</B> 명령문이 있어야 합니다.
<B>MOUNT</B> 명령문이 없는 경우, 테이프 조정자는
테이프가 필요할 때 마다 운용자에게 프롬프트를 표시합니다.
<P>
<P>다음에서 설명하는 <B>AUTOQUERY</B> 명령문은 덤프
동작에 필요한 첫번째 테이프를 위한 테이프 조정자의 테이프 확보
프로시듀어를 수정합니다.
<P>
<P><B>UNMOUNT</B> 명령이 있으면, 테이프 조정자는 테이프
장치가 필요할 때 마다 표시된 스크립트나 프로그램을 호출합니다.
모든 테이프 장치에 별도의 테이프 마운트해제 루틴이 있는 것은 아니며,
이런 경우 <B>UNMOUNT</B> 명령은 필요없습니다.
명령에 대해서는 <A HREF="auagd011.htm#HDRWQ277">장치의 테이프 마운트 및 마운트해제 루틴 호출</A>의 내용을 참조하십시오.
<P><DT><B>AUTOQUERY
</B><DD>이 명령이 <B>NO</B>로 설정되어 있으면, 테이프
조정자는 덤프 동작에 필요한 첫번째 테이프가 이미 테이프 드라이브에
있는 것으로 가정합니다. <B>MOUNT</B> 명령에 대한 앞의
설명에서 처럼 일반 테이프 확보 프로시듀어를 사용하지 않습니다.
<B>-noautoquery</B> 플래그를
<B>butc</B> 명령에 포함시키면 같은 효과를 얻을 수 있습니다.
<P>
<P>이 명령이 없거나 <B>YES</B>로 설정되어 있으면,
테이프 조정자는 첫번째 테이프인 경우라도 일반 테이프 확보 프로시듀어를
사용합니다. 자세한 내용은 <A HREF="auagd011.htm#HDRWQ278">초기 테이프에서 탐색 또는 프롬프트 삭제</A>의 내용을 참조하십시오.
<P><DT><B>BUFFERSIZE
</B><DD>이 명령이 파일에 있으면, 테이프 조정자는 기본 버퍼 크기 16 KB
대신 버퍼 크기를 지정된 값으로 설정합니다. 자세한 설명은
<A HREF="auagd011.htm#HDRWQ281">테이프 스트림화를 위한 메모리 버퍼 설정</A>의 내용을 참조하십시오.
</DL>
<P>
<P><B>CFG_</B><VAR>device_name</VAR> 파일이 없으면, 테이프
조정자는 데이터를 테이프 장치로 기록하고, 테이프가 필요할 때 마다
운용자에게 프롬프트를 표시합니다(<B>-noautoquery</B>
플래그가 <B>butc</B> 명령에 있는 경우 첫번째 테이프는
제외).
</LI><LI><A NAME="LIBKOV-NAMECHECK"></A>테이프 조정자는
<B>CFG_</B><VAR>device_name</VAR> 파일에 있는 명령에서
지시한 것처럼(<A HREF="#LIBKOV-READCFG">6</A> 단계에서 설명함) 이 때
테이프 드라이브나 백업 데이터 파일을 엽니다.
명령문은 마운트 스크립트를 호출할 것인 지 또는 운용자에게 프롬프트할
것인 지 여부도 결정합니다. <A HREF="#LIBKOV-BUTC">1</A> 단계에서, 테이프
조정자는 <B>tapeconfig</B> 파일에서 장치의 용량과
파일표시 크기를 읽습니다. 이제는 테이프나 백업 데이터 파일의 마그네틱
레이블에서 같은 값들을 읽고 이전 값과 다르면
<B>tapeconfig</B> 값들을 겹쳐쓰기합니다.
<P>
<P>초기 덤프를(현재 예에서처럼) 작성하지만 레이블에 영구적 이름이
없는 경우, 테이프 조정자는 AFS 테이프 이름의 형식이 3개의 수용가능한
형식 중 하나인 지 체크합니다.
그렇지 않으면, 테이프를 꺼내고 <B>backup labeltape</B> 명령을 사용하여 수용가능한 이름을 기록해야 합니다.
<B>NAME_CHECK NO</B> 명령문을
<B>CFG_</B><VAR>device_name</VAR> 파일에 삽입하여 이
이름 점검 단계를 통과할 수 있습니다. 수용가능한 AFS 테이프 이름 값
목록과 그 설명에 대해서는 <A HREF="auagd011.htm#HDRWQ280">AFS 테이프 이름 체크 삭제</A>의 내용을
참조하십시오.
</LI><LI><A NAME="LIBKOV-EXPDATE"></A>초기 덤프의 경우, 테이프 조정자는 테이프 또는
백업 덤프 파일의 처음에서 쓰기를 시작하고, 기존 데이터를
겹쳐쓰기합니다. 잘못 겹쳐쓰기하지 않도록 하기 위해, 백업 시스템은
먼저 테이프나 백업 덤프 파일의 레이블에 있는 이름과 연관된 덤프
레코드를 백업 데이터베이스에서 확인합니다. 만기되지 않은 덤프가
있는 백업 데이터 파일로의 쓰기 또는 만기되지 않은 덤프가 있는 덤프
세트에 속하는 테이프로의 쓰기는 거부합니다. 모든 덤프가 만기되기 전에
파일이나 테이프를 다시 사용하려면, <B>backup labeltape</B>
명령을 사용하여 이에 대해 레이블을 다시 지정하십시오. 이렇게 하면
파일에 있는 모든 덤프 또는 덤프 세트에 있는 모든 테이프에서 백업
데이터베이스 레코드가 제거되며, 그러면 테이프에서 데이터들을 복원할 수
없게 됩니다. 만기 날짜에 대해서는 <A HREF="auagd011.htm#HDRWQ270">만기 날짜 정의</A>의
내용을 참조하십시오.
<P>
<P>테이프 조정자는 서로 다른 두 가지 유형의 부적합한 테이프가 다시
사용되었는 지 체크합니다. 테이프에 현재 수행되는 덤프에 속하는
데이터가 포함될 수 없으며, 이는 이전 테이프가 아직 드라이브에 있거나
테이프를 잘못하여 다시 삽입했음을 의미하기 때문입니다. 테이프
조정자는 다음 메시지를 생성하고 다른 테이프를 확보하려 합니다.
<P>
<PRE>   Can't overwrite tape containing the dump in progress
</PRE>
<P>
<P>테이프에는 현재(증분) 덤프의 상위 덤프에 있는 데이터가 들어갈 수
없으며, 이는 상위 덤프를 겹쳐쓰기하면 현재 덤프에서 데이터를 복원할
수 없게 되기 때문입니다. 테이프 조정자는 다음 메시지를 생성하고 다른
테이프를 확보하려 합니다.
<P>
<PRE>   Can't overwrite the parent dump <VAR>parent_name</VAR> (<VAR>parent_dump_ID</VAR>)
</PRE>
</LI><LI><A NAME="LIBKOV-WRITE"></A>테이프 조정자는 이제 테이프나 백업 데이터 파일로
데이터를 기록합니다. 사용가능한 공간을 추적하면서
<A HREF="#LIBKOV-NAMECHECK">7</A> 단계에서 확보한
용량과 파일표시 크기를 사용하며, 테이프 끝에 도달했을 때 덤프가 아직
완료되지 않았으면 테이프 확보 프로시듀어를 자동으로 사용합니다.
자세한 설명 및 테이프 조정자가 물리적으로 테이프 끝에 갑자기 도달했을
경우 발생할 수 있는 내용에 대해서는 <A HREF="auagd011.htm#HDRWQ258">tapeconfig 파일 구성</A>의
내용을 참조하십시오. 이와 유사하게, 갑작스런 공간 부족으로부터의
복구를 최적화하도록 백업 데이터 파일을 구성하는 명령에 대해서는
<A HREF="auagd011.htm#HDRWQ282">백업 데이터 파일로 데이터 덤프</A>에 있는 명령의
<A HREF="auagd011.htm#LITAPECONFIG-FILE">6</A> 단계를 참조하십시오.
<P>
<P>테이프 조정자가 덤프 도중 볼륨에 액세스할 수 없는 경우(서버 프로세스,
시스템 또는 네트워크 부족으로 인해), 볼륨을 건너뛰고 액세스할 수
있는 모든 볼륨들을 계속해서 덤프합니다. 그런 다음 누락된 볼륨에 대한
오류 메시지를 테이프 조정자 창과 로그 파일에서 생성합니다. 백업
볼륨이 이전 덤프 동작을 수행한 뒤 다시 복제되지 않았음을
발견하면(즉, 볼륨의 현재 클론 날짜가 상위 클론 날짜와 같음)
이와 유사한 메시지를 생성합니다.
<P>
<PRE>   Volume <VAR>volume_name</VAR> (<VAR>volume_ID</VAR>) not dumped - has not been re-cloned 
       since last dump.
</PRE>
<P>
<P>볼륨 모두를 처음 패스한 뒤, 각각의 누락된 볼륨을 다시 덤프하려
합니다. 먼저 첫번째 패스를 수행하는 동안 볼륨에 액세스할 수 없었던
이유가 VL 서버가 <A HREF="#LIBKOV-VOLMATCHES">3</A> 단계에서 덤프할 볼륨
목록을 생성한 뒤 이동되었기 때문인 지 체크합니다. 그런 경우, 새로운
사이트에서 볼륨을 덤프합니다. 볼륨에 액세스하려는 두 번째 시도도
실패하면, 테이프 조정자는 다음 메시지를 생성하여 진행할 방법에 대한
지시를 기다립니다.
<P>
<PRE>   Dump of volume <VAR>volume_name</VAR> (<VAR>volume_ID</VAR>) failed
   Please select action to be taken for this volume.
      r - retry, try dumping this volume again
      o - omit, this volume from this dump
      a - abort, the entire dump
</PRE>
<P>
<P>덤프 프로세스의 자동화를 증가시키기 위해, <B>ASK
NO</B> 명령문을 <B>CFG_</B><VAR>device_name</VAR>
파일에 삽입하여 이 프롬프트를 억제시키고 테이프 조정자가 덤프시
자동으로 볼륨을 누락시키도록 합니다.
<P>
<P>발생한 대로 덤프를 추적하는 경우, 프롬프트를 사용하면 정확한
조치를 취할 수 있습니다. 볼륨이 다시 복제되지 않았으면,
<B>vos backup</B> 명령을 실행할 수 없습니다. 볼륨에
액세스할 수 없으면, 그 원인을 조사하고 해결할 수 있습니다.
<A NAME="IDX7025"></A>
<A NAME="IDX7026"></A>
<A NAME="IDX7027"></A>
<A NAME="IDX7028"></A>
<A NAME="IDX7029"></A>
</LI><LI>테이프 또는 백업 데이터 파일에 아직 AFS 테이프 이름이 없으면,
백업 시스템은 적합한 이름을 생성하고, 이를 레이블과 백업 데이터베이스에
기록합니다. 또한 덤프 이름과 ID 번호를 덤프에 지정하고, 이를
백업 데이터베이스에서 작성한 덤프 레코드로 기록합니다.
테이프 및 덤프 이름에 대한 자세한 설명은 <A HREF="auagd011.htm#HDRWQ253">덤프 이름과 테이프 이름</A>의
내용을 참조하십시오. 덤프 레코드 또는 볼륨의 덤프 히스토리 표시, 또는
테이프 내용 검색에 대해서는 <A HREF="#HDRWQ302">백업 덤프 레코드 표시</A>의 내용을 참조하십시오.
</LI></OL>
<P><H3><A NAME="HDRWQ299" HREF="auagd002.htm#ToC_336">기존 덤프 세트로 덤프 추가</A></H3>
<A NAME="IDX7030"></A>
<P>AFS 백업 시스템을 사용하면 <B>-append</B> 플래그를
<B>backup dump</B> 명령에 삽입시켜 덤프 세트에 있는
마지막 테이프 끝에 덤프를 추가할 수 있습니다. 덤프를 추가하면 백업
시스템 자동화와 효율성이 여러 방식으로 향상됩니다.
<UL>
<LI>테이프 용량의 사용이 극대화됩니다. 초기 덤프는 항상 새로운
테이프에서 시작되어야 하지만, 덤프 세트에 있는 마지막 테이프 끝에
추가될 필요는 없습니다. 하나 이상의 덤프를 추가하여 사용하지 않는
테이프를 채울 수 있습니다.
</LI><LI>덤프 동작을 완료하는 데 필요한 테이프 수와 테이프 교체 횟수를
줄일 수 있습니다. 먼저 초기 덤프들을 연속해서 수행하는 대신, 초기
덤프에서 시작하여 여러 추가 덤프를 바로 다음에 수행합니다. 이
방식을 사용하면 모든 덤프들을 연속해서 같은 테이프에 기록할 수
있습니다(테이프에 이들 모두를 수용할 충분한 공간이 있는 것으로
가정함). 반대로 먼저 초기 덤프 모두를 수행하면, 각각은 새로운
테이프에서 시작되어야 하고 덤프를 추가해야 할 경우 다시 테이프들을
교체해야 합니다.
<P>
<P>대화식 <TT>backup></TT> 프롬프트에서 일련의 <B>backup dump</B> 명령들을 실행하거나, <B>backup dump</B> 명령에서
<B>-file</B> 인수로 이름을 지정했던 파일에 기록할 수
있습니다. 이런 방식으로 덤프를 추가하면 덤프 모두가 한 테이프에
수용될 수 있는 경우 테이프 스태커나 주크 박스 없이도 여러번의 무인
백업 동작을 수행할 수 있습니다.
</LI><LI>복원 동작을 수행하는 동안 테이프 교체 횟수를 줄일 수 있습니다.
예를 들어 볼륨 세트의 증분 덤프 모두를 한 덤프 세트에 있는 테이프로
추가하면, 볼륨 세트에서 볼륨을 복원하는 데 필요한 테이프 교체 횟수가
최소화됩니다. 상위 전체 덤프가 들어있는 테이프로 증분 덤프를
추가하지 않는 것이 최선이지만, 테이프가 유실 또는 훼손된 경우,
볼륨에서 데이터 모두를 잃게 됩니다.
<P>
<P>관련된 추가 덤프 모두를 그룹화하는 것이 효율적일 수 있더라도, 백업
시스템에서는 테이프나 덤프 세트에 있는 추가 덤프간의 관계가 필요하지
않습니다.
</LI></UL>
<P>추가 덤프 기록시, 백업 시스템은 <A HREF="#HDRWQ298">덤프 프로세스에 대한 구성 선택사항의 영향</A>에서
설명한 대부분의 단계를 수행합니다. 추가된 덤프는 다른 덤프 또는 초기
덤프와 아무런 관계가 없으므로, <A HREF="#LIBKOV-NAMECHECK">7</A> 단계를
건너뜁니다. 이런 경우 AFS 테이프 이름이 볼륨 세트와 덤프 레벨 이름에
적용되는 지 체크할 필요도 없습니다. 또한 <A HREF="#LIBKOV-EXPDATE">8</A>
단계도 건너뜁니다.
테이프에 있는 기존 데이터를 겹쳐쓰기하지 않으므로, 테이프나 파일에
있는 기존 덤프의 만기 날짜를 체크하지 않아도 됩니다.
<A HREF="#LIBKOV-WRITE">9</A> 단계에서, 테이프 조정자는 데이터를 기록하기
전에 테이프 또는 백업 데이터 파일에 있는 마지막 덤프 끝까지 검색합니다.
<P>백업 시스템은 추가된 덤프에 대해 다음 조건을 부과합니다.
<UL>
<LI>테이프로 기록하는 경우, 테이프 조정자는 덤프 세트의 마지막이
백업 데이터베이스에 있는 완료되어 유효한 테이프 및 덤프 레코드인 지
체크합니다. 그렇지 않으면 테이프를 꺼내고 수용가능한 테이프를
요청합니다. 테이프에 유효한 데이터가 있을 것으로 생각되면,
<A HREF="#HDRWQ305">테이프 내용 검색하기</A>에서 설명한 것처럼
<B>backup scantape</B> 명령에서 <B>-dbadd</B>
인수를 사용하여 이에 대한 백업 데이터베이스 덤프 레코드를 다시 생성할
수 있습니다.
</LI><LI>테이프나 백업 데이터 파일에 있는 가장 최근의 덤프는 완료되어야
합니다.
</LI><LI>테이프나 파일이 속하는 덤프 세트는 백업 데이터베이스에서 기록된
초기 덤프로 시작되어야 합니다. 현재 테이프에 덤프가 없으면, 백업
시스템은 초기 덤프로서 덤프 동작을 처리하고, 관련 요구사항을
부과합니다(예를 들면 AFS 테이프 이름이 적합한 지 체크).
</LI></UL>
<P>덤프 추가시, 백업 데이터베이스에 있는 덤프 세트의 덤프 및 테이프
레코드 모두가 초기 덤프로 색인화됨을 기억하십시오. 추가된 덤프의
레코드를 삭제하려면, 초기 덤프 레코드를 삭제해야 하며, 그러면 덤프
세트에 있는 모든 덤프의 레코드들이 삭제됩니다. 이들 레코드 없이는
덤프 세트에 있는 어떤 데이터로 복원할 수 없습니다.
<P>이처럼, 덤프 세트에 있는 모든 덤프들은 덤프 세트에 있는 테이프를
다시 사용하기 전에(새로운 초기 덤프를 기록) 만기되어야 합니다.
만기 날짜가 덤프 세트에 있는 테이프를 다시 사용할 날짜보다 이후이면
덤프를 추가하지 마십시오. 마지막 만기 날짜 이전에 테이프를 다시
사용하려면, 백업 데이터베이스에서 초기 덤프의 레코드를 삭제해야
합니다. <B>backup labeltape</B> 명령을 사용하여
<A HREF="auagd011.htm#HDRWQ273">테이프에 레이블 지정하기</A>에서 설명한 것처럼 테이프에 레이블을
다시 지정하거나, <B>backup deletedump</B> 명령을
사용하여 <A HREF="#HDRWQ322">백업 데이터베이스에서 레코드 삭제하기</A>에서 설명한 것처럼 레코드를
직접 삭제하십시오.
<P>이론적으로는 원하는 만큼 많은 덤프를 추가할 수 있다 하더라도, 보통
덤프 세트에서는 다음의 이유로 테이프 수에 제한이 있음을 알 수
있습니다(예를 들면 5까지).
<UL>
<LI>덤프 세트에 있는 테이프 중 하나에서 읽을 수 없는 부분을 발견하면,
백업 운영 레코드를 다시 구성하는 데 사용하는 <B>backup scantape</B> 동작의 일부로서 테이프 조정자가 테이프를
검색하지 않도록 할 수 있습니다.
테이프 조정자는 거의 항상 손상된 부분까지 성공적으로 테이프를
검색할 수 있으며, 사소한 손상 부분은 보통 통과할 수 있습니다.
검색 동작은 덤프 세트에 있는 임의 테이프에서 시작될 수 있으므로,
한 테이프가 손상되었다고 해서 덤프 세트에 있는 다른 테이프까지
검색할 수 없는 것은 아닙니다. 그러나 덤프 세트에서 손상된 부분
앞에 있는 테이프만을 검색하거나, 손상된 부분 다음에 오는 테이프만을
검색할 수 있습니다(백업 데이터베이스에서 테이프를 사용하여 정보를
재구성하는 내용에 대해서는 <A HREF="#HDRWQ305">테이프 내용 검색하기</A>의 내용을
참조하십시오).
<P>
<P>읽을 수 없는 잘못된 부분이 생기면 볼륨 전체를 복구할 수 없습니다.
이는 복원 동작이 전체 덤프에서 시작되고 각각의 증분 덤프에서 순서대로
계속되기 때문입니다. 특정 덤프를 복원할 수 없으면, 이후 증분 덤프의
데이터들도 복원할 수 없습니다.
</LI><LI>앞으로 하나 이상의 덤프를 보존하려는 경우라면, 관심있는 데이터가
들어있는 것만이 아닌 덤프 세트를 구성하는 전체 테이프 세트를 보존해야
합니다. 하지만 그렇게 하면 테이프와 보존 저장장소 모두가 낭비됩니다.
보존에 대한 자세한 내용은 <A HREF="auagd011.htm#HDRWQ269">테이프 보존</A>을 참조하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ300" HREF="auagd002.htm#ToC_337">덤프 스케줄</A></H3>
<P>기본적으로, 백업 시스템은 사용자가 <B>backup dump</B>
명령을 입력하자 마자 덤프 동작을 실행하며, 테이프 조정자는 데이터를
사용하지 않게 되고 기록할 파일 목록을 사용할 수 있게 되면 즉시
기록하기 시작합니다. 그러나 특정 시점에 시작하도록 덤프 동작을
스케줄할 수 있습니다.
<UL>
<LI>단일 덤프 동작을 스케줄하려면, <B>-at</B> 인수를 삽입하여 시작 시간을 지정하십시오.
</LI><LI>여러 덤프 동작을 스케줄하려면, <B>-file</B>
인수에서 지정한 파일에 동작을 나열하고 <B>-at</B> 인수를 사용하여 <B>backup</B> 명령 해석기가
파일을 읽는 시기를 지정하십시오. <B>-at</B> 인수를
누락하면, 명령 해석기를 즉시 파일을 읽어 스케줄로서 계산되지 않지만
하나의 명령으로 여러개의 덤프 동작을 시작하도록 할 수 있습니다.
<B>-file</B> 인수를 <B>-volumeset</B>,
<B>-dump</B>, <B>-portoffset</B>,
<B>-append</B> 또는 <B>-n</B>
옵션과 결합하지 마십시오.
<P>
<P>파일 포맷팅 명령에 대해서는 <A HREF="#HDRWQ301">덤프 작성하기</A>의
<A HREF="#LIBKDUMP-SYNTAX">7</A> 과정에 있는 <B>-file</B>
인수 설명을 참조하십시오.
</LI></UL>
<P>백업 시스템은 <B>backup dump</B> 명령을 실행하자마자
스케줄되는 지 또는 실행을 시작하는 지에 관계없이 같은 방식으로
초기 및 추가 덤프를 수행합니다. 한가지 차이점은 성공적으로 실행하기
위한 요구조건들을 명령 실행 시간과 백업 시스템이 실제로 실행을 시작하는
시간에 모두 만족시켜야 한다는 것입니다. 볼륨 세트, 덤프 레벨 및 포트
오프셋에 필요한 모든 백업 데이터베이스 항목과, 모든 덤프 및 테이프
레코드들도 이 때 있어야 합니다. 아마도 더욱 중요한 것은 필수 관리
토큰을 이 때 사용할 수 있어야 한다는 것입니다. <A HREF="#HDRWQ297">백업 동작을 보다 효과적으로 작성하기</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ301" HREF="auagd002.htm#ToC_338">덤프 작성하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
</LI><LI>테이프 장치를 사용하는 경우 테이프를 넣으십시오.
</LI><LI><B>backup</B> 명령을 실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   % <B>backup</B>
</PRE>
</LI><LI>사용할 볼륨 세트와 덤프 레벨을 결정하십시오. 필요하면,
<B>backup listvolsets</B> 및 <B>backup listdumps</B> 명령을 실행하여 기존 볼륨 세트와 덤프 레벨을 표시하십시오.
출력에 대한 설명과 완전한 명령에 대해서는 <A HREF="auagd011.htm#HDRWQ266">볼륨 세트 및 볼륨 항목 표시하기</A>
및 <A HREF="auagd011.htm#HDRWQ271">덤프 계층 표시하기</A>의 내용을 참조하십시오.
<P>
<PRE>   backup> <B>listvolsets</B>  [&lt;<VAR>volume&nbsp;set&nbsp;name</VAR>>]
   backup> <B>listdumps</B>
</PRE>
<P>
<P>임시 볼륨 세트를 사용하려 하면, 현재 대화식 세션에 있는 동안 작성해야
합니다.
이것은 볼륨을 영구적으로 제거하기 위해 테이프로 덤프할 경우에
유용합니다(소유자가 셀을 제거하려 하므로). 이런 경우, 한번만 사용하는
볼륨 세트 레코드로 백업 데이터베이스를 채우지 않고도 관심있는 볼륨만
들어있는 볼륨 항목을 정의할 수 있습니다. 완전한 명령은
<A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>에 있습니다.
<P>
<PRE>   backup>  <B>addvolset</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>> <B>-temporary</B>
   backup> <B>addvolentry  -name</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>>  \
                        <B>-server</B> &lt;<VAR>machine&nbsp;name</VAR>>  \
                        <B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>  \
                        <B>-volumes</B> &lt;<VAR>volume&nbsp;name&nbsp;(regular&nbsp;expression)</VAR>>
</PRE>
</LI><LI>초기 덤프를 작성하여 이를 영구적 이름이 없는 테이프나 백업 데이터
파일로 기록하는 경우, 이것의 AFS 테이프 이름은
<A HREF="auagd011.htm#HDRWQ280">AFS 테이프 이름 체크 삭제</A>에서 설명한 바와 같이 백업 시스템의
포맷 요구조건을 만족시켜야 합니다.
필요하면, <B>backup readlabel</B> 명령을 사용하여
레이블을 표시하고, <B>backup labeltape</B> 명령을
사용하여 <A HREF="auagd011.htm#HDRWQ272">테이프 레이블 기록 및 읽기</A>에서 설명한 것처럼 이름을
변경하십시오. 또한 테이프를 겹쳐쓰기하고 이를 만기되지 않은 덤프가
들어있는 덤프 세트의 일부가 되도록 하려는 경우 권장하지 않더라도
테이프에 레이블을 다시 지정해야 합니다. 테이프 재사용 방법에 대한
설명은 <A HREF="auagd011.htm#HDRWQ268">테이프 재사용 스케줄 작성</A>의 내용을 참조하십시오.
<A NAME="IDX7031"></A>
<A NAME="IDX7032"></A>
</LI><LI><A NAME="LIBKDUMP-SYNTAX"></A><B>backup dump</B> 명령을
사용하여 볼륨 세트를 덤프하십시오.
<UL>
<LI>하나의 초기 덤프를 작성하려면, 볼륨 세트명, 덤프 레벨 이름 및
포트 오프셋(0이 아닌 경우)만을 제공하십시오.
</LI><LI>하나의 추가 덤프를 작성하려면 <B>-append</B>
플래그를 추가하십시오.
</LI><LI>단일 초기 덤프 또는 추가 덤프를 스케줄하려면, <B>-at</B> 인수를 추가하십시오.
</LI><LI>여러 개의 덤프 동작을 시작하려면, 파일에 해당 명령을 기록하고
<B>-file</B> 인수를 사용하여 이에 이름을 지정하십시오.
이 인수를 <B>-at</B> 이외의 다른 인수와 결합하지 마십시오.
</LI></UL>
<P>
<PRE>   backup> <B>dump</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>> &lt;<VAR>dump&nbsp;level&nbsp;name</VAR>> [&lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]   \
                [<B>-at</B> &lt;<VAR>Date/time&nbsp;to&nbsp;start&nbsp;dump</VAR>><SUP>+</SUP>]  \
                [<B>-append</B>]  [<B>-n</B>]
[<B>-file</B> &lt;<VAR>load file</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>dump
</B><DD>모두를 입력해야 합니다.
<P><DT><B><VAR>volume set name</VAR>
</B><DD>덤프할 볼륨 세트 이름입니다.
<P><DT><B><VAR>dump level name</VAR>
</B><DD>볼륨세트를 덤프할 덤프 레벨의 완전 경로 이름를 지정합니다.
<P><DT><B><VAR>TC port offset</VAR>
</B><DD>동작을 처리하는 테이프 조정자 프로세스의 포트 오프셋 번호를
지정합니다. 기본값 0이 적합하지 않으면 이 인수를 제공해야 합니다.
<P><DT><B>-at
</B><DD>앞으로 명령을 실행할 또는 <B>-file</B>
인수에서 지정한 파일을 읽을 날짜와 시간을 지정합니다.
<VAR>mm</VAR>/<VAR>dd</VAR>/<VAR>yyyy</VAR> [<VAR>hh</VAR>:<VAR>MM</VAR>]
형식으로 값을 입력합니다. 여기서 월(<VAR>mm</VAR>), 일(<VAR>dd</VAR>)
및 연(<VAR>yyyy</VAR>)은 필수입니다. 유효한 연 값 범위는
<B>1970</B> - <B>2037</B>이며, 그보다
높은 값은 표준 UNIX 표현에 있는 가장 큰 날짜가 2038년 1월이므로
유효하지 않습니다. 백업 시스템은 자동으로 2038 이내의 최대 값으로
나중에 있는 날짜를 줄입니다.
<P>
<P>시간과 분(<VAR>hh</VAR>:<VAR>MM</VAR>)은 선택적이지만, 제공되면
24시간 형식(예를 들어 <B>14:36</B>는 오후 2:36)으로
되어있어야 합니다. 이것이 생략되었을 경우 시간의 기본값은 자정(00:00시)입니다.
<P>
<P>예에서, <B>04/23/1999 20:20</B>값은 1999년 4월 23일
오후 8:20으로 명령을 스케줄합니다.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">명령의 구문 명령문에서 이 인수 다음에는 플러스 기호가 오며,
이것은 다른 분리문자나 큰 따옴표로 묶지 않아도 되는 여러 단어 값을
사용할 수 있기 때문이며, 여러 날짜를 사용하기 때문은 아닙니다.
하나의 날짜(그리고 선택적으로 시간) 정의를 입력합니다.
</TD></TR></TABLE>
<P><DT><B>-append
</B><DD>테이프나 백업 데이터 파일에서 발견한 하나 이상의 덤프 동작에서
부터 데이터 끝까지 검색하여 추가 덤프를 작성합니다.
<P><DT><B>-n
</B><DD>표시된 덤프에 포함시킬 모든 볼륨 이름을 표시하지만, 실제로
데이터를 테이프나 백업 데이터 파일에 기록하지는 않습니다. 이
플래그를 실제 명령에서 사용하려는 인수와 결합하십시오.
<B>-file</B> 인수와는 결합하지 마십시오.
<P><DT><B>-file
</B><DD><B>backup</B> 명령이 들어있는 파일의 로컬 디스크
또는 AFS 경로 이름을 지정합니다.
백업 시스템은 즉시 파일을 읽거나, 인수가 있는 경우
<B>-at</B> 인수에서 지정한 시간에 파일을 읽습니다.
일부 경로 이름은 현재 작업 디렉토리에 관련하여 해석됩니다.
<P>
<P>표시된 파일의 행에 <B>backup dump</B> 명령을
삽입하십시오. 이 때 명령행과 같은 구문을 사용하지만 행 처음에
<B>backup</B> 단어는 삭제하십시오. 각 명령에는 0값이
적합하지 않은 경우 <VAR>volume set name</VAR> 및 <VAR>dump level
name</VAR> 인수와 <VAR>TC port offset</VAR> 인수가 들어있어야 합니다.
파일에 있는 명령에는 <B>backup dump</B> 명령의 선택적
인수가 포함될 수 있으며, 여기에는 <B>-at</B> 인수(이것은 백업 시스템이 파일을 읽는 날짜와 시간보다
이후의 날짜와 시간을 지정해야 함)가 포함됩니다.
</DL>
</LI><LI><B>butc</B> 명령을 실행할 때
<B>-noautoquery</B> 플래그를 삽입하지 않았거나
장치의 <B>CFG_</B><VAR>device_name</VAR> 구성 파일에
<B>AUTOQUERY YES</B>가 들어있는 경우, 테이프 조정자는
장치 드라이브에 테이프를 넣도록 합니다. 이미 테이프를 넣었으면,
&lt;<B>Return</B>>을 눌러 레이블링 준비가 되었음을
나타내어야 합니다.
<P>
<P>여러 테이프가 필요하면, <B>MOUNT</B> 명령문을
<B>CFG_</B><VAR>device_name</VAR> 파일에 삽입하고 해당
스태커나 주크 박스를 테이프로 채우거나, 아니면 콘솔에 남아 후속
테이프에 대한 테이프 조정자 프롬프트에 반응해야 합니다.
</LI><LI>덤프 동작이 완료되면, 오류가 있는 지 백업 시스템의 로그 파일를
검토하십시오. <A HREF="auagd009.htm#HDRWQ173">서버 프로세스 로그 파일 표시</A>에서 설명한 바와
같이 <B>bos getlog</B> 명령을 사용하여
<B>/usr/afs/logs/BackupLog</B> 파일을 읽고,
테이프 조정자 시스템에서는 문서 편집기를 사용하여
로컬 <B>/usr/afs/backup</B> 디렉토리에 있는
<B>TE_</B><VAR>device_name</VAR> 및
<B>TL_</B><VAR>device_name</VAR> 파일들을 읽으십시오.
<P>
<P>테이프 이름과 덤프 ID 번호를 각 테이프의 외부 레이블에 기록하는 것도 좋습니다.
</LI></OL>
<HR><H2><A NAME="HDRWQ302" HREF="auagd002.htm#ToC_339">백업 덤프 레코드 표시</A></H2>
<P><B>backup</B> 명령 집합에는 백업한 데이터에 대한
정보를 표시하는 3개의 명령이 포함됩니다.
<UL>
<LI>수행된 날짜와 포함된 볼륨 수처럼 하나 이상의 덤프 동작에 대한
정보를 표시하려면, <A HREF="#HDRWQ303">덤프 레코드 표시하기</A>에서처럼
<B>backup dumpinfo</B> 명령을 사용하십시오.
단일 덤프의 상세 레코드 또는 일정 수의 덤프에 대한 집약 레코드를
표시할 수 있으며, 최근의 것부터 시작하여 과거의 것으로 진행합니다.
덤프 수를 지정하거나 기본값 10을 사용할 수 있습니다.
</LI><LI>볼륨의 덤프 히스토리를 표시하려면, <A HREF="#HDRWQ304">볼륨의 덤프 히스토리 표시하기</A>에서
설명한 바와 같이 <B>backup volinfo</B> 명령을 사용하십시오.
</LI><LI>포함된 볼륨에 대해 테이프나 백업 데이터 파일에서 추출한 정보를
표시하려면 <B>backup scantape</B> 명령을 사용하십시오.
테이프 및 덤프 레이블에서 생겨난 새로운 덤프 및 테이프 레코드들을
백업 데이터베이스에서 작성하려면 <B>-dbadd</B>
플래그를 추가하십시오. 명령에 대해서는 <A HREF="#HDRWQ305">테이프 내용 검색하기</A>의
내용을 참조하십시오.
</LI></UL>
<A NAME="IDX7033"></A>
<A NAME="IDX7034"></A>
<A NAME="IDX7035"></A>
<A NAME="IDX7036"></A>
<A NAME="IDX7037"></A>
<A NAME="IDX7038"></A>
<A NAME="IDX7039"></A>
<P><H3><A NAME="HDRWQ303" HREF="auagd002.htm#ToC_340">덤프 레코드 표시하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>backup dumpinfo</B> 명령을 실행하여 백업
데이터베이스에서 기록된 덤프에 대한 정보를 나열하십시오.
<P>
<PRE>   % <B>backup dumpinfo</B> [<B>-ndumps</B> &lt;<VAR>no.&nbsp;of&nbsp;dumps</VAR>>]  [<B>-id</B> &lt;<VAR>dump&nbsp;id</VAR>>]  [<B>-verbose</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>dump
</B><DD><B>dumpinfo</B>의 축약명입니다.
<P><DT><B>-ndumps
</B><DD>지정된 갯수의 덤프 각각에 대한 백업 데이터베이스 레코드를
표시하며, 최근의 것부터 시작하여 과거의 것으로 진행됩니다.
데이터베이스에 요청된 것보다 적은 갯수의 덤프가 들어있으면, 출력에는
기존의 모든 덤프에 대한 레코드들이 포함됩니다. 이 인수를 <B>-id</B> 인수나 <B>-verbose</B> 플래그와 결합하지
마십시오. 마지막 10개 덤프에 대한 레코드를 표시하려면, 3개의 옵션
모두를 생략하십시오.
<P><DT><B>-id
</B><DD>백업 데이터베이스 레코드를 표시할 단일 덤프의 덤프 ID 번호를
지정합니다. <B>-id</B> 스위치를 포함시켜야 합니다.
이 옵션을 <B>-ndumps</B> 또는
<B>-verbose</B> 인수와 결합시키지 마십시오. 마지막
10개 덤프에 대한 레코드를 표시하려면 3 인수 모두를 생략하십시오.
<P><DT><B>-verbose
</B><DD><B>-id</B> 인수로 지정한 덤프에 대한 좀 더 상세
정보를 제공하며, 이 인수는 혼자서만 사용되어야 합니다. 이 플래그를
<B>-ndumps</B> 옵션과 함께 결합시키지 마십시오.
</DL>
</LI></OL>
<P><B>-ndumps</B> 인수가 제공되면, 출력에서는 테이블
양식으로 다음 정보를 제공하며, 각 덤프별로 각 행이 제공됩니다.
<DL>
<P><DT><B><TT>dumpid</TT>
</B><DD>덤프 ID 번호.
<P><DT><B><TT>parentid</TT>
</B><DD>덤프의 상위 덤프의 덤프 ID 번호. <TT>0</TT> 값은
전체 덤프를 식별합니다.
<P><DT><B><TT>lv</TT>
</B><DD>덤프를 작성하는 데 사용된 덤프 레벨의 덤프 계층 깊이.
<TT>0</TT> 값은 전체 덤프를 식별하며, 이 경우 <TT>parentid</TT>
필드에 있는 값도 <TT>0</TT>입니다. <TT>1</TT> 이상의 값은 덤프 계층의 해당 레벨에서 작성된 증분 덤프를
나타냅니다.
<P><DT><B><TT>created</TT>
</B><DD>백업 시스템이 덤프를 작성한 덤프 동작을 시작했던 날짜와 시간.
<P><DT><B><TT>nt</TT>
</B><DD>덤프에 있는 데이터가 들어있는 테이프 갯수.
<TT>0</TT> 값은 덤프 동작이 종료되었거나 실패했음을 나타냅니다.
<B>backup deletedump</B> 명령을 사용하여 그러한
항목들을 제거하십시오.
<P><DT><B><TT>nvols</TT>
</B><DD>데이터가 포함된 덤프의 볼륨 수. 볼륨이 여러 테이프에
걸쳐 있는 경우, 두번 계산됩니다. <TT>0</TT> 값은 덤프 동작이
종료되었거나 실패했음을 나타매고, <TT>nt</TT> 필드에 있는 값도 이
경우 <TT>0</TT>입니다.
<P><DT><B><TT>dump name</TT>
</B><DD>다음 양식으로 된 덤프 이름.
<P>
<PRE>   <VAR>volume_set_name</VAR>.<VAR>dump_level_name</VAR> (<VAR>initial_dump_ID</VAR>)
   
</PRE>
<P>
<P>
<P>여기서 <VAR>volume_set_name</VAR>은 볼륨 세트의 이름이고,
<VAR>dump_level_name</VAR>은 볼륨 세트가 덤프된 덤프 레벨 경로 이름의
마지막 요소입니다.
<P>
<P><VAR>initial_dump_ID</VAR>가 표시되면 이것은 이 덤프가 속할 덤프 세트에
있는 초기 덤프의 덤프 ID입니다. 괄호안에 값이 없으면, 덤프는 추가
덤프가 없는 덤프 세트내의 초기 덤프입니다.
</DL>
<P><B>-id</B> 인수만 제공되는 경우, 출력의 첫번째 행은
<TT>Dump</TT> 문자열로 시작되고, 다음 필드에서 전체 덤프에 대한
정보를 알려줍니다.
<DL>
<P><DT><B><TT>id</TT>
</B><DD>덤프 ID 번호.
<P><DT><B><TT>level</TT>
</B><DD>덤프를 작성하는 데 사용된 덤프 레벨의 덤프 계층 깊이.
<TT>0</TT> 값은 전체 덤프를 식별합니다. <TT>1</TT> 이상의 값은
덤프 계층의 지정된 레벨에서 작성된 증분 덤프를 나타냅니다.
<P><DT><B><TT>volumes</TT>
</B><DD>데이터가 포함된 덤프의 볼륨 수.
<P><DT><B><TT>created</TT>
</B><DD>덤프 동작이 시작된 날짜와 시간
</DL>
<P>다음에 공백 행이 오는 출력에는 덤프의 볼륨 데이터가 들어있는 각
테이프 항목도 포함됩니다. 뒤에 <TT>Tape</TT> 문자열이 오는 각
항목의 처음 두 행에서는 다음 필드에서 그 테이프에 대한 정보를 알려줍니다.
<DL>
<P><DT><B><TT>name</TT>
</B><DD>있는 경우 테이프의 영구적 이름 또는 이것의 AFS 테이프 이름, 및
괄호에 있는 테이프 ID 번호.
<P><DT><B><TT>nVolumes</TT>
</B><DD>덤프 데이터가 포함된 이 테이프의 볼륨 수.
<P><DT><B><TT>created</TT>
</B><DD>테이프 조정자가 이 테이프로 데이터를 기록하기 시작하는 날짜와
시간.
</DL>
<P>뒤에 다른 공백 행이 오는 테이프 고유 정보들은 테이프에 있는 각 볼륨
덤프에 대한 행이 포함되는 테이블을 구성합니다. 정보는 다음 표제와
함께 컬럼에 표시됩니다.
<DL>
<P><DT><B><TT>Pos</TT>
</B><DD>이 테이프 또는 파일에서 각 볼륨의 상대 위치. 테이프에서,
카운터는 위치 2(테이프 레이블이 위치 1에 있음)에서 시작되어 각
볼륨별로 1씩 증가합니다. 백업 데이터 파일에 있는 볼륨의 경우, 위치
번호는 1에서 부터 시작되지만 보통 1씩 증가하지는 않습니다. 각각은
파일에서 볼륨 데이터가 시작하는 16KB 오프셋의 서수입니다.
그러므로 위치 번위의 차이는 각 블록의 데이터가 차지하는 16KB
블록 수를 나타냅니다. 예를 들어 두 번째 볼륨이 위치 5에 있고 목록에
있는 세 번째 볼륨이 위치 9에 있는 경우, 이는 두 번째 볼륨의 덤프가
파일에서 64KB(6개의 16KB 블록)를 차지함을 의미합니다.
<P><DT><B><TT>Clone time</TT>
</B><DD>백업 또는 읽기 전용 볼륨의 경우, 읽기/쓰기 소스에서 복제된
시간. 읽기/쓰기 볼륨의 경우, 이것은 출력의 첫번째 행에서 표시하는
덤프 작성 날짜와 같습니다.
<P><DT><B><TT>Nbytes</TT>
</B><DD>볼륨 덤프에서 데이터의 바이트 수.
<P><DT><B><TT>Volume</TT>
</B><DD>볼륨 이름으로서, <TT>.backup</TT> 또는 <TT>.readonly</TT> 확장자로 완료됩니다.
</DL>
<P><B>-id</B> 인수와 <B>-verbose</B> 플래그 모두가 지정되면, 출력은 여러 섹션으로 구분됩니다.
<UL>
<LI>밑줄쳐진 <TT>Dump</TT> 문자열이 헤드인 첫번째 섹션에는 전체
덤프에 대한 정보가 포함됩니다. <TT>id</TT>, <TT>level</TT>, <TT>created</TT> 및 <TT>nVolumes</TT>로 레이블이
지정된 필드에서는 <B>-id</B> 인수만 제공될 때 출력의
첫번째 행에 표시되는 것과(순서는 다르지만) 같은 값을 표시합니다.
백업 운용자가 관심있어 할 수 있는 다른 필드는 다음과 같습니다.
<P>
<DL>
<P><DT><B><TT>maxTapes</TT>
</B><DD>이 덤프가 속하는 덤프 세트가 포함되는 테이프 수.
<P><DT><B><TT>Start Tape Seq</TT>
</B><DD>덤프 세트가 포함되는 테이프 세트에서 이 덤프가 시작되는
테이프의 순위.
</DL>
</LI><LI>이 덤프의 데이터가 들어있는 각 테이프의 경우, 밑줄친
<TT>Tape</TT> 문자열이 표제인 섹션 다음에 옵니다. <TT>name</TT>,
<TT>written</TT> 및 <TT>nVolumes</TT>로 레이블이 지정된
필드에서는 <B>-id</B> 인수만 제공될 때 출력의
세 번째 행에 표시되는 것과(순서는 다르지만) 같은 값을 표시합니다. 백업
운용자가 관심있어 할 수 있는 다른 필드는 다음과 같습니다.
<P>
<DL>
<P><DT><B><TT>expires</TT>
</B><DD>이 테이프를 다시 사용할 수 있는 날짜와 시간. 포함된 모든
덤프기 만기되었기 때문입니다.
<P><DT><B><TT>nMBytes Data</TT> and <TT>nBytes Data</TT>
</B><DD>함께 합계되며, 이들 필드는 실제로 볼륨에서 덤프된 데이터의
총 양을 나타냅니다(레이블, 파일표시 및 기타 표시자와는 반대임).
<P><DT><B><TT>KBytes Tape Used</TT>
</B><DD>덤프 데이터를 저장하는 데 사용된 테이프의 킬로바이트 수(백업 데이터 파일의 경우는 디스크 공간). 이것은 보통 <TT>nMBytes
Data</TT>와 <TT>nBytes Data</TT> 필드에 있는 값의 합계보다 큽니다.
여기에는 레이블, 파일 표시 및 기타 표시자에 필요한 공간이 포함되기
때문이며, 제공된 블록에 있는 데이터가 16KB 전체를 채우지 못하더라도 백업
시스템이 16KB 오프셋에서 데이터를 기록하기 때문입니다.
</DL>
</LI><LI>제공된 테이프에 있는 각 볼륨의 경우, 밑줄친
<TT>Volume</TT> 문자열이 표제인 섹션 다음에 옵니다.
<TT>name</TT>, <TT>position</TT>, <TT>clone</TT> 및
<TT>nBytes</TT>로 레이블이 지정된 필드에서는
<B>-id</B> 인수만 제공될 때 각 테이프에 있는 볼륨을
나열하는 테이블에 표시되는 것과(순서는 다르지만) 같은
값을 표시합니다.
백업 운용자가 관심있어 할 수 있는 다른 필드는 다음과 같습니다.
<P>
<DL>
<P><DT><B><TT>id</TT>
</B><DD>볼륨 ID.
<P><DT><B><TT>tape</TT>
</B><DD>이 볼륨 데이터가 들어있는 테이프 이름.
</DL>
</LI></UL>
<P>다음 예 명령에서는 가장 최근의 5개 덤프 동작에 대한 백업 데이터베이스
레코드를 표시합니다.
<PRE>   % <B>backup dump 5</B>
      dumpid   parentid lv created          nt nvols dump name
   924424000          0 0  04/18/1999 04:26  1    22 usr.sun (924424000)
   924685000  924424000 1  04/21/1999 04:56  1    62 usr.wed (924424000)
   924773000  924424000 1  04/22/1999 05:23  1    46 usr.thu (924424000)
   924860000  924424000 1  04/23/1999 05:33  1    58 usr.fri (924424000)
   925033000          0 0  04/25/1999 05:36  2    73 sys.week
</PRE>
<A NAME="IDX7040"></A>
<A NAME="IDX7041"></A>
<A NAME="IDX7042"></A>
<A NAME="IDX7043"></A>
<P><H3><A NAME="HDRWQ304" HREF="auagd002.htm#ToC_341">볼륨의 덤프 히스토리 표시하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에
나열된 사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>backup volinfo</B> 명령을 실행하여 볼륨의 덤프
히스토리를 표시하십시오.
<P>
<PRE>   % <B>backup volinfo</B> &lt;<VAR>volume&nbsp;name</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>voli
</B><DD><B>volinfo</B>의 축약형입니다.
<P><DT><B><VAR>volume name</VAR>
</B><DD>덤프 히스토리를 표시할 볼륨의 이름입니다. 백업 또는 읽기 전용
버전의 볼륨을 덤프했으면, <B>.backup</B> 또는
<B>.readonly</B> 확장자를 삽입하십시오.
</DL>
</LI></OL>
<P>출력에는 가장 최근의 것에서 부터 오래된 것의 순으로 지정된 볼륨에
대해 설명하는 백업 데이터베이스 덤프 레코드에 대한 각 행이
포함됩니다. 각 레코드의 출력은 6개 컬럼을 가진 테이블에 나타납니다.
<DL>
<P><DT><B><TT>dumpID</TT>
</B><DD>볼륨이 포함되는 덤프의 덤프 ID.
<P><DT><B><TT>lvl</TT>
</B><DD>볼륨이 덤프되었던 덤프 계층에서의 덤프 레벨 깊이. <TT>0</TT>
값은 전체 덤프를 나타냅니다. <TT>1</TT> 이상의 값은 덤프 계층에서
지정된 레벨에 작성된 증분 덤프를 나타냅니다.
<P><DT><B><TT>parentid</TT>
</B><DD>덤프의 상위 덤프의 덤프 ID. <TT>0</TT> 값은 상위가 없는 전체
덤프를 나타내며, 이 경우 <TT>lvl</TT> 컬럼에 있는 값도 <TT>0</TT>입니다.
<P><DT><B><TT>creation date</TT>
</B><DD>백업 시스템이 덤프를 작성한 덤프 동작을 시작했던 날짜와 시간.
<P><DT><B><TT>clone date</TT>
</B><DD>백업 또는 읽기 전용 볼륨의 경우, 읽기/쓰기 소스에서 복제된 시간.
읽기/쓰기 볼륨의 경우, <TT>creation date</TT> 필드값과 같습니다.
<P><DT><B><TT>tape name</TT>
</B><DD>덤프가 포함된 테이프 이름. 영구적 이름이거나 <I>volume_set_name</I>.<I>dump_level_name</I>.<I>tape_index</I> 형식으로 된 AFS 테이프 이름입니다. 여기서
<I>volume_set_name</I>은 이 테이프가 한 파트인 덤프
세트에 있는 초기 덤프와 연관된 볼륨 세트의 이름이며,
<I>dump_level_name</I>은 초기 덤프가 백업되었던 덤프
레벨의 이름이며, <I>tape_index</I>는 덤프 세트에서
테이프의 순서입니다. 어느 유형의 이름이든 다음에는 괄호로 묶인 덤프
ID가 올 수 있습니다. 그런 경우, 이것은 이 추가 덤프가 속하는 덤프
세트내의 초기 덤프의 덤프 ID입니다.
</DL>
<P>다음 예에서는 백업 볼륨 <B>user.smith.backup</B>의
덤프 히스토리 일부를 보여줍니다.
<PRE>   %<B> backup volinfo user.smith.backup</B>
   DumpID    lvl parentID  creation   date  clone date       tape name
   924600000 1   924427600 04/20/1999 05:20 04/20/1999 05:01 user_incr_2 (924514392)
   924514392 1   924427600 04/19/1999 05:33 04/19/1999 05:08 user_incr_2 
   924427600 0           0 04/18/1999 05:26 04/18/1999 04:58 user_full_6 
       .     .      .         .       .       .      .         .
       .     .      .         .       .       .      .         .
</PRE>
<A NAME="IDX7044"></A>
<A NAME="IDX7045"></A>
<A NAME="IDX7046"></A>
<A NAME="IDX7047"></A>
<A NAME="IDX7048"></A>
<P><H3><A NAME="HDRWQ305" HREF="auagd002.htm#ToC_342">테이프 내용 검색하기</A></H3>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">손상된 테이프를 검색하는 기능은 손상 정도와, 손상된 데이터
유형에 따라 달라집니다. 백업 시스템은 거의 항상 손상 부분까지
성공적으로 테이프를 검색할 수 있습니다. 손상이 미미한 경우, 백업
시스템은 이를 건너뛰고 나머지 테이프를 검색할 수 있지만, 손상이 좀 더
심각하면 더 이상 검색할 수 없습니다.
검색 동작이 덤프 세트에 있는 첫번째 테이프에서부터 시작할 필요는
없지만, 백업 시스템은 제공된 초기 테이프 이후 순서대로만 테이프들을
처리할 수 있습니다. 그러므로, 한 테이프가 손상되면 덤프 세트에 있는
다른 테이프를 검색할 수 었지만 손상된 부분 앞에 있는 테이프나 뒤에
있는 테이프는 검색할 수 있습니다.
<P>
<P><B>-dbadd</B> 플래그를 사용하여 백업 데이터베이스
정보를 검색하고 제공한 첫번째 테이프가 덤프 세트에 있는 첫번째
테이프가 아닌 경우, 다음 제한사항이 적용됩니다.
<UL>
<LI>테이프에 있는 첫번째 데이터가 덤프 세트에 있는 이전(검색되지
않은) 테이프에서 시작된 볼륨의 연속인 경우, 백업 시스템은
해당 볼륨의 레코드를 백업 데이터베이스에 추가하지 않습니다.
</LI><LI>백업 시스템은 추가된 덤프의 시작을 나타내는 표시자를 읽고 이 안에
있는 볼륨의 데이터베이스 레코드들을 추가해야 합니다. 테이프에 있는
첫번째 볼륨이 추가 덤프에 속하지만 바로 앞에 추가 덤프 표시자가
없으면, 백업 시스템은 이 볼륨 또는 추가 덤프에 속하는 이후 볼륨에
대한 백업 데이터베이스 레코드를 작성하지 않습니다.
</LI></UL>
</TD></TR></TABLE>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
</LI><LI>테이프를 검색하는 경우는 드라이브에 테이프를 넣으십시오.
</LI><LI><B>(선택적)</B> <B>backup</B>
명령을 실행하여 대화식 모드가 되도록 하십시오.
<P>
<PRE>   % <B>backup</B>
</PRE>
<A NAME="IDX7049"></A>
<A NAME="IDX7050"></A>
</LI><LI><B>backup scantape</B> 명령을 실행하여 테이프
내용을 읽으십시오.
<P>
<PRE>   backup> <B>scantape</B> [<B>-dbadd</B>] [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sc
</B><DD><B>scantape</B>의 축약형입니다.
<P><DT><B>-dbadd
</B><DD>덤프에 있는 테이프와 덤프 레이블에서 덤프와 테이프 레코드를
생성하고 이를 백업 데이터베이스에 기록합니다.
<P><DT><B><VAR>TC port offset</VAR>
</B><DD>동작을 처리하는 테이프 조정자 프로세스의 포트 오프셋 번호를
지정합니다. 기본값 0이 적합하지 않으면 이 인수를 제공해야 합니다.
</DL>
</LI><LI><B>butc</B> 명령을 실행할 때
<B>-noautoquery</B> 플래그를 삽입하지 않았거나 장치의
<B>CFG_</B><VAR>device_name</VAR> 구성 파일에
<B>AUTOQUERY YES</B> 명령이 들어있는 경우, 테이프
조정자는 장치 드라이브에 테이프를 넣도록 합니다. 이미 수행있으면,
<B>&lt;Return></B>을 눌러 테이프를 읽을 준비가 되었음을
나타내어야 합니다
</LI></OL>
<P>테이프 검색 동작을 종료하려면, &lt;<B>Ctrl-c</B>>와
같은 종료 신호를 사용하거나 대화식 모드에서 <B>(backup)
kill</B> 명령을 실행하십시오. <B>-dbadd</B>
인수가 포함된 경우 검색을 인터럽트하지 않는 것이 좋습니다. 백업
시스템이 새로운 레코드를 이미 백업 데이터베이스에 기록한 경우,
검색 동작을 다시 수행하기 전에 이를 제거해야 합니다. 반복되는 검색
동작 중 백업 시스템이 작성하는 데 필요한 모든 레코드가 이미 존재함을
알게 되면, 동작을 정지합니다.
<P>테이프에 있는 덤프 각각에 대해, 테이프 조정자 창에 있는 출력에서는
각 볼륨 항목이 뒤에 오는 덤프 레이블을 표시합니다. 명령 창에는
아무것도 출력되지 않습니다. 덤프 레이블에는
<A HREF="auagd011.htm#HDRWQ272">테이프 레이블 기록 및 읽기</A>에서 설명한 것처럼 <B>backup
readlabel</B> 명령에서 표시한 테이프 레이블과 같은 필드가 있습니다.
그렇지 않으면 출력에 있는 필드에 대한 자세한 설명은 <I>AFS Administration Reference</I>의
내용을 참조하십시오.
<P>다음 예에서는 포트 오프셋 2이 있는 장치에서 테이프에 있는 덤프
레이블과 첫번째 볼륨 항목을 표시합니다.
<PRE>   % <B>backup scantape 2</B>
   -- Dump label --
   tape name = monthly_guest
   AFS tape name = guests.monthly.3
   creationTime =  Mon Feb  1 04:06:40 1999
   cell = abc.com
   size = 2150000 Kbytes
   dump path = /monthly
   dump id = 917860000
   useCount = 44
   -- End of dump label --
   -- volume --
   volume name: user.guest10.backup
   volume ID 1937573829
   dumpSetName: guests.monthly
   dumpID 917860000
   level 0
   parentID 0
   endTime 0
   clonedate Mon Feb  1 03:03:23 1999
</PRE>
<HR><H2><A NAME="HDRWQ306" HREF="auagd002.htm#ToC_343">데이터 복원 및 복구</A></H2>
<A NAME="IDX7051"></A>
<A NAME="IDX7052"></A>
<A NAME="IDX7053"></A>
<A NAME="IDX7054"></A>
<A NAME="IDX7055"></A>
<A NAME="IDX7056"></A>
<A NAME="IDX7057"></A>
<A NAME="IDX7058"></A>
<A NAME="IDX7059"></A>
<A NAME="IDX7060"></A>
<A NAME="IDX7061"></A>
<A NAME="IDX7062"></A>
<P>백업 목적은 데이터가 갑자기 유실되거나 제거될 때 데이터를 바로 과거
상태로 리턴시켜 복구할 수 있도록 하기 위한 것입니다. AFS 백업
시스템은 여러 볼륨을 복원하는 3가지 명령을 제공합니다.
<UL>
<LI>하나 이상의 볼륨들을 단일 사이트(AFS 파일 서버 시스템에 있는
파티션)로 복원하려면, <B>backup volrestore</B>
명령을 사용하십시오.
</LI><LI>볼륨 세트로서 정의된 하나 이상의 볼륨을 복원하려면
<B>backup volsetrestore</B> 명령을 사용하십시오.
</LI><LI>전체 파티션(즉, VLDB가 이에 상주하는 것으로 나열하는 볼륨 모두)을
복원하려면 <B>backup diskrestore</B> 명령을
사용하십시오.
</LI></UL>
<P>명령들은 제공하는 기능과, 이들이 필요로하는 요구조건이 다르므로 다른
목적에 적합합니다. 특정 복원 동작에 적합한 명령을 결정하려면,
이 소개의 <A HREF="#HDRWQ308">backup volrestore 명령 사용</A>, <A HREF="#HDRWQ310">backup diskrestore 명령 사용</A>
및 <A HREF="#HDRWQ312">backup volsetrestore 명령 사용</A>절을 참조하십시오.
<P><H3><A NAME="HDRWQ307" HREF="auagd002.htm#ToC_344">보다 효율적으로 복원 동작 작성하기</A></H3>
<P>다음 주석은 모든 유형의 복원 동작에 적용됩니다.
<UL>
<LI>백업 시스템은 볼륨의 가장 최근 전체 덤프를 복원하는 것으로 시작합니다.
후속 증분 덤프를 복원하고 난 뒤, 전체 덤프에 있는 데이터를
특히 볼륨의 변경 히스토리를 반복하며 변경합니다.
<B>backup diskrestore</B> 및 <B>backup volsetrestore</B> 명령들은 항상 전체 증분 덤프를 복원하며, 볼륨이 가장 최근의 증분
덤프 상태가 되도록 합니다. <B>backup volrestore</B>
명령을 사용하여 과거에 지정된 시점의 상태로 볼륨을 리턴할 수 있지만,
그 이후 수행된 증분 덤프에서 데이터를 복원하지는 않습니다.
</LI><LI>백업 시스템은 복원된 볼륨의 작성 날짜를 복원 동작 날짜와
시간으로 설정합니다. 작성 날짜는 <B>vos examine</B> 및
<B>vos listvol</B> 명령의 출력 화면에서 <TT>Creation</TT> 필드에 나타납니다.
</LI><LI>복원할 볼륨을 나타낼 때, 기본(읽기/쓰기) 이름을 지정하는 것이
가장 좋습니다. 이런 경우, 백업 시스템은 백업 데이터베이스에서
읽기/쓰기 또는 백업 버전의 볼륨 데이터가 들어있는 가장 최근의 덤프
세트를 탐색하고, 가장 최근의 전체 덤프에서 시작하여 그 볼륨의 덤프를
복원합니다. 볼륨 이름에 <B>.backup</B> 또는 <B>.readonly</B> 확장자를 삽입하면, 백업
시스템은 그 버전의 덤프만을 복원합니다. 그 버전에서 덤프된 데이터를
찾을 수 없는 경우, 다른 버전이 덤프되었더라도 복원을 수행할 수
없습니다.
</LI><LI>3개의 복원 명령에서는 <B>-n</B> 옵션을 인정하며,
이 옵션은 복원할 볼륨 목록과, 필요한 덤프가 들어있는 테이프 또는
백업 데이터 파일을 생성하지만, 실제로 데이터를 AFS 서버 파티션에
복원하지는 않습니다. 이 기능을 사용하면 복원 동작을 시작하기 전에
테이프를 함께 모을 수 있으며, 심지어 테이프 하나를 사용하는 경우
스태커 또는 주크 박스로 테이프를 미리 로드하기도 합니다.
</LI><LI>AFS 데이터를 테이프로 백업할 경우, 테이프 장치 모두가 호환되면
복원이 간단해집니다. 즉, 압축 비율이 동일하고 같은 유형의 테이프를
읽을 수 있음을 의미합니다(이 제안은 <A HREF="#HDRWQ297">백업 동작을 보다 효과적으로 작성하기</A>에
있으며, 데이터를 복원해야 하는 때까지는 속도가 너무 느려 구현할
수 없습니다). 데이터가 호환되지 않는 장치를 사용하여 백업된
경우라도 한번의 명령으로 여러 볼륨을 복원할 수 있습니다.
이것은 3개의 복원 명령 모두에서 <B>-portoffset</B>
인수는 여러 값을 승인하기 때문입니다. 그러나 백업 시스템은 각
볼륨의 전체 덤프를 복원할 때 나열된 첫번째 포트 오프셋을 사용하고,
각 볼륨의 레벨 1 증분 덤프를 복원할 때는 다음 포트 오프셋을 사용하는
식으로 사용합니다. 모든 볼륨의 전체 덤프를 작성할 때(그리고 각각의
증분 레벨에서도) 호환되는 테이프 장치를 사용하지 않았으면, 한번의
명령으로 여러 볼륨들을 복원할 수 없습니다.
<B>backup volrestore</B> 명령을 사용하여 한번에
하나의 볼륨을 복원하거나, 볼륨을 덤프할 때 사용했던 테이프 장치에
따라 볼륨을 그룹화하는 볼륨 세트를 정의한 뒤
<B>backup volsetrestore</B> 명령을 사용해야 합니다.
</LI><LI>복원 동작 중, 백업 시스템은 <A HREF="#HDRWQ298">덤프 프로세스에 대한 구성 선택사항의 영향</A>에서
설명한 바와 같이 덤프 동작에서와 같은 방식으로 관련
<B>CFG_</B><VAR>device_name</VAR> 구성 파일에 있는
명령을 사용합니다.
덤프 동작에서처럼 <B>MOUNT</B>,
<B>UNMOUNT</B>, <B>AUTOQUERY</B>,
<B>BUFFERSIZE</B> 및 <B>FILE</B> 명령을 사용합니다. <B>BUFFERSIZE</B>
명령에서의 차이점은 명령이 겹쳐쓰기하는 기본 버퍼 크기가 복원
동작에서는 32KB인 반면, 덤프 동작에서는 16KB이라는 것입니다.
백업 시스템은 복원 동작을 수행하는 동안 <B>NAME_CHECK</B> 명령을 전혀 사용하지 않습니다. <B>ASK</B> 명령은 백업 시스템이 어떤 이유로든 볼륨을 복원할 수 없는
경우 사용자에게 프롬프트를 표시할 것인 지 여부를 제어합니다.
설정값이 <B>NO</B>이면, 문제가 있는 볼륨을
건너뛰고 가능한 많은 다른 볼륨을 복원합니다.
</LI><LI>백업 시스템이 볼륨이나 VLDB에 액세스할 수 없도록 하는 네트워크,
시스템 또는 서버 프로세스 문제점이 발견되면 복원 동작을
수행하지 마십시오. 백업 시스템이 볼륨을 복원하도록 자동
시도하더라도, 복원 동작은 시간이 걸리고 어떤 경우는 계속할 수 있는
방법에 대한 지시를 프롬프트하기 위해 완전히 정지하기도 합니다.
</LI><LI>복원 동작이 정지하지 않도록 합니다(예를 들어 대화식 모드에서
<B>(backup) kill</B> 명령을 실행하여). 복원 동작이
제어를 벗어난 원인을 포함하여 어떤 이유로 인터럽트되면, 가능한 빨리
실제에서와 같은 복원 명령을 다시 실행하십시오. 부족 또는 기타
문제점으로 인해 동작이 정지되면, 시스템이 정상으로 리턴할 때 까지
계속하지 마십시오.
<P>
<P>동작이 정지될 때 완전히 복원된 볼륨은 온라인으로 사용할 수 있지만,
이 상태에 있는 것은 아주 소수입니다.
한번에 여러 볼륨을 복원할 때, 백업 시스템은 이들에 대한 레벨 1 증분
복원을 시작하기 전에 모든 볼륨의 전체 덤프를 복원합니다. 이때 다음
증분 레벨에서 데이터를 복원하기 전에 특정 증분 레벨에서 모든 볼륨의
볼륨을 완료합니다. 같은 동작의 상위로서 자주 사용되는 다른 레벨 보다
적은 증분 레벨에서 볼륨을 덤프하는 경우를 제외하면, 완료하기 어렵습니다.
<P>
<P>볼륨의 현재 내용을 겹쳐쓰기하는 경우 복원 동작을 인터럽트하는 것은
위험합니다. 복원 동작이 진행된 정도에 따라, 백업 시스템이 이 전체를
제거하는 그러한 불완전한 상태에 볼륨이 있을 수 있습니다. 복원되는
데이터는 계속 테이프나 백업 데이터 파일에서 사용할 수 있지만, 볼륨을
다시 작성하려면 다른 단계를 수행해야 합니다.
</LI></UL>
<P><H3><A NAME="HDRWQ308" HREF="auagd002.htm#ToC_345">backup volrestore 명령 사용</A></H3>
<A NAME="IDX7063"></A>
<A NAME="IDX7064"></A>
<A NAME="IDX7065"></A>
<A NAME="IDX7066"></A>
<A NAME="IDX7067"></A>
<A NAME="IDX7068"></A>
<P><B>backup volrestore</B> 명령은 단일 사이트로 소수
파티션을 복원해야 하는 경우(파일 서버 시스템의 파티션에서) 가장
적합합니다. 기본적으로, 가장 최근의 덤프 동작 상태로 볼륨을
복원합니다(이를 <I>전체 복원</I>이라고 함). 또한
명령을 사용하여 <I>날짜 지정 복원</I>을 수행할 수도
있습니다. 이것은 지정된 날짜와 시간 이전에 수행된 덤프(전체 및
증분)만을 복원하며, 최종 관련 증분 덤프시 상태로 볼륨을 유지합니다.
<B>backup diskrestore</B> 및 <B>backup
volsetrestore</B> 명령들은 전체 복원만을 수행합니다.
<P><B>-extension</B> 인수를 포함시켜, 현재 버전을
겹쳐쓰기하는 대신 각 볼륨의 새로운 사본으로 데이터를 복원할 수 있습니다.
파일공간에서 새로운 볼륨을 마운트한 다음에는 두 내용을 비교하고
영구적으로 유지할 내용을 선택할 수 있습니다.
<P>다음 목록에서는 <B>backup volrestore</B> 명령의 인수들을
결합하여 다른 방식으로 볼륨을 복원하는 방법을 요약합니다.
<UL>
<LI>이전에 설명한 것처럼 날짜 지정 복원을 수행하려면,
<B>-date</B> 인수를 사용하여 날짜 및 선택적으로
시간을 지정하십시오. 백업 시스템은 가장 최근의 전체 덤프와 덤프에
포함된 볼륨의 클론 날짜가 표시된 날짜 및 시간보다 이전인 후속 증분
덤프를 복원합니다(클론 날짜 정의에 대해서는 <A HREF="#HDRWQ298">덤프 프로세스에 대한 구성 선택사항의 영향</A>에
있는 <A HREF="#LIBKOV-CLONEDATE">4</A> 단계를 참조하십시오).
이 인수를 <B>-extension</B> 인수와 결합시켜 날짜 지정
복원을 새로운 볼륨에 둘 수 있습니다.
</LI><LI>복원된 데이터로 볼륨 내용을 겹쳐쓰기하자 마자 새로운 사이트로
볼륨을 이동하려면, <B>-server</B>와 <B>-partition</B> 인수를 단독으로 또는 결합시켜 사용하여 현재 사이트
이외의 새로운 사이트를 지정하십시오. 백업 시스템은 그 사이트에서
새로운 볼륨을 작성하고, 기존 볼륨을 제거한 다음 볼륨의 VLDB 항목에서
사이트 정보를 갱신합니다. 볼륨의 백업 버전이 있으면 원래 사이트에서
자동으로 제거되지 않습니다. <B>vos remove</B> 명령을 사용하여 제거한 다음 <B>vos
backup</B> 명령을 사용하여 새로운 사이트에서 백업 버전을
작성하십시오.
</LI><LI>새로운 볼륨을 작성하여 복원된 데이터를 상주시키려면, 기존 볼륨을
겹쳐쓰기하는 대신 <B>-extension</B> 인수를 사용하십시오.
백업 시스템은 <B>-server</B> 및
<B>-partition</B> 인수에서 명명한 서버와 파티션에서
새로운 볼륨을 작성하고, <B>-volume</B> 인수로 지정된
이름에 확장자를 추가하여 그 이름을 생성한 뒤, 이에 대한 새로운 VLDB
항목을 작성합니다. 명령은 어느 방식으로든 기존 볼륨에 영향을 주지
않습니다. 그러나 지정된 확장자를 가진 볼륨이 이미 존재하면, 명령은
이를 겹쳐쓰기합니다.
새로운 볼륨 내용에 액세스할 수 있도록 하려면, <B>fs mkmount</B> 명령을 사용하여 마운트하십시오. 그런 다음 그 내용을
기존 볼륨 내용과 비교하고 영구적으로 유지할 내용을 알 수 있습니다.
</LI><LI>더 이상 AFS 서버 파티션에는 없지만 데이터를 백업하기 위한 볼륨을
복원하려면, <B>-volume</B> 인수로 새로운 볼륨 이름을
지정하고 <B>-server</B> 및
<B>-partition</B> 인수를 사용하여 이를 원하는 사이트에
두십시오. 백업 시스템은 새로운 볼륨과 새로운 VLDB 항목을 작성합니다.
</LI></UL>
<A NAME="IDX7069"></A>
<A NAME="IDX7070"></A>
<P><H3><A NAME="HDRWQ309" HREF="auagd002.htm#ToC_346">backup volrestore 명령으로 볼륨 복원하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
<P>
<P>하나 이상의 테이프 장치를 사용하는 경우 각 테이프 조정자에 대해
명령을 반복하십시오.
</LI><LI>테이프 장치를 사용하는 경우 테이프를 넣으십시오.
</LI><LI><B>backup</B> 명령을 실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   % <B>backup</B>
</PRE>
</LI><LI>원하는 인수와 함께 <B>backup volrestore</B>
명령을 실행하십시오.
<P>
<PRE>   backup> <B>volrestore</B> &lt;<VAR>destination&nbsp;machine</VAR>> &lt;<VAR>destination&nbsp;partition</VAR>>  \ 
                      <B>-volume</B> &lt;<VAR>volume(s)&nbsp;to&nbsp;restore</VAR>><SUP>+</SUP>  \
                      [<B>-extension</B> &lt;<VAR>new&nbsp;volume&nbsp;name&nbsp;extension</VAR>>]  \
                      [<B>-date</B> &lt;<VAR>date&nbsp;from&nbsp;which&nbsp;to&nbsp;restore</VAR>>]  \
                      [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offsets</VAR>><SUP>+</SUP>] [<B>-n</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>volr
</B><DD><B>volrestore</B>의 축약형입니다.
<P><DT><B><VAR>destination machine</VAR>
</B><DD>각 볼륨을 복원할 파일 서버 시스템 이름입니다. 볼륨의 현재
사이트가 아니어도 됩니다.
<P><DT><B><VAR>destination partition</VAR>
</B><DD>각 볼륨을 복원할 파티션 이름입니다. 볼륨의 현재 사이트가
아니어도 됩니다.
<P><DT><B>-volume
</B><DD>복원할 각 볼륨의 이름입니다. <A HREF="#HDRWQ307">보다 효율적으로 복원 동작 작성하기</A>에서
설명한 이유로 기본(읽기/쓰기) 이름을 입력하는 것이 좋습니다.
<P><DT><B>-extension
</B><DD>복원된 데이터가 상주할 새로운 볼륨을 작성하며, 그 이름은
지정된 문자열을 <B>-volume</B> 확장자가 명명한 각
볼륨에 추가하여 생성합니다. 백업 시스템은 기존 볼륨이 있는 경우
그 내용을 유지합니다. <B>.readonly</B> 또는 <B>.backup</B> 확장자 중 어느 것도
사용하지 마십시오. 기본 볼륨 이름과 확장자 결합은 최대 22자를 초과할
수 없습니다. 점으로 이름과 확장자를 구분하려면, 문자열의 첫 문자로
이를 지정하십시오(예를 들면 <B>.rst</B>에서 처럼).
<P><DT><B>-date
</B><DD>날짜와 선택적으로 시간을 지정합니다. 복원된 볼륨에는 그 날짜
이전에 수행된 덤프의 데이터만이 포함됩니다.
<I>mm</I>/<I>dd</I>/<I>yyyy</I> [<I>hh</I>:<I>MM</I>]
형식으로 값을 제공합니다. 여기서 필수적인
<I>mm/dd/yyyy</I> 부분은 월(<I>mm</I>), 일(<I>dd</I>) 및 연(<I>yyyy</I>)을 나타내며, 그리고 선택적인 <I>hh:MM</I>
부분에서는 24시간 형식으로 시간과 분을 나타냅니다(예를 들어
<B>14:36</B> 값은 오후 2:36을 나타냅니다). 이것이
생략되면, 시간의 기본값은 자정 이후 59초(00:00:59 시)입니다.
<P>
<P>유효한 연 값 범위는 <B>1970</B> - <B>2037</B>이며,
그보다 높은 값은 표준 UNIX 표현에 있는 가장 큰 날짜가 2038년 1월이므로
유효하지 않습니다. 명령 해석기를 최대 날짜를 최대값으로 자동 감소시킵니다.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">명령의 구문 명령문에서 이 인수 다음에는 플러스 기호가 오며,
이것은 다른 분리문자나 큰 따옴표로 묶지 않아도 되는 여러 단어 값을
사용할 수 있기 때문이며, 여러 날짜를 사용하기 때문은 아닙니다.
하나의 날짜(그리고 선택적으로 시간) 정의를 입력합니다.
</TD></TR></TABLE>
<P><DT><B>-portoffset
</B><DD>하나 이상의 포트 오프셋 번호를 지정하며, 각각은 동작에 사용할
테이프 조정자에 해당됩니다. 하나 이상의 값이 있으면, 백업 시스템은
각 볼륨의 전체 덤프를 복원할 때 첫번째 값을, 각 볼륨의 레벨 1 증분
덤프를 복원할 때 두 번째 값을, 이런 식으로 사용합니다. 덤프 계층에서
해당 깊이에 있는 덤프와 그 하위 레벨에 있는 모든 덤프를 복원할 때
목록에 있는 마지막 값을 사용합니다.
<P>
<P>모든 덤프에 기본값 0이 적합하지 않으면 이 인수를 제공해야 합니다.
0이 목록에 있는 값 중 하나인 경우, 해당 순서에서 명시적으로 이를
입력하십시오.
<P><DT><B>-n
</B><DD>복원 동작에 필요한 덤프가 들어있는 테이프 목록을 표시하며,
실제로 동작을 수행하지는 않습니다.
</DL>
</LI><LI><B>butc</B> 명령을 실행할 때
<B>-noautoquery</B> 플래그를 삽입하지 않았거나 장치의
<B>CFG_</B><VAR>device_name</VAR> 구성 파일에
<B>AUTOQUERY YES</B> 명령이 들어있는 경우, 테이프
조정자는 장치 드라이브에 테이프를 넣도록 합니다. 이미 테이프를
넣었으면, &lt;<B>Return</B>>을 눌러 레이블링 준비가 되었음을
나타내어야 합니다.
<P>
<P>여러 테이프가 필요하면, <B>MOUNT</B> 명령문을
<B>CFG_</B><VAR>device_name</VAR> 파일에 삽입한 다음
해당 스태커나 주크 박스를 테이프로 채우거나, 아니면 콘솔에 남아 후속 테이프에
대한 테이프 조정자 프롬프트에 반응해야 합니다.
</LI><LI>복원 동작이 완료되면, 오류가 있는 지 백업 시스템의 로그 파일을
검토하십시오. <A HREF="auagd009.htm#HDRWQ173">서버 프로세스 로그 파일 표시</A>에서 설명한 바와 같이
<B>bos getlog</B> 명령을 사용하여 <B>/usr/afs/logs/BackupLog</B> 파일을 읽고, 테이프 조정자
시스템에서는 문서 편집기를 사용하여 로컬 <B>/usr/afs/backup</B> 디렉토리에 있는 <B>TE_</B><VAR>device_name</VAR> 및
<B>TL_</B><VAR>device_name</VAR> 파일들을 읽으십시오.
</LI></OL>
<P><H3><A NAME="HDRWQ310" HREF="auagd002.htm#ToC_347">backup diskrestore 명령 사용</A></H3>
<A NAME="IDX7071"></A>
<A NAME="IDX7072"></A>
<P><B>backup diskrestore</B> 명령은 아마도 하드웨어 장애로 데이터
모두가 손상 또는 유실되었기 때문에 AFS 서버 파티션에
있는 모든 볼륨을 복원해야 할 경우 가장 적합합니다. 명령은 VLDB가 현재
사이트로서 지정된 파티션을 나열하는 읽기/쓰기 볼륨 모두의 전체 복원을
수행하며, 가장 최근에 덤프한 유형에 따라 각 볼륨의 읽기/쓰기 또는
백업 버전의 덤프를 사용합니다(<B>backup diskrestore</B> 동작이 완료한 뒤 <B>vos backup</B>
및 <B>vos release</B> 명령을 사용하여 파티션에
상주하는 백업 또는 읽기 전용 볼륨을 복원할 수 있습니다).
<P>기본적으로, 백업 시스템은 이전에 있었던 사이트로 볼륨을 복원합니다.
파티션 내용을 다른 사이트로 이동시키려면
<B>-newserver</B> 및
<B>-newpartition</B> 인수를 단독으로 또는 결합하여
사용하십시오.
<P>기본적으로 백업 시스템은 복원된 데이터로 기존 볼륨의 내용을
겹쳐쓰기합니다. 새로운 볼륨을 작성하여 복원된 데이터를 대신
상주시키려면, <B>-extension</B> 인수를 사용하십시오.
백업 시스템은 <B>-newserver</B> 및
<B>-newpartition</B> 인수가 사용되었으면 이 인수들이
지정했던 사이트에서, 그렇지 않으면 <B>-server</B> 및
<B>-partition</B> 인수가 지정하는 사이트에서 새로운
볼륨을 작성합니다. VLDB에 나열된 읽기/쓰기 기본 이름에 확장자를
추가하여 볼륨 이름을 생성하고, 새로운 VLDB 항목을 작성합니다. 명령은
어느 방식으로든 기존 볼륨에 영향을 주지않습니다. 그러나 지정된
확장자를 가진 볼륨이 이미 존재하면, 명령은 이를 겹쳐쓰기합니다.
<P>파티션이 손상된 것같으면, <B>backup diskrestore</B>
명령을 실행하기 전에 <B>vos syncserv</B> 명령을
실행하지 않도록 하십시오.
설명한 바와 같이 백업 시스템은 VLDB 사이트 정의에 따라 볼륨들을
복원합니다. <B>vos syncserv</B> 명령은 파티션의
손상 정도가 너무 심각하여 볼륨 서버가 볼륨을 유지여부를 확실할 수
없을 때 볼륨의 VLDB 항목을 제거하기도 합니다.
<A NAME="IDX7073"></A>
<A NAME="IDX7074"></A>
<P><H3><A NAME="HDRWQ311" HREF="auagd002.htm#ToC_348">backup diskrestore 명령으로 파티션 복원하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
<P>
<P>하나 이상의 테이프 장치를 사용하는 경우 각 테이프 조정자에 대해 명령을
반복하십시오.
</LI><LI>테이프 장치를 사용하는 경우 테이프를 넣으십시오.
</LI><LI><B>backup</B> 명령을 실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   % <B>backup</B>
</PRE>
</LI><LI>원하는 인수와 함께 <B>backup diskrestore</B>
명령을 실행하십시오.
<P>
<PRE>   backup> <B>diskrestore</B> &lt;<VAR>machine&nbsp;to&nbsp;restore</VAR>> &lt;<VAR>partition&nbsp;to&nbsp;restore</VAR>>  \
                       [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>><SUP>+</SUP>]  \
                       [<B>-newserver</B> &lt;<VAR>destination&nbsp;machine</VAR>>]  \
                       [<B>-newpartition</B> &lt;<VAR>destination&nbsp;partition</VAR>>]  \
                       [<B>-extension</B> &lt;<VAR>new&nbsp;volume&nbsp;name&nbsp;extension</VAR>>] [<B>-n</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>di
</B><DD><B>diskrestore</B>의 축약형입니다.
<P><DT><B><VAR>machine to restore</VAR>
</B><DD>복원해야 하는 볼륨의 사이트로서 VLDB가 나열하는 파일 서버
시스템의 이름입니다.
<P><DT><B><VAR>partition to restore</VAR>
</B><DD>복원해야 하는 볼륨의 사이트로서 VLDB가 나열하는 파티션 이름입니다.
<P><DT><B>-portoffset
</B><DD>하나 이상의 포트 오프셋 번호를 지정하며, 각각은 동작에 사용할
테이프 조정자에 해당됩니다. 하나 이상의 값이 있으면, 백업 시스템은 각
볼륨의 전체 덤프를 복원할 때 첫번째 값을, 각 볼륨의 레벨 1 증분 덤프를
복원할 때 두 번째 값을, 이런 식으로 사용합니다. 덤프 계층에서 해당
깊이에 있는 덤프와 그 하위 레벨에 있는 모든 덤프를 복원할 때 목록에
있는 마지막 값을 사용합니다.
<P>
<P>모든 덤프에 기본값 0이 적합하지 않으면 이 인수를 제공해야 합니다.
0이 목록에 있는 값 중 하나인 경우, 해당 순서에서 명시적으로 이를
입력하십시오.
<P><DT><B>-newserver
</B><DD>볼륨을 복원할 대체 파일 서버 시스템의 이름입니다. 이 인수를
생략하면, 볼륨은 <B>-server</B> 인수가 명명한 파일
서버 시스템으로 복원됩니다.
<P><DT><B>-newpartition
</B><DD>데이터를 복원할 대체 파티션의 이름입니다. 이 인수를 생략하면,
볼륨은 <B>-partition</B> 인수가 명명한 파티션으로
복원됩니다.
<P><DT><B>-extension
</B><DD>복원하는 각 볼륨에 새로운 볼륨을 작성하여 복원된 데이터를
상주시킵니다. 이 때 VLDB에서 나열된 것처럼 지정된 문자열을 볼륨의
읽기/쓰기 기본 이름에 추가합니다. <B>.readonly</B>
또는 <B>.backup</B> 이외의 문자열을 사용할 수 있지만,
기본 이름과 확장자 결합은 최대 22자를 초과할 수 없습니다. 점으로
이름과 확장자를 구분하려면, 이를 문자열의 첫번째 문자로
지정하십시오(예를 들어 <B>.rst</B>에서처럼).
<P><DT><B>-n
</B><DD>요청된 복원을 수행하는 데 필요한 테이프 목록을 표시합니다.
실제로 동작을 수행하지는 않습니다.
</DL>
</LI><LI><B>butc</B> 명령을 실행할 때
<B>-noautoquery</B> 플래그를 삽입하지 않았거나 장치의
<B>CFG_</B><VAR>device_name</VAR> 구성 파일에
<B>AUTOQUERY YES</B> 명령이 들어있는 경우, 테이프
조정자는 장치 드라이브에 테이프를 넣도록 합니다. 이미 테이프를
넣었으면, &lt;<B>Return</B>>을 눌러 레이블링 준비가
되었음을 나타내어야 합니다.
<P>
<P>여러 테이프가 필요하면, <B>MOUNT</B> 명령문을
<B>CFG_</B><VAR>device_name</VAR> 파일에 삽입한 다음 해당
스태커나 주크 박스를 테이프로 채우거나, 아니면 콘솔에 남아 후속
테이프에 대한 테이프 조정자 프롬프트에 반응해야 합니다.
</LI><LI>복원 동작이 완료되면, 오류가 있는 지 백업 시스템의 로그 파일을
검토하십시오. <A HREF="auagd009.htm#HDRWQ173">서버 프로세스 로그 파일 표시</A>에서 설명한 바와 같이
<B>bos getlog</B> 명령을 사용하여
<B>/usr/afs/logs/BackupLog</B> 파일을 읽고, 테이프
조정자 시스템에서는 문서 편집기를 사용하여 로컬
<B>/usr/afs/backup</B> 디렉토리에 있는
<B>TE_</B><VAR>device_name</VAR> 및
<B>TL_</B><VAR>device_name</VAR> 파일들을 읽으십시오.
</LI></OL>
<P><H3><A NAME="HDRWQ312" HREF="auagd002.htm#ToC_349">backup volsetrestore 명령 사용</A></H3>
<P><B>backup volsetrestore</B> 명령은 여러 읽기/쓰기
볼륨의 전체 복원을 수행해야 할 경우 가장 적합합니다. 이 볼륨들은
지정된 사이트에 위치합니다. <B>-name</B> 인수로 볼륨
세트의 이름을 지정하거나 다음 절에서 설명한 바와 같이
<B>-file</B> 인수가 명명한 파일에서 각 볼륨의 이름과
복원 상태를 나열하여 복원할 볼륨을 지정합니다.
<P><B>backup volsetrestore</B> 명령을 사용하면 한번의
명령으로 많은 수의 볼륨을 복원할 수 있으므로, 복원 동작을 완료하는
데에는 여러 시간이 소요될 수 있습니다. 시간을 줄이는 한가지 방법은
명령의 여러 인스턴스들을 동시에 실행하는 것입니다.
<B>-name</B> 인수를 사용하여 각 명령에서 해체 볼륨
세트를 지정하거나, <B>-file</B> 인수를 사용하여 다른
볼륨을 나열하는 파일의 이름을 지정하십시오. 필요한 테이프들을 읽는 데
여러 테이프 조정자들을 사용할 수 있어야 합니다. 복원되는 볼륨이
테이프로 덤프되는 방법에 따라, 해제된 볼륨 세트를 지정하면 필요한
테이프 교체 횟수를 줄일 수 있습니다.
<P><H4><A NAME="HDRWQ313">-name 인수로 볼륨 세트 복원하기</A></H4>
<P><B>-name</B> 인수를 사용하여 볼륨 세트에서 정의된
볼륨 그룹을 복원하십시오. 백업 시스템은 볼륨 세트의 볼륨 항목에서
정의된 서버, 파티션 및 볼륨 이름 기준에 맞는 볼륨 목록을 VLDB에서
작성하며, 이것의 덤프는 사용할 수 있습니다. VLDB가 계속 볼륨을
나열하는 동안 볼륨이 서버 파티션에 있을 필요는 없습니다(이것은
예를 들어 하드웨어 문제점으로 디스크 전체 내용이 손상될 때 발생할 수
있습니다).
<P>기본적으로 백업 시스템은 VLDB에 나열된 사이트의 볼륨 세트 기준에
맞는 각 볼륨을 읽기/쓰기 볼륨으로서 복원합니다. 대응되는 이름을 가진
볼륨이 그 사이트에 있으면, 현재 내용은 겹쳐쓰기됩니다. 대신
<B>-extension</B> 인수를 포함시켜 복원된 데이터가
들어갈 새로운 볼륨을 작성할 수 있습니다. 백업 시스템은 기존 볼륨의
사이트에서 새로운 볼륨을 작성하고, 기존 볼륨의 읽기/쓰기 기본 이름에
확장자를 추가하여 이름을 생성한 다음 이에 대한 새로운 VLDB 항목을
작성합니다. 명령은 어느 방식으로든 기존 볼륨에 영향을 주지 않습니다.
그러나 지정된 확장자를 가진 볼륨이 이미 존재하면, 명령은 이를
겹쳐쓰기합니다. 새로운 볼륨 내용에 액세스할 수 있도록 하려면, <B> fs mkmount</B> 명령을 사용하여 마운트하십시오. 그런
다음 그 내용을 기존 볼륨 내용과 비교하고 영구적으로 유지할 내용을
알 수 있습니다.
<P>볼륨 세트가 이전에 볼륨을 백업하는 데 사용될 필요는
없습니다(<B>-volumeset</B> 옵션으로서
<B>backup dump</B> 명령에서 사용될 필요는 없습니다).
특히 이 명령으로 복원해야 하는 볼륨을 대응시키기 위해 정의할 수
있습니다. 실제로, <B>backup addvolset</B> 명령에
<B>-temporary</B> 플래그를 포함시켜 작성한
<I>임시</I> 볼륨은 특히 이 컨텍스트(명령은
<A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>에 있음)에서 유용할 수 있습니다. 임시
볼륨 세트는 백업 데이터베이스로 추가되지 않고 현재 대화식 백업
세션 동안에만 존재합니다. 이 세션은 볼륨 세트가 이 명령으로 시작된
단일 복원 동작을 완료하는 데에만 필요한 경우 적합합니다.
<P>특별히 정의된 볼륨 세트가 보다 나은 이유는 덤프 동작에 사용하도록
미리 정의된 볼륨 세트는 주로 백업 버전의 볼륨과 대응되는 반면, 복원
동작의 경우는 기본(읽기/쓰기) 이름에 맞는 볼륨 항목을 정의하는 것이
가장 좋습니다. 이런 경우, 백업 시스템은 읽기/쓰기 또는 백업 버전
볼륨의 덤프가 들어있는 가장 최근의 덤프 세트를 백업 데이터베이스에서
탐색합니다. 반대로, 볼륨 항목이 명시적으로 볼륨의 백업 또는 읽기 전용
버전과 대응되면, 백업 시스템은 그 볼륨 버전의 덤프만을 사용하고,
<B>.backup</B> 또는 <B>.readonly</B>
확장자를 제거하여 이를 읽기/쓰기 볼륨으로 복원합니다.
<P>볼륨 세트 기준에 맞는 VLDB 항목이 있지만 백업 데이터베이스에 기록된
덤프가 없으므로, 백업 시스템은 이들을 복원할 수 없습니다. 각각에
대해 표준 오류 문자열에서 오류 메시지를 생성합니다.
<P><H4><A NAME="HDRWQ314">-file 인수로 파일에 나열된 볼륨 복원하기</A></H4>
<P><B>-file</B> 인수를 사용하여 복원할 각 읽기/쓰기
볼륨의 이름과 사이트를 지정하십시오. 각 볼륨 항목은 파일에서 자신의
행에 나타나야 하며, 형식은 다음과 같습니다.
<PRE>   <VAR>machine</VAR>    <VAR>partition</VAR>   <VAR>volume</VAR>    [<VAR>comments...</VAR>]
</PRE>
<P>여기서
<DL>
<P><DT><B><VAR>machine</VAR>
</B><DD>볼륨을 복원할 파일 서버 시스템의 이름입니다. 현재 사이트 이외의
시스템을 명명함으로써 이를 복원하자 마자 볼륨을 이동할 수 있습니다.
<P><DT><B><VAR>partition</VAR>
</B><DD>볼륨을 복원할 파티션의 이름입니다. 현재 사이트 이외의 파티션을
명명하면 이를 복원한 뒤 볼륨을 이동할 수 있습니다.
<P><DT><B><VAR>volume</VAR>
</B><DD>복원할 볼륨의 이름입니다. 읽기/쓰기 또는 백업 버전의 볼륨
덤프가 포함된 가장 최근의 덤프 세트에 대한 백업 데이터베이스를
백업 시스템에서 탐색하도록 기본(읽기/쓰기) 이름을 지정하십시오.
볼륨의 해당 버전 덤프를 복원하며, 가장 최근의 전체 덤프에서
시작합니다. 반대로 <TT>.backup</TT> 또는 <TT>.readonly</TT>
확장자가 포함되어 있는 경우, 백업 시스템은 해당 버전의 덤프를
복원하지만 확장자 없이 읽기/쓰기 볼륨으로 복원합니다. 기본 이름은
VLDB에 있는 이름 대신 백업 데이터베이스 덤프 레코드에 사용된 이름과
일치해야 하며, 다른 경우 백업 시스템은 <B>-file</B>
인수를 사용할 때 VLDB에게 조회하지 않습니다.
<P><DT><B><VAR>comments...</VAR>
</B><DD>기타 텍스트입니다. 백업 시스템은 볼륨 이름 다음에 오는 각 행의
텍스트는 무시하므로, 유용한 노트는 이 필드를 사용할 수 있습니다.
</DL>
<P><VAR>시스템</VAR>, <VAR>파티션</VAR> 또는 <VAR>볼륨</VAR> 필드에서는
와일드카드(예를 들면 <B>.*</B>)를 사용하지 마십시오.
파일에 있는 여러 행에서 같은 볼륨의 이름을 지정할 수 있지만, 백업
시스템은 이들 중 첫번째만을 처리합니다.
<P>기본적으로 백업 시스템은 각 볼륨의 기존 버전을 복원된 데이터로
대체하며, 이때 <VAR>시스템</VAR> 및 <VAR>파티션</VAR> 필드에서 지정한
사이트에 볼륨을 놓습니다. 대신 <B>-extension</B> 인수를 포함시켜 복원된 내용이 들어갈 새로운 볼륨을 작성할 수
있습니다. 백업 시스템은 <VAR>시스템</VAR> 및 <VAR>파티션</VAR> 필드에서
지정한 사이트에서 새로운 볼륨을 작성하고, <VAR>볼륨</VAR> 필드에 있는
이름의 읽기/쓰기 버전에 지정된 확장자를 추가하여 이름을 생성한 뒤,
이에 대한 새로운 VLDB 항목을 작성합니다. 명령은 어느 방식으로든
기존 볼륨에 영향을 주지 않습니다. 그러나 지정된 확장자를 가진 볼륨이
이미 존재하면, 명령은 이를 겹쳐쓰기합니다. 새로운 볼륨 내용에
액세스할 수 있도록 하려면, <B> fs mkmount</B> 명령을
사용하여 마운트하십시오. 그런 다음 그 내용을 기존 볼륨 내용과 비교하고
영구적으로 유지할 내용을 알 수 있습니다.
<P>백업 데이터베이스에 기록된 덤프가 없는 볼륨 항목이 파일에 들어 있는
경우, 포함 시스템은 이를 복원할 수 없습니다. 각각에 대해 표준 오류
문자열에서 오류 메시지를 생성합니다.
<P><B>-file</B> 인수에 대한 입력으로서 사용할 파일을
생성하는 한가지 방법은 <B>-name</B> 및
<B>-n</B> 옵션과 함께 명령을 실행하여 파일로 출력을
지정합니다. 출력에는 각 볼륨에 다음과 같은 행이 포함되며(여기서는
읽기 쉽도록 2행에서만 표시함), 값은 다음 목록에서 표시된 소스에서
추출한 것입니다.
<PRE>   <VAR>machine</VAR>   <VAR>partition</VAR>   <VAR>volume_dumped</VAR>  # as   <VAR>volume_restored</VAR>;    \
         <VAR>tape_name</VAR>   (<VAR>tape_ID</VAR>);   pos   <VAR>position_number</VAR>;   <VAR>date</VAR>
</PRE>
<P>여기서
<DL>
<P><DT><B><VAR>machine</VAR>
</B><DD>VLDB에 나열된 것처럼 현재 볼륨이 들어있는 파일 서버 시스템의
이름입니다.
<P><DT><B><VAR>partition</VAR>
</B><DD>VLDB에 나열된 것처럼 현재 볼륨이 들어있는 파티션의 이름입니다.
<P><DT><B><VAR>volume_dumped</VAR>
</B><DD>백업 데이터베이스에서 나열된 바와 같이, 덤프된 볼륨의 버전(읽기/
쓰기 또는 백업)을 지정합니다.
<P><DT><B><VAR>volume_restored</VAR>
</B><DD><B>-n</B> 플래그가 포함되지 않았을 경우 백업
시스템이 볼륨을 복원하는 이름을 지정합니다.
<B>-extension</B> 인수가 <B>-name</B>
및 <B>-n</B> 옵션에 포함되어 있으면, 확장자는 이
필드에 있는 이름에 표시됩니다(예를 들면 <TT>user.pat.rst</TT>에서처럼).
<P><DT><B><VAR>tape_name</VAR>
</B><DD>백업 데이터베이스에서 볼륨의 덤프가 들어있는 테이프 이름입니다.
테이프에 영구적 이름이 있으면, 그 이름도 표시됩니다. 이름이 없으면
이것은 AFS 테이프 이름입니다.
<P><DT><B><VAR>tape_ID</VAR>
</B><DD>백업 데이터베이스에서 볼륨의 덤프가 들어있는 테이프 ID입니다.
<P><DT><B><VAR>position_number</VAR>
</B><DD>테이프에서 덤프 위치를 지정합니다(예를 들어 <TT>31</TT>은
테이프에서 그 덤프 앞에 30개의 볼륨 덤프가 있음을 나타냅니다). 덤프가
백업 데이터 파일로 기록된 경우, 이 번호는 볼륨의 데이터가 시작되는
16KB 오프셋의 서수입니다.
<P><DT><B><VAR>date</VAR>
</B><DD>볼륨이 덤프된 날짜와 시간입니다.
</DL>
<P><B>-file</B> 인수와 함께 사용하기에 적합하도록
항목을 작성하려면, 표시된 대로 편집하십시오.
<UL>
<LI>백업 시스템은 입력 파일의 각 라인에 있는 처음 3 필드만을
사용하므로, 번호 사인(<TT>#</TT>) 다음에 있는 모든 필드들은 무시합니다.
제거하면 파일을 읽기가 쉬워지는 경우 제거할 수도 있지만, 제거하지 않아도 무방합니다.
</LI><LI>출력 파일에 있는 각 행의 <VAR>volume_dumped</VAR>(세 번째) 필드가
입력 파일에서는 <VAR>volume</VAR> 필드가 됩니다. 백업 시스템은 데이터를
읽기/쓰기 볼륨으로만 복원하므로, <TT>.backup</TT> 또는 <TT>.readonly</TT> 확장자가 <VAR>volume_dumped</VAR> 필드에 있는 이름에 표시되면 제거하십시오.
</LI><LI>출력 파일에는 특정 볼륨이 포함되었던 모든 덤프 동작 행에 관한
행도 포함되지만(전체 덤프 및 모든 증분 덤프), 백업 시스템은 특정
볼륨에 대해 설명하는 입력 파일의 첫번째 행만을 처리합니다. 반복되는
행을 제거하여 읽기 쉬워지면 이를 제거할 수도 있습니다.
</LI><LI>출력 행에 있는 <I>시스템</I> 및 <I>파티션</I> 필드에서는 볼륨의 현재 사이트를 지정합니다. 복원하면서
볼륨을 다른 위치로 이동하려면, 값을 변경하십시오.
</LI></UL>
<A NAME="IDX7075"></A>
<A NAME="IDX7076"></A>
<P><H3><A NAME="HDRWQ315" HREF="auagd002.htm#ToC_352">backup volsetrestore 명령으로 볼륨 그룹 복원하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
<P>
<P>하나 이상의 테이프 장치를 사용하는 경우 각 테이프 조정자에 대해
명령을 반복하십시오.
</LI><LI>테이프 장치를 사용하는 경우 테이프를 넣으십시오.
</LI><LI><B>backup</B> 명령을 실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   % <B>backup</B>
</PRE>
</LI><LI><B>(선택적)</B> 적합한 경우,
<B>(backup) addvolset</B> 명령을 실행하여 이 복원 동작에
대한 새로운 볼륨 세트를 작성하십시오. 볼륨 세트를 백업 데이터베이스에
추가하지 않아도 되면 <B>-temporary</B> 플래그를 포함하십시오.
그런 다음 하나 이상의 <B>(backup) addvolentry</B>
명령을 실행하여 복원할 볼륨만 들어있는 볼륨 항목을 작성하십시오.
완전한 명령은 <A HREF="auagd011.htm#HDRWQ265">볼륨 세트와 볼륨 항목의 정의 및 표시</A>에 있습니다.
<P>
<PRE>   backup> <B>addvolset</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>>  [<B>-temporary</B>]
   
   backup> <B>addvolentry  -name</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>>  \
                        <B>-server</B> &lt;<VAR>machine&nbsp;name</VAR>>  \
                        <B>-partition</B> &lt;<VAR>partition&nbsp;name</VAR>>  \
                        <B>-volumes</B> &lt;<VAR>volume&nbsp;name&nbsp;(regular&nbsp;expression)</VAR>>
</PRE>
</LI><LI>원하는 인수와 함께 <B>backup volsetrestore</B>
명령을 실행하십시오.
<P>
<PRE>   backup> <B>volsetrestore</B>
[<B>-name</B> &lt;<VAR>volume&nbsp;set&nbsp;name</VAR>>]  \
                 [<B>-file</B> &lt;<VAR>file&nbsp;name</VAR>>]  \
                 [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>><SUP>+</SUP>]  \
                 [<B>-extension</B> &lt;<VAR>new&nbsp;volume&nbsp;name&nbsp;extension</VAR>>] [<B>-n</B>] 
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>-name
</B><DD>복원할 볼륨 세트의 이름입니다. 백업 시스템은
<A HREF="#HDRWQ313">-name 인수로 볼륨 세트 복원하기</A>에서 설명한 것처럼 볼륨 세트의 볼륨
항목에 대응되는, VLDB에 나열된 모든 볼륨들을 복원합니다. 이 인수나
<B>-file</B> 인수 중 하나만을 포함하십시오.
<P><DT><B>-file
</B><DD>하나 이상의 볼륨을 나열하는 파일의 전체 경로 이름과, 각각을
복원할 사이트(파일 서버 시스템 및 파티션)를 지정합니다.
입력 파일의 형식은 <A HREF="#HDRWQ314">-file 인수로 파일에 나열된 볼륨 복원하기</A>에서 설명한 바와 같습니다.
이 인수나 <B>-name</B> 인수 중 하나만을 사용하십시오.
<P><DT><B><B>-portoffset</B>
</B><DD>하나 이상의 포트 오프셋 번호를 지정하며, 각각은 동작에 사용할
테이프 조정자에 해당됩니다. 하나 이상의 값이 있으면, 백업 시스템은 각
볼륨의 전체 덤프를 복원할 때 첫번째 값을, 각 볼륨의 레벨 1 증분
덤프를 복원할 때 두 번째 값을, 이런 식으로 사용합니다. 덤프 계층에서
해당 깊이에 있는 덤프와 그 하위 레벨에 있는 모든 덤프를 복원할 때
목록에 있는 마지막 값을 사용합니다.
<P>
<P>모든 덤프에 기본값 0이 적합하지 않으면 이 인수를 제공해야 합니다.
0이 목록에 있는 값 중 하나인 경우, 해당 순서에서 명시적으로 이를
입력하십시오.
<P><DT><B>-extension
</B><DD>복원하는 각 볼륨에 새로운 볼륨을 작성하여 복원된 데이터를
상주시킵니다. 이 때 VLDB에서 나열된 것처럼 지정된 문자열을 볼륨의 읽기/쓰기
기본 이름에 추가합니다. <B>.readonly</B> 또는 <B>.backup</B> 이외의 문자열을 사용할 수 있지만, 기본
이름과 확장자 결합은 최대 22자를 초과할 수 없습니다. 점으로 이름과
확장자를 구분하려면, 이를 문자열의 첫번째 문자로 지정하십시오(예를
들어 <B>.rst</B>에서 처럼).
<P><DT><B><B>-n</B>
</B><DD>플래그가 포함되지 않을 경우 복원할 볼륨 목록을 표시하지만,
실제로 복원하지는 않습니다. 이 참조 페이지의
<B>Output</B> 절에서는 출력 형식에 대해 자세히
설명합니다. <B>-name</B> 인수와 결합되면, 출력은
이후 <B>backup volsetrestore</B> 명령에서
<B>-file</B> 인수에 대한 입력으로서 사용되도록 쉽게
편집됩니다.
</DL>
</LI><LI><B>butc</B> 명령을 실행할 때
<B>-noautoquery</B> 플래그를 삽입하지 않았거나 장치의
<B>CFG_</B><VAR>device_name</VAR> 구성 파일에
<B>AUTOQUERY YES</B> 명령이 들어있는 경우, 테이프
조정자는 장치 드라이브에 테이프를 넣도록 합니다. 이미 테이프를
넣었으면, &lt;<B>Return</B>>을 눌러 레이블링 준비가
되었음을 나타내어야 합니다.
<P>
<P>여러 테이프가 필요하면, <B>MOUNT</B> 명령문을
<B>CFG_</B><VAR>device_name</VAR> 파일에 삽입한 다음
해당 스태커나 주크 박스를 테이프로 채우거나, 아니면 콘솔에 남아 후속
테이프에 대한 테이프 조정자 프롬프트에 반응해야 합니다.
</LI><LI>복원 동작이 완료되면, 오류가 있는 지 백업 시스템의 로그 파일을
검토하십시오. <A HREF="auagd009.htm#HDRWQ173">서버 프로세스 로그 파일 표시</A>에서 설명한 바와 같이
<B>bos getlog</B> 명령을 사용하여 <B>/usr/afs/logs/BackupLog</B> 파일을 읽고, 테이프 조정자
시스템에서는 문서 편집기를 사용하여 로컬 <B>/usr/afs/backup</B> 디렉토리에 있는 <B>TE_</B><VAR>device_name</VAR> 및
<B>TL_</B><VAR> device_name</VAR> 파일들을 읽으십시오.
</LI></OL>
<A NAME="IDX7077"></A>
<HR><H2><A NAME="HDRWQ316" HREF="auagd002.htm#ToC_353">백업 데이터베이스 유지</A></H2>
<P>백업 데이터베이스는 백업 시스템이 데이터를 덤프하고 복원할 때
사용하는 구성 및 추적 정보 모두를 저장합니다. 하드웨어 장애나
데이터베이스 서버 시스템상의 다른 문제점으로 인해 데이터베이스가
유실 또는 손상되면, 비교적 쉽게 구성 정보를 다시 작성할 수
있습니다(덤프 계층, 볼륨 세트 목록, 테이프 조정자 포트 오프셋 번호).
그러나 덤프 추적 정보(덤프 레코드)를 복원하면 복잡하고 시간이 많이
소요됩니다. 데이터를 잃지 않도록 하기 위해, 백업 데이터베이스 자체를
정기적으로 테이프에 백업하십시오.
<P>또다른 고려사항은 백업 데이터베이스가 너무 빠르게 커질 수 있다는
것입니다. 이는 백업 시스템이 덤프 동작에 대한 아주 자세하고 상호
참조적인 레코드들도 보존하기 때문입니다. 백업 동작은 백업 서버가
필요한 데이터를 찾기 위해 이제는 사용하지 않는 많은 레코드들을
탐색해야 하는 경우 효율이 떨어집니다. 데이터베이스가 관리가능한
크기를 유지하도록 하기 위해서는 <A HREF="#HDRWQ321">백업 데이터베이스에서 이전 레코드 제거</A>에서
처럼 <B>backup deletedump</B> 명령을 사용하여 사용하지
않는 레코드들을 삭제하십시오.
계속 필요한 레코드들을 삭제했음을 나중에 알게 되면,
<A HREF="#HDRWQ305">테이프 내용 검색하기</A>에서 처럼 <B>backup
scantape</B> 명령을 사용하여, 다시 데이터베이스로 돌아가 해당
테이프에 있는 덤프와 테이프 레이블 정보를 읽을 수 있습니다.
<A NAME="IDX7078"></A>
<A NAME="IDX7079"></A>
<A NAME="IDX7080"></A>
<A NAME="IDX7081"></A>
<A NAME="IDX7082"></A>
<P><H3><A NAME="HDRWQ317" HREF="auagd002.htm#ToC_354">백업 데이터베이스 백업 및 복원</A></H3>
<P>백업 데이터베이스에 있는 정보는 중요하므로, 정기적으로 테이프나 다른
영구적 매체로 백업하는 것이 가장 좋습니다.
다른 AFS 관리 데이터베이스에서 처럼, 권장하는 방법은 시스템의
로컬 디스크를 백업하도록 지정된 유틸리티(UNIX
<B>tar</B> 명령과 같은)를 사용하는 것입니다. 명령에
대해서는 <A HREF="auagd008.htm#HDRWQ107">관리 데이터베이스 백업 및 복원</A>의 내용을 참조하십시오.
<P>아주 드물지만 백업 데이터베이스가 손상 또는 유실된 것 같은 경우는
<B>backup dbverify</B> 명령을 사용하여 그 상태를
확인할 수 있습니다. 손상되었으면, <B>backup savedb</B>
명령을 사용하여 일부 유형의 손상을 보수하십시오. 그런 다음
<B>backup restoredb</B>를 사용하여 데이터베이스 서버
시스템의 로컬 디스크로 수정된 데이터베이스를 리턴하십시오. 그 명령에
해해서는 <A HREF="#HDRWQ318">백업 데이터베이스에서 손상 체크 및 복구</A>의 내용을 참조하십시오.
<P><H3><A NAME="HDRWQ318" HREF="auagd002.htm#ToC_355">백업 데이터베이스에서 손상 체크 및 복구</A></H3>
<P>아주 드문 경우이지만 백업 데이터베이스가 디스크 또는 다른 하드웨어
오류로 인해 손상 또는 훼손될 수 있습니다. <B>backup
dbverify</B> 명령을 사용하여 데이터베이스의 안정성을 체크하십시오.
손상되었으면, <B>backup savedb</B> 명령을 사용하여
데이터베이스를 테이프로 복사하여 복구하는 것이 가장 효과적인
방법입니다. 명령은 자동으로 여러 유형의 손상들을 복구하므로,
<B>backup restoredb</B> 명령을 사용하여 복구된
데이터베이스 사본을 데이터베이스 서버 시스템의 로컬 디스크로
전송할 수 있습니다.
<P><B>backup savedb</B> 명령은 <I>고립된
블록</I>도 제거하며, 이 블록은 백업 서버가 데이터베이스에 미리
할당했지만 사용할 수 없는 일정 범위의 메모리입니다. 고립된 블록은
데이터베이스 액세스에 방해되지 않지만 디스크 공간을 낭비합니다.
<B>backup dbverify</B> 명령은 <B>-detail</B> 플래그가 포함되는 경우 고립된 블록이 있음을 보고합니다.
<A NAME="IDX7083"></A>
<A NAME="IDX7084"></A>
<A NAME="IDX7085"></A>
<P><H3><A NAME="HDRWQ319" HREF="auagd002.htm#ToC_356">백업 데이터베이스 안정성 확인하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>backup dbverify</B> 명령을 실행하여 백업
데이터베이스의 안정성을 체크하십시오.
<P>
<PRE>   % <B>backup dbverify</B>
[<B>-detail</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>db
</B><DD><B>dbverify</B>의 축약형입니다.
<P><DT><B>-detail
</B><DD><I>AFS Administration Reference</I>에 있는 <B>backup dbverify</B> 참조
페이지에서 설명한 것처럼, 고립된 블록의 존재 유무와 데이터베이스에
대한 기타 정보를 알려줍니다.
</DL>
<P>
<P>출력에서는 다음 메시지 중 하나를 표시합니다.
<UL>
<LI><TT>Database OK</TT>는 백업 데이터베이스가 손상되지 않았음을
나타냅니다.
</LI><LI><TT>Database not OK</TT>는 백업 데이터베이스가 손상되었음을
나타냅니다.
문제점을 복구하려면 <A HREF="#HDRWQ320">백업 데이터베이스에서 손상 복구하기</A>에 있는 명령을
사용하십시오.
</LI></UL>
</LI></OL>
<A NAME="IDX7086"></A>
<A NAME="IDX7087"></A>
<P><H3><A NAME="HDRWQ320" HREF="auagd002.htm#ToC_357">백업 데이터베이스에서 손상 복구하기</A></H3>
<OL TYPE=1>
<LI>셀에 있는 각각의 데이터베이스 서버 시스템에서 로컬
수퍼유저 <B>루트</B>로서 로그인하십시오.
</LI><LI><A NAME="LISAVEDB-STARTTC"></A>동작을 수행할 테이프 장치에 대한 테이프 조정자가 아직 실행되고 있지
않으면, 해당 테이프 조정자에 연결하고, <B>butc</B>
명령을 실행하십시오. 이에 대한 완전한 명령은
<A HREF="#HDRWQ292">테이프 조정자 프로세스 시작하기</A>에 있습니다.
<P>
<PRE>   % <B>butc</B> [&lt;<VAR>port offset</VAR>>] [<B>-noautoquery</B>]
</PRE>
</LI><LI>테이프로 기록하는 경우, 해당 장치에 테이프를 넣으십시오.
</LI><LI>시스템 중 하나에서 작업하면서 <B>backup</B>
명령을 실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   # <B> backup -localauth</B>
</PRE>
<P>
<P>여기서 <B>-localauth</B>는 로컬
<B>/usr/afs/etc/KeyFile</B> 파일에서 서버 티켓을
생성합니다. 이 플래그를 사용하면 AFS 관리 토큰없이 로컬 수퍼유저
<B>루트</B>로서 로그인하는 동안 특권이 부여된
명령을 실행할 수 있습니다.
</LI><LI>실행중인 백업 동작이 없도록 하십시오. 필요하면,
<A HREF="#HDRWQ295">테이프 조정자 프로세스의 상태 확인하기</A>에서 처럼 <B>(backup)
status</B> 명령을 실행하십시오.
각 테이프 조정자 포트 오프셋을 교대로 반복하십시오.
<P>
<PRE>   backup>
<B>status -portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>
</PRE>
</LI><LI><A NAME="LISAVEDB-CMD"></A>테이프나 파일로 기록하자 마자
<B>(backup) savedb</B> 명령을 실행하여
데이터베이스내의 손상부분을 복구하십시오.
<P>
<PRE>   backup> <B>savedb</B> [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sa
</B><DD><B>savedb</B>의 축약형입니다.
<P><DT><B>-portoffset
</B><DD>이 동작을 위해 테이프나 백업 데이터 파일을 처리하는 테이프
조정자의 포트 오프셋 번호를 지정합니다. 기본값 0이 적합하지 않으면 이
인수를 제공해야 합니다.
</DL>
</LI><LI>대화식 모드를 종료하십시오.
<P>
<PRE>   backup>  <B>quit</B>  
</PRE>
</LI><LI>각 시스템에서 교대로 <B>bos shutdown</B>
명령을 실행하여 백업 서버 프로세스를 종료하십시오. 로컬 수퍼유저
루트로서 로그인했지만 관리 토큰을 가질 필요는 없으므로,
<B>-localauth</B> 플래그를 포함하십시오. 완전한
명령 구문은 <A HREF="auagd009.htm#HDRWQ168">프로세스를 일시적으로 정지하려면</A>의 내용을 참조하십시오.
<P>
<PRE>   # <B>/usr/afs/bin/bos shutdown</B> &lt;<VAR>machine&nbsp;name</VAR>> <B>buserver  -localauth  -wait</B>
</PRE>
</LI><LI>각 시스템에서 다음 명령을 실행하여 백업 데이터베이스를
제거하십시오.
<P>
<PRE>   # <B>cd /usr/afs/db</B>
   # <B>rm bdb.DB0</B>
   # <B>rm bdb.DBSYS1</B>
</PRE>
</LI><LI>IP 주소가 가장 낮은 시스템에서 시작하여 각 시스템에서,
<B>bos start</B> 명령을 실행하여 백업 서버 프로세스를
다시 시작하십시오. 이 프로세스는 시작된 후 길이가 0인 백업
데이터베이스 사본을 작성합니다. 완전한 명령 구문은 <A HREF="auagd009.htm#HDRWQ166">상태 플래그를 Run으로 변경하여 프로세스를 시작하려면</A>의 내용을 참조하십시오.
<P>
<PRE>   # <B>/usr/afs/bin/bos start</B> &lt;<VAR>machine&nbsp;name</VAR>> <B>buserver  -localauth</B>
</PRE>
</LI><LI>시스템 중 하나에서 작업하면서 <B>backup</B> 명령을
실행하여 대화식 모드로 들어가십시오.
<P>
<PRE>   # <B> backup -localauth</B>
</PRE>
<P>
<P>여기서 <B>-localauth</B>는 로컬 <B>/usr/afs/etc/KeyFile</B> 파일에서 서버 티켓을 생성합니다.
</LI><LI><B>(backup) addhost</B> 명령을 실행하여, 복구된
데이터베이스 사본을 읽는 테이프 또는 파일을 처리하는 테이프 조정자
프로세스(<A HREF="#LISAVEDB-STARTTC">2</A> 단계에서 시작된 프로세스로서
<A HREF="#LISAVEDB-CMD">6</A> 단계에서는 <B>backup
savedb</B> 동작을 수행함) 항목을 새로운 빈 데이터베이스에서
작성하십시오.
완전한 구문에 대해서는 <A HREF="auagd011.htm#HDRWQ262">테이프 조정자 시스템 구성하기</A>에 있는
<A HREF="auagd011.htm#LICONFTC-ADDHOST">8</A> 과정을 참조하십시오.
<P>
<PRE>   backup>  <B>addhost</B> &lt;<VAR>tape&nbsp;machine&nbsp;name</VAR>> [&lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]
</PRE>
<A NAME="IDX7088"></A>
<A NAME="IDX7089"></A>
</LI><LI><B>(backup) restoredb</B> 명령을 실행하여
데이터베이스 서버 시스템으로 복구된 데이터베이스를 복사하십시오.
<P>
<PRE>   backup>
<B>restoredb</B>  [<B>-portoffset</B> &lt;<VAR>TC&nbsp;port&nbsp;offset</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD><B>restoredb</B>의 축약형입니다.
<P><DT><B>-portoffset
</B><DD>이 동작을 위해 테이프나 백업 데이터 파일을 처리하는 테이프
조정자의 포트 오프셋 번호를 지정합니다. 기본값 <B>0</B>이 적합하지 않으면 이 인수를 제공해야 합니다.
</DL>
</LI><LI><B>(선택적)</B> 추가로
<B>backup</B> 명령을 실행하지 않으려면 대화식
모드를 종료하십시오.
<P>
<PRE>   backup>
<B>quit</B>
</PRE>
</LI><LI><B>(선택적)</B> 원할 경우, <B>Ctrl-d</B> 또는 다른 인터럽트 신호을 입력하여 각각의 데이터베이스 서버
시스템에서 <B>루트</B> 쉘을 종료하십시오. 또한
테이프 조정자 시스템에서 <B>Ctrl-c</B> 신호를
사용하여 프로세스를 정지할 수 있습니다.
</LI></OL>
<A NAME="IDX7090"></A>
<A NAME="IDX7091"></A>
<P><H3><A NAME="HDRWQ321" HREF="auagd002.htm#ToC_358">백업 데이터베이스에서 이전 레코드 제거</A></H3>
<P><B>backup dump</B> 또는 <B>backup
labeltape</B> 명령을 사용하여 테이프를 다시 사용하거나 레이블을
다시 지정할 때마다, 백업 시스템은 그 테이프와 덤프 세트에 있는 다른 모든
테이프에 들어있는 덤프에 대한 덤프 레코드 모두를 자동으로 제거합니다.
그러나, 이전 레코드들은 백업 데이터베이스에서 계속해서 누적될
수 있습니다. 예를 들어 제조업체에서 권장하는 최대 횟수만큼 사용한
후 백업 테이프를 버릴 때, 여기에 있는 덤프 레코드들은
데이터베이스에 남게 됩니다. 이와 같이, 백업 시스템은 덤프가 만기
날짜에 도달했지만 덤프가 들어있는 테이프를 다시 사용하거나 레이블을
다시 지정하려 할 때에만 자동으로 덤프 레코드를 삭제하지 않습니다.
마지막으로 백업 동작이 중간에서 정지되었을 경우, 정지되기 전에
테이프로 기록된 볼륨 레코드들은 데이터베이스에 그대로 남습니다.
<P>백업 데이터베이스가 너무 크면 백업 서버가 필요한 것을 찾기 위해 많은
레코드를 탐색해야 하므로 백업 동작시 효율성이 떨어질 수 있습니다.
사용하지 않는 이전 레코드를 제거하려면, <B>backup deletedump</B> 명령을 사용하십시오. 덤프 ID로 각 덤프를
식별하거나, 일정 기간동안 작성된 모든 덤프들을 제거하도록
지정하십시오. 초기 덤프 레코드를 제거하는 경우는 제외하면, 추가 덤프
레코드를 제거할 수 없음을 기억하십시오. 초기 덤프 레코드를 제거하면
연관된 모든 추가 덤프 레코드들이 제거됩니다. 덤프 레코드를 제거하면
해당 테이프에서, 또는 직접적으로든 또는 간접적으로든 상위로서 삭제된
덤프를 참조하는 모든 덤프에서 데이터를 복원할 수 없습니다. 즉, 복원
동작은 전체 덤프에서 계속되어 지정된 순서대로 각 증분 덤프에서
계속되어야 합니다. 특정 덤프에 대한 레코드를 제거했으면, 이후 증분
덤프 데이터를 복원할 수 없습니다.
<P>백업 데이터베이스를 축약하는 또다른 방법은 <B>-archive</B> 인수를 <B>backup savedb</B> 명령에
포함시키는 것입니다.
데이터베이스 사본이 테이프나 백업 데이터 파일로 기록된 뒤, 백업
서버는 시간소인이 사용자가 지정한 날짜 및 시간 이전인 모든 덤프
동작의 덤프 레코드들을 삭제합니다. 그러나 <B>-to</B>
인수를 <B>backup deletedump</B> 명령과 함께 실행하는
것도 같은 효과가 있으며, <B>backup savedb</B> 명령에서
처럼 테이프 조정자 프로세스를 시작하지 않아도 되므로 좀 더
간단합니다. <B>backup savedb</B> 명령에서
<B>-archive</B> 인수에 대한 내용은 <I>AFS Administration Reference</I>에 있는
명령 참조서를 참조하십시오.
<P>나중에 삭제한 덤프 레코드에 액세스해야 하고 해당 테이프는 계속
존재하는 경우, <B>-dbadd</B> 인수를
<B>backup scantape</B> 명령에서 사용하여
<A HREF="#HDRWQ305">테이프 내용 검색하기</A>에서 설명한 것처럼 그 내용을 검색할 수
있습니다.
<A NAME="IDX7092"></A>
<A NAME="IDX7093"></A>
<P><H3><A NAME="HDRWQ322" HREF="auagd002.htm#ToC_359">백업 데이터베이스에서 레코드 삭제하기</A></H3>
<OL TYPE=1>
<LI><B>/usr/afs/etc/UserList</B> 파일에 나열된
사용자로서 인증받았는 지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>(선택적)</B> 여러 레코드를 삭제하거나
추가 명령을 실행하려면 <B>backup</B> 명령을 실행하여
대화식 모드로 들어가십시오. 대화식 프롬프트는 다음 단계에서 나타납니다.
<P>
<PRE>   % <B>backup</B>
</PRE>
</LI><LI><B>(선택적)</B> <B>backup dumpinfo</B> 명령을 실행하여 삭제할 레코드를 결정하는 데 도움이 될 수 있는
백업 데이터베이스 정보를 나열하십시오. 자세한 명령은
<A HREF="#HDRWQ303">덤프 레코드 표시하기</A> 내용을 참조하십시오.
<P>
<PRE>   backup> <B>dumpinfo</B> [&lt;<VAR>no.&nbsp;of&nbsp;dumps</VAR>>]  [<B>-id</B> &lt;<VAR>dump&nbsp;id</VAR>>]  [<B>-verbose</B>]
</PRE>
</LI><LI><B>backup deletedump</B> 명령을 실행하여 하나
이상의 덤프 세트를 삭제하십시오.
<P>
<PRE>   backup> <B>deletedump</B>
[<B>-dumpid</B> &lt;<VAR>dumpid</VAR>><SUP>+</SUP>]
[<B>-from</B> &lt;<VAR>date&nbsp;time</VAR>>]  \
                      [<B>-to</B> &lt;<VAR>date&nbsp;time</VAR>>] 
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>dele
</B><DD><B>deletedump</B>의 축약형입니다.
<P><DT><B>-dumpid
</B><DD>백업 데이터베이스에서 삭제할 초기 덤프의 덤프 ID를 지정합니다.
연관된 모든 추가 덤프의 레코드들도 삭제됩니다.
이 인수나 <B>-to</B>(그리고 선택적으로
<B>-from</B>) 인수 중 하나를 제공하십시오.
<P><DT><B>-from
</B><DD>날짜 범위 시작을 지정합니다. 표시된 기간동안 작성된 덤프
레코드들이 삭제됩니다.
<P>
<P><B>-to</B> 인수로 표시한 시간 이전의 모든 레코드들을
누락시키려면 이 인수를 삭제하십시오. 그렇지 않으면 다음 형식으로
값을 제공하십시오.
<P>
<P><VAR>mm</VAR>/<VAR>dd</VAR>/<VAR>yyyy</VAR> [<VAR>hh</VAR>:<VAR>MM</VAR>]
<P>
<P>여기서 월(<VAR>mm</VAR>), 일(<VAR>dd</VAR>) 및 연(<VAR>yyyy</VAR>)은 필수입니다.
기본값 자정(00:00 시)을 나타내려면 시와 분(<VAR>hh</VAR>:<VAR>MM</VAR>)을
생략할 수 있습니다. 이 시와 분을 제공할 경우, 24시간 형식(예를 들어
<B>14:36</B> 값은 오후 2:36을 나타냄)을 사용하십시오.
<P>
<P>다음과 함께 <B>-to</B> 인수를 제공해야 합니다.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">명령의 구문 명령문에서 이 인수 다음에는 플러스 기호가 오며,
이것은 다른 분리문자나 큰 따옴표로 묶지 않아도 되는 여러 단어 값을
사용할 수 있기 때문이며, 여러 날짜를 사용하기 때문은 아닙니다.
하나의 날짜(그리고 선택적으로 시간) 정의를 입력합니다.
</TD></TR></TABLE>
<P><DT><B>-to
</B><DD>날짜 범위 끝을 지정합니다. 표시된 기간동안 작성된 덤프
레코드들이 백업 데이터베이스에서 삭제됩니다.
<P>
<P><B>-from</B> 인수로 지정한 날짜 이후에 작성된 모든
레코드들을 삭제하려면 <B>NOW</B> 값을 지정하십시오.
백업 데이터베이스에 있는 모든 덤프 레코드를 삭제하려면,
<B>NOW</B> 값을 입력하고 <B>-from</B>
인수는 생략하십시오. 그렇지 않으면 <B>-from</B>
인수에서와 같은 형식으로 날짜 값을 제공하십시오.
유효한 연(<VAR>yyyy</VAR>) 범위값은 <B>1970</B> - <B>2037</B>이며, 표준 UNIX 표현으로 가능한
최종 날짜는 2038년 이전이므로 더 큰 값은 유효하지 않습니다.
명령 해석기는 자동으로 2038 이내의 최대 값으로 나중에 있는
날짜를 줄입니다.
<P>
<P>시간 부분(<VAR>hh</VAR>:<VAR>MM</VAR>)이 삭제되면, 기본값은 자정후
59초(00:00:59시)입니다. 이처럼, <B>backup</B> 명령
해석기는 사용자가 입력한 임의 시간에 59초를 자동으로 더합니다.
어느 경우이든 59초를 추가하면 백업 데이터베이스와 <B>backup
dumpinfo</B> 명령에서 덤프 작성시를 시와 분으로만 표현하는 것이
보상됩니다. 예를 들어 데이터베이스는 20:55:00 및 20:55:59 사이에
시작하는 모든 덤프 동작의 작성 시간소인을 <TT>20:55</TT>로
기록합니다. 시간에 자동으로 59초를 추가하는 것은 그 분 동안 작성된
모든 덤프의 레코드들이 해당됩니다.
<P>
<P>이 인수나 <B>-dumpid</B> 인수 중 하나만을 제공하십시오.
이 인수는 <B>-from</B> 인수가 제공되는 경우 필수입니다.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">명령의 구문 명령문에서 이 인수 다음에는 플러스 기호가 오며,
이것은 다른 분리문자나 큰 따옴표로 묶지 않아도 되는 여러 단어 값을
사용할 수 있기 때문이며, 여러 날짜를 사용하기 때문은 아닙니다.
하나의 날짜(그리고 선택적으로 시간) 정의를 입력합니다.
</TD></TR></TABLE>
</DL>
</LI></OL>
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd011.htm">이전 페이지</A> &#124; <A HREF="auagd013.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B> 
<!-- Begin Footer Records  ========================================== -->
<P><HR><B> 
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved 
</B> 
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
