<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    --> 
<BODY bgcolor="ffffff"> 
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<P>
<A NAME="IDX7308"></A>
<A NAME="IDX7309"></A>
<HR><H1><A NAME="HDRWQ387" HREF="auagd002.htm#ToC_431">클라이언트 시스템 및 캐쉬 관리 프로그램 관리</A></H1>
<P>이 장에서는 AFS 클라이언트 시스템을 관리하는 방법에 대해 설명하며,
이 시스템은 사용자가 AFS 파일공간에 액세스할 수 있고 AFS 서버
프로세스와 통신할 수 있는 시스템입니다(클라이언트 시스템은 제대로
구성되었으면 AFS 서버 시스템으로서도 동시에 기능할 수 있습니다).
AFS 클라이언트 기계에는 다음과 같은 특징이 있습니다.
<UL>
<LI>커널에는 보통 캐쉬 관리 프로그램이라고 하는 수정사항 세트가
포함되며, 이를 사용하면 AFS 파일 및 디렉토리에 액세스할 수 있습니다.
사용자 요구에 적합하도록 캐쉬 관리 프로그램의 기능 중 많은 부분을
구성할 수 있습니다. <A HREF="#HDRWQ390">캐쉬 관리 프로그램 사용자 정의 개요</A>를 참조하십시오.
</LI><LI>로컬 디스크에 있는 <B>/usr/vice/etc</B> 디렉토리에는
여러 구성 파일들이 저장됩니다. <A HREF="#HDRWQ392">/usr/vice/etc 디렉토리에 있는 구성 파일</A>을 참조하십시오.
</LI><LI>캐쉬는 시스템 메모리나 또는 사용하는 로컬 디스크 파티션에 있는
AFS 파일 서버 시스템에서 패치한 데이터의 임시 사본을 저장합니다.
<A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A> 및 <A HREF="#HDRWQ402">afsd 프로그램으로 기타 캐쉬 매개변수 설정</A>의 내용을
참조하십시오.
</LI></UL>
<P>시스템에 클라이언트 기능들을 설치하는 방법을 배우려면 <I>AFS 빠른 시작</I>의
내용을 참조하십시오.
<HR><H2><A NAME="HDRWQ388" HREF="auagd002.htm#ToC_432">명령 요약</A></H2>
<P>이 장에서는 표시된 명령을 사용하여 다음 타스크를 수행하는 방법에 대해
설명합니다.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">재부트시 설정한 캐쉬 크기 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>cat /usr/vice/etc/cacheinfo</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">현재 캐쉬 크기 및 이용도 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs getcacheparms</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">재부트없이 디스크 캐쉬 크기 변경
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs setcachesize</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">캐쉬 관리 프로그램 시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>afsd</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%"><B>CellServDB</B> 파일 내용 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>cat /usr/vice/etc/CellServDB</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">커널 메모리에서 데이터베이스 서버 시스템 목록 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs listcells</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">커널 메모리에서 데이터베이스 서버 시스템
목록 변경
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs newcell</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">setuid의 셀 상태 체크
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs getcellstatus</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">setuid의 셀 상태 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs setcell</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">서버 탐침 간격 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs checkservers -interval</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">시스템의 셀 멤버쉽 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>cat /usr/vice/etc/ThisCell</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">시스템의 셀 멤버쉽 변경
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Edit <B>/usr/vice/etc/ThisCell</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">캐쉬 파일/디렉토리 플러쉬
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs flush</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">볼륨에서 캐쉬된 모두 플러쉬
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs flushvolume</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">볼륨 대 마운트지점 맵핑 갱신
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs checkvolumes</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">캐쉬 관리 프로그램의 서버 선호 사항 순위
표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs getserverprefs</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">캐쉬 관리 프로그램의 서버 선호 사항 순위 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs setserverprefs</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">등록할 클라이언트 시스템 주소 표시
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs getclientaddrs</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">등록할 클라이언트 시스템 주소 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs setclientaddrs</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">경로 및 상태 메시지 표시 제어
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs messages</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">시스템의 시스템 유형 표시 및 변경
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs sysname</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">비동기 기록 사용 가능
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><B>fs storebehind</B>
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ390" HREF="auagd002.htm#ToC_433">캐쉬 관리 프로그램 사용자 정의 개요</A></H2>
<A NAME="IDX7310"></A>
<A NAME="IDX7311"></A>
<A NAME="IDX7312"></A>
<P>AFS 클라이언트 시스템의 커널에는 보통 <I>캐쉬
관리 프로그램</I>이라고 하는 수정내용 세트가 포함되며, 이를 사용하면
AFS 파일 및 디렉토리에 액세스할 수 있고, AFS 서버 프로세스와 통신할
수도 있습니다. 보통 캐쉬 관리 프로그램을 프로세스나 프로그램으로
애기하기도 하며, 프로세스나 프로그램처럼 동작하기도 합니다.
이 프로그램을 구성할 때, 그 사용법이 완전하게 정확하지는 않음을
기억하는 것이 좋습니다.
<P>캐쉬 관리 프로그램은 주로 시스템에서 실행중인 응용프로그램을 위해
파일들을 패치합니다. 응용프로그램이 AFS 파일에 요청하면, 캐쉬
관리 프로그램은 볼륨 위치(VL) 서버에게 문의하여 파일이 포함된
볼륨이 들어있는 파일 서버 시스템 목록을 확보합니다. 그런 다음 캐쉬
관리 프로그램은 응용프로그램의 시스템 호출 요청을 해당 시스템에서
실행중인 파일 서버에 대한 원격 프로시듀어 호출(RPC)로 변환시킵니다.
파일 서버가 파일을 전달하면, 캐쉬 관리 프로그램은 이를 응용프로그램에
전달하기 전에 로컬 <I>캐쉬</I>에 저장합니다.
<P>파일 서버는 파일과 함께 <I>콜백</I>이라는 데이터
구조를 전달합니다(보다 정확하게 말하면, 읽기/쓰기 볼륨에서
패치한 각 파일의 콜백과 읽기 전용 볼륨에서 패치한 모든 데이터의
단일 콜백을 전달합니다). 유효한 콜백은 캐쉬 관리 프로그램이 캐쉬한
파일 사본이 파일 서버에서 유지하는 중앙 사본과 일치함을 나타냅니다.
다른 AFS 클라이언트 시스템에 있는 응용프로그램이 중앙 사본을 변경하면
파일 서버는 콜백을 중단시키고, 캐쉬 관리 프로그램은 시스템에 있는
응용프로그램이 다음번에 파일에서 데이터를 요청할 때 새로운 버전을
검색해야 합니다. 그러나, 콜백이 중단되어 있는 동안은 캐쉬 관리
프로그램이 계속해서 시스템에 있는 응용 프로그램에게 캐쉬된
버전의 파일을 제공하여 불필요한 네트워크 전송을 줄일 수 있습니다.
<P>이 장의 표시된 절에서는 다음 캐쉬 관리 프로그램 기능을 구성하고
사용자 정의하는 방법에 대해 설명합니다. 첫번째(디스크나 메모리
캐쉬 선택)를 제외한 모든 것은 선택적이며, 이는 AFS가 이에 대해
적합한 기본값을 설정하기 때문입니다.
<UL>
<LI><I>디스크 또는 메모리 캐쉬</I>. AFS 캐쉬
관리 프로그램은 로컬 디스크에 있는 공간 대신 캐쉬에 시스템 메모리를
사용할 수 있습니다. 사용할 것은 결정하는 것이 가장 기본적인 구성
결정입니다. <A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>을 참조하십시오.
</LI><LI><I>캐쉬 크기</I>. 캐쉬 크기는 아마도 클라이언트
기계 성능에 가장 많은 영향을 줍니다. 캐쉬 관리 프로그램이 네트워크를
통해 파일 서버와 접속해야 하는 빈도를 결정하거나, 캐쉬된 데이터를
버리고 새로 요청된 파일을 위해 공간을 마련해야 하는 지를 결정합니다.
이 모두는 캐쉬 관리 프로그램이 사용자에게 파일을 전달하는 속도에
영행을 줍니다. <A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>을 참조하십시오.
</LI><LI><I>캐쉬 위치</I>. 디스크 캐쉬의 경우, 기존
캐쉬 디렉토리 위치(<B>/usr/vice/cache</B>)를 변경하여
시스템에 있는 다른 디스크에서 좀 더 넓은 공간을 사용할 수 있도록
할 수 있습니다. 캐쉬가 커지면 파일 전송 속도도 빨라질 수 있습니다.
<A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>을 참조하십시오.
</LI><LI><I>청크(chunk) 크기 및 갯수</I>. 캐쉬 관리
프로그램을 시작하는 <B>afsd</B> 프로그램을 사용하면
캐쉬가 나누어지는 청크의 크기와 갯수 및 관련 매개변수를 제어할 수
있습니다. 이들 매개변수를 설정하는 것은 선택적이며, 이는 적당한
기본값이 있기 때문이지만 매개변수를 설정하면 정확한 제어를 할 수 있습니다.
AFS 분배에는 서로 다른 구성 및 이용 패턴에 적합한 값으로 캐쉬
관리 프로그램을 설정하는 구성 스크립트가 포함됩니다.
<A HREF="#HDRWQ402">afsd 프로그램으로 기타 캐쉬 매개변수 설정</A>을 참조하십시오.
</LI><LI><I>데이터베이스 서버 시스템 지식</I>. 로컬
디스크에 있는 <B>/usr/vice/etc/CellServDB</B>
파일에서 셀의 데이터베이스 서버 시스템을 나열하여 셀의
AFS 파일 공간 및 기타 서비스에 액세스할 수 있습니다.
<A HREF="#HDRWQ406">데이터베이스 서버 시스템 정보 유지</A>를 참조하십시오.
</LI><LI><I>setuid 권한</I>. 캐쉬 관리 프로그램이
셀에서 프로그램이 setuid 허용권한을 실행하도록 허용하는 지 여부를
제어할 수 있습니다. <A HREF="#HDRWQ409">클라이언트가 Setuid 프로그램을 실행할 수 있는 지 결정</A>을 참조하십시오.
</LI><LI><I>셀 멤버쉽</I>. 각 클라이언트들은 로컬
<B>/usr/vice/etc/ThisCell</B> 파일에서 정의한 하나의
셀에 속합니다. 셀 멤버쉽은 시스템 사용자가 인증받고 AFS 명령이
실행되는 기본 셀을 결정합니다. <A HREF="#HDRWQ411">클라이언트 시스템의 셀 멤버쉽 설정</A>을 참조하십시오.
</LI><LI><I>캐쉬된 파일 버전</I>. AFS 시스템의 콜백은
보통 캐쉬 관리 프로그램이 사용가능한 가장 최근 버전의 파일 및
디렉토리를 갖도록 합니다. 그러나 캐쉬에 만기된 버전이 들어있는 것으로
생각되면 캐쉬 관리 프로그램에게 파일 서버로부터 가장 최근 버전의
파일을 패치하도록 할 수도 있습니다. <A HREF="#HDRWQ412">캐쉬된 데이터 갱신 강요하기</A>를 참조하십시오.
</LI><LI><I>파일 서버 및 볼륨 위치 서버 선호 사항</I>.
캐쉬 관리 프로그램은 파일 서버 시스템 및 볼륨 서버(VL) 시스템에서
인터페이스에 대해 숫자로 선호 사항 순위를 설정합니다. 순위는 캐쉬
관리 프로그램이 볼륨 또는 VLDB(Location Database)에서 데이터를
패치할 때 처음으로 사용할 인터페이스를 결정합니다. 캐쉬
관리 프로그램은 시작하자 마자 각 인터페이스에 대한 네트워크 근접도를
바탕으로 기본 순위를 설정하지만, 원하면 선호 사항 순위를 수정할 수
있습니다. <A HREF="#HDRWQ414">서버 선호 사항 순위 유지</A>를 참조하십시오.
</LI><LI><I>파일 서버로 등록된 인터페이스</I>. 캐쉬
관리 프로그램이 멀티홈(여러 인터페이스 주소가 있는)인 경우,
클라이언트 시스템으로 RPC를 시작할 때 파일 서버가 사용하도록 등록할
홈을 제어할 수 있습니다. <A HREF="#HDRWQ415">멀티홈 클라이언트 시스템 관리</A>를 참조하십시오.
</LI><LI><I>정보 메시지 표시</I>. 기본적으로, 캐쉬
관리 프로그램은 기본 오류 및 정보 메시지를 클라이언트 시스템의
콘솔 및 명령쉘로 전송합니다. 메시지 표시를 사용할 수 없도록
설정할 수도 있습니다. <A HREF="#HDRWQ416">경고 및 정보 메시지 표시 제어</A>를 참조하십시오.
</LI><LI><I>시스템 유형</I>. 캐쉬 관리 프로그램은 커널
메모리에 로컬 시스템의 AFS 시스템 유형을 기록하고, 경로 이름에 있는
<VAR>@sys</VAR> 변수값을 대체합니다. <A HREF="#HDRWQ417">시스템 유형 이름 표시 및 설정</A>을 참조하십시오.
</LI><LI><I>지연된 기록</I>. 기본적으로, 캐쉬
관리 프로그램은 응용프로그램이 파일을 닫을 때 모든 데이터를 파일
서버로 즉시 동기식으로 기록합니다. 각 파일 또는 캐쉬
관리 프로그램이 처리하는 모든 파일에 대해 비동기 기록을 사용할 수
있으며, 캐쉬 관리 프로그램이 닫히는 응용프로그램으로 제어를 리턴할
때 기록된 채로 남게될 데이터 양을 설정할 수 있습니다. <A HREF="#HDRWQ418">비동기 기록 가능</A>을 참조하십시오.
</LI></UL>
<P>클라이언트 시스템 자체에서 모든 구성을 변경해야 합니다(콘솔이나
<B>텔넷</B> 연결과 같은 직접 연결을 통해). 캐쉬
관리 프로그램을 원격으로 구성할 수 없습니다. 몇몇 명령을 실행하려면 로컬
수퍼유저 <B>루트</B>로 로그인해야 하지만, 다른
명령에는 특권이 필요하지 않습니다. 이 장에서 설명하는 모든 파일들은
실제로 각 AFS 클라이언트 시스템의 로컬 디스크에 상주해야 합니다(예를
들어 AFS에 있는 파일로 기호 링크될 수 없습니다).
<P>AFS의 <B>패키지</B> 프로그램은 클라이언트 시스템
구성의 다른 측면을 단순화할 수 있으며, 여기에는 시스템의 AFS 초기설정
파일에서의 설정도 포함됩니다. <A HREF="auagd016.htm#HDRWQ419">package 프로그램을 사용한 클라이언트 시스템 구성</A>을 참조하십시오.
<HR><H2><A NAME="HDRWQ391" HREF="auagd002.htm#ToC_434">로컬 디스크에서의 구성 및 캐쉬 관련 파일</A></H2>
<A NAME="IDX7313"></A>
<A NAME="IDX7314"></A>
<A NAME="IDX7315"></A>
<A NAME="IDX7316"></A>
<A NAME="IDX7317"></A>
<P>이 절에서는 모든 클라이언트 시스템의 로컬 <B>/usr/vice/etc</B>
디렉토리에 있어야 하는 클라이언트 구성 파일에 대해 간단히 설명합니다.
시스템에서 디스크 캐쉬를 사용하는 경우, 캐쉬 전용 파티션이 있어야
하며, 보통 <B>/usr/vice/cache</B> 디렉토리에서 마운트됩니다.
<P><B>Windows 사용자를 위한 주:</B> 이 책에서 설명하는
몇몇 파일들은 Windows 운영 체제를 실행하는 시스템에 없습니다.
또한 Windows는 슬래쉬(&nbsp;<B>/</B>&nbsp;)
대신 역슬래쉬(&nbsp;<B>\</B>&nbsp;)를
사용하여 경로 이름에서 각 요소를 구분합니다.
<P><H3><A NAME="HDRWQ392" HREF="auagd002.htm#ToC_435">/usr/vice/etc 디렉토리에 있는 구성 파일</A></H3>
<P>클라이언트 시스템의 로컬 디스크에 있는 <B>/usr/vice/etc</B>
디렉토리에는 캐쉬 관리 프로그램이 제대로 동작하기 위한 구성 파일들이
있어야 합니다. 이 구성 파일들은 캐쉬 관리 프로그램 구성의 가장
기본적인 측면을 제어합니다.
<P>셀에 있는 클라이언트 시스템이 동일하게 수행되는 중요한 경우, 중앙
소스에서 이들 파일들을 갱신하는 것이 가장 효과적입니다. 다음
설명에는 파일을 유지하는 최상의 방법에 대해 설명하는 절의 포인터도
포함됩니다.
<DL>
<A NAME="IDX7318"></A>
<A NAME="IDX7319"></A>
<A NAME="IDX7320"></A>
<A NAME="IDX7321"></A>
<A NAME="IDX7322"></A>
<P><DT><B>afsd
</B><DD>캐쉬 관리 프로그램을 시작하는 프로그램의 2진 파일.
시스템이 AFS 클라이언트 시스템을 유지하려면 시스템이 재부트할 때 마다
실행되어야 합니다. 프로그램은 콜백을 처리하는 프로세스와 같이
캐쉬 관리 프로그램의 기능을 향상시키는 여러 디먼도 시작합니다.
<A NAME="IDX7323"></A>
<A NAME="IDX7324"></A>
<P><DT><B>cacheinfo
</B><DD>캐쉬의 가장 기본적인 구성 매개변수를 설정하는 1 라인으로 된
파일. 여기에는 캐쉬 관리 프로그램이 AFS 파일공간을 마운트하는 로컬
디렉토리, 캐쉬로 사용할 로컬 디스크 디렉토리, 및 캐쉬에 할당된
킬로바이트 양등의 정보가 들어갑니다.
<P>
<P><I>AFS 빠른 시작</I>에서는 클라이언트 시스템을 설치할 때 이 파일을 작성하는
방법에 대해 설명합니다. 메모리 캐쉬를 사용하는 시스템에서 캐쉬 크기를
변경하려면, 파일을 편집한 뒤 시스템을 재부트하십시오. 디스크 캐쉬를
사용하는 시스템에서는, <B>fs setcachesize</B> 명령을
실행하여 재부트하지 않고도 캐쉬 크기를 변경할 수 있습니다. 그 명령에
대해서는 <A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>의 내용을 참조하십시오.
<A NAME="IDX7325"></A>
<A NAME="IDX7326"></A>
<P><DT><B>CellServDB
</B><DD>이 ASCII 파일은 이 시스템에서 액세스할 수 있도록 하려는
데이터베이스 서버 시스템의 이름을 로컬 셀이나 외부 셀에서
지정합니다(데이터베이스 서버 시스템은 인증, 백업, 보호 및
VL 서버 프로세스를 실행하는 셀내의 시스템입니다.
<A HREF="auagd008.htm#HDRWQ92">데이터베이스 서버 시스템</A>의 내용을 참조하십시오).
<P>
<P>캐쉬 관리 프로그램은 셀의 데이터베이스 서버 시스템에 도달하여
파일공간에서 파일을 패치할 수 있어야 합니다.
<B>CellServDB</B> 파일에 있는 정보가 틀리거나
누락되면 액세스 속도가 느려지거나 완전히 봉쇄됩니다.
셀의 데이터베이스 서버 시스템이 변경될 때 마다 파일을 갱신하는 것이
중요합니다.
<P>
<P><B>afsd</B> 프로그램이 캐쉬 관리 프로그램을 시작하면,
커널 메모리로 파일 내용을 로드합니다. 캐쉬 관리 프로그램은 재부트
사이에 파일을 읽지 않으므로, 파일의 변경사항을 커널 메모리에 적용할
수 있도록 하려면 시스템을 재부트해야 합니다. 또는
<B>fs newcell</B> 명령을 실행하여 파일을 변경하지 않고
직접 커널 메모리로 변경사항을 삽입할 수 있습니다. 중앙 소스에서
파일을 업그레이드하는 것도 편리할 수 있습니다. 그 명령에 대해서는
<A HREF="#HDRWQ406">데이터베이스 서버 시스템 정보 유지</A>의 내용을 참조하십시오.
<P>
<P>(클라이언트 시스템에 있는 <B>CellServDB</B> 파일은
서버 시스템의 <B>/usr/afs/etc</B> 디렉토리에 있는 것과
같지 않습니다. 이 보존되는 파일은 로컬 셀의 데이터베이스 서버
시스템만을 나열합니다.
서버 <B>CellServDB</B> 파일 유지에 대한 명령은,
<A HREF="auagd008.htm#HDRWQ118">서버 CellServDB 파일 유지</A>의 내용을 참조하십시오).
<A NAME="IDX7327"></A>
<A NAME="IDX7328"></A>
<P><DT><B>NetInfo
</B><DD>이 선택적인 ASCII 파일은 클라이언트 시스템상의 하나 이상의
네트워크 인터페이스 주소를 나열합니다. 캐쉬 관리 프로그램이 시작될
때 주소가 있으면, 캐쉬 관리 프로그램은 이것을 파일 서버로 등록하는
인터페이스 목록의 기본으로서 사용합니다. <A HREF="#HDRWQ415">멀티홈 클라이언트 시스템 관리</A>를 참조하십시오.
<A NAME="IDX7329"></A>
<A NAME="IDX7330"></A>
<P><DT><B>NetRestrict
</B><DD>이 선택적인 ASCII 파일은 하나 이상의 네트워크 인터페이스 주소를 나열합니다.
캐쉬 관리 프로그램이 시작될 때 주소가 있으면, 캐쉬 관리 프로그램은
파일 서버로 등록하는 인터페이스 목록에서 지정된 주소를 제거합니다.
<A HREF="#HDRWQ415">멀티홈 클라이언트 시스템 관리</A>를 참조하십시오.
<A NAME="IDX7331"></A>
<A NAME="IDX7332"></A>
<P><DT><B>ThisCell
</B><DD>이 ASCII 파일에는 시스템이 속하는 셀에 대한 도메인 유형의
완전한 이름을 지정하는 한 행이 들어 있습니다. 예는 <TT>abc.com</TT> 및 <TT>stateu.edu</TT>입니다. 이 값은 시스템 사용자가
인증받게 되는 기본 셀을 정의하고, 여기에서는 명령 해석기(예를
들면 <B>bos</B> 명령)가 서버 프로세스에 접속합니다.
<P>
<P><I>AFS 빠른 시작</I>에서는 AFS 클라이언트 기능을 설치할 때 이 파일을 작성하는
방법에 대해 설명합니다. 클라이언트 시스템의 셀 멤버쉽 변경방법에
대해서는 <A HREF="#HDRWQ411">클라이언트 시스템의 셀 멤버쉽 설정</A>의 내용을 참조하십시오.
</DL>
<P>이 파일뿐만 아니라, <B>/usr/vice/etc</B> 디렉토리에는
때때로 다음 유형의 파일 및 하위 디렉토리가 포함됩니다.
<UL>
<A NAME="IDX7333"></A>
<A NAME="IDX7334"></A>
<A NAME="IDX7335"></A>
<A NAME="IDX7336"></A>
<LI>많은 시스템 유형의 <B>afs.rc</B> AFS 초기설정
스크립트. <I>AFS 빠른 시작</I>에서 지정된 일반 구성에서, 운영 체제에서 사용하는
다른 초기설정 파일과 같은 디렉토리에서 보관되는 실제 스크립트에
대한 기호 연결입니다.
<A NAME="IDX7337"></A>
<A NAME="IDX7338"></A>
</LI><LI>동적 커널 로드 프로그램이 사용하는 AFS 커널 라이브러리 파일이
있는 하위 디렉토리.
<A NAME="IDX7339"></A>
<A NAME="IDX7340"></A>
</LI><LI><B>C</B>라는 하위 디렉토리로서, 여기에는
<B>afszcm.cat</B>라는 캐쉬 관리 프로그램 카탈로그
파일이 들어 있습니다. fstrace 프로그램은 카탈로그 파일을 사용하여
동작 코드를 문자열로 번역하여 추적 로그에 있는 메시지를 읽을 수
있도록 합니다. <A HREF="auagd013.htm#HDRWQ342">fstrace 명령 집합 정보</A>를 참조하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ393" HREF="auagd002.htm#ToC_436">캐쉬 관련 파일</A></H3>
<A NAME="IDX7341"></A>
<A NAME="IDX7342"></A>
<A NAME="IDX7343"></A>
<A NAME="IDX7344"></A>
<A NAME="IDX7345"></A>
<P>디스크 캐쉬를 사용하는 클라이언트 시스템에는 캐쉬 전용 로컬 디스크
디렉토리가 있어야 합니다. 일반 마운트 포인트는 <B>/usr/vice/cache</B>이지만, 사용할 공간이 좀 더 있는 다른 파티션을 사용할 수도 있습니다.
<P>캐쉬 디렉토리에 있는 파일을 직접 삭제하거나 수정하지 마십시오.
그렇게 하면 커널이 손상될 수 있으며, 복구하는 유일한 방법은 시스템을
재부트하는 것입니다. 기본적으로 로컬 수퍼유저 <B>루트</B>는 파일을 소유하고 직접 읽을 수 있습니다.
<P>메모리 캐쉬를 사용하는 클라이언트 시스템은 대신 시스템 메모리내의 이
파일들에 저장된 모든 정보들을 보존합니다.
<DL>
<A NAME="IDX7346"></A>
<A NAME="IDX7347"></A>
<P><DT><B>CacheItems
</B><DD>캐쉬 관리 프로그램이 캐쉬 청크 내용을 추적하는 2진 형식 파일(다음에서
설명한 바와 같이 디렉토리에 있는 <B>V</B> 파일).
여기에는 파일 ID 번호(fID)와 데이터 버전 번호가 포함됩니다.
<A NAME="IDX7348"></A>
<A NAME="IDX7349"></A>
<P><DT><B>VolumeItems
</B><DD>캐쉬 관리 프로그램이 마운트 포인트와 데이터를 패치했던 볼륨
사이의 맵핑을 기록하는 2진 형식 파일. 캐쉬 관리 프로그램은
<B>pwd</B> 명령에 응답할 때 정보를 사용합니다.
<A NAME="IDX7350"></A>
<A NAME="IDX7351"></A>
<A NAME="IDX7352"></A>
<P><DT><B>V<VAR>n</VAR>
</B><DD>캐쉬 청크 파일. 이것은 AFS 파일에서 패치한 데이터를 상주시키기
위해 최대 크기(기본은 64KB)로 확장됩니다. 캐쉬에 있는
<B>V</B><VAR>n</VAR> 파일 갯수는 다른 요소에 있는 캐쉬
크기에 따라 달라집니다. <VAR>n</VAR>은 각 파일에 지정된 색인이며,
각 파일들은 순차적으로 번호가 지정되지만 캐쉬 관리 프로그램이
순차적으로 또는 연속적으로 이들을 사용하지 않습니다. AFS 파일이
<B>V</B><VAR>n</VAR> 파일의 최대 크기보다 크면, 캐쉬
관리 프로그램은 이를 여러 <B>V</B><VAR>n</VAR> 파일로
나눕니다.
</DL>
<HR><H2><A NAME="HDRWQ394" HREF="auagd002.htm#ToC_437">캐쉬 유형, 크기 및 위치 결정</A></H2>
<P>이 절에서는 메모리나 디스크 캐쉬를 구성하는 방법, 캐쉬 유형의 크기를
표시하고 설정하는 방법 그리고, 디스크 캐쉬에 대한 캐쉬 디렉토리
위치를 설정하는 방법에 대해 설명합니다.
<A NAME="IDX7353"></A>
<A NAME="IDX7354"></A>
<P>캐쉬 관리 프로그램은 기본적으로 디스크 캐쉬를 사용하며, 바람직한
캐쉬 유형입니다. 메모리 캐쉬를 구성하려면, <B>-memcache</B> 플래그를 <B>afsd</B> 명령에
포함시키십시오. 이것은 주로 시스템의 AFS 초기설정 파일에서
호출됩니다. 메모리 캐쉬를 사용하도록 구성되면, 시스템에 디스크가
있는 경우라도 캐쉬 관리 프로그램은 디스크 캐쉬를 수행하지 않습니다.
<P><H3><A NAME="Header_438" HREF="auagd002.htm#ToC_438">캐쉬 크기 선택</A></H3>
<A NAME="IDX7355"></A>
<P>캐쉬 크기는 다른 캐쉬 매개변수보다 더 직접 클라이언트 시스템의 성능에
영향을 줍니다. 캐쉬를 크게하면, 캐쉬 관리 프로그램이 사용자에게
파일을 전달하는 속도가 빨라집니다. 캐쉬가 작아도 캐쉬 관리 프로그램이
캐쉬된 데이터를 버리고 새로 요청된 데이터를 위해 공간을 작성해야 하는
빈도가 증가하므로 성능에 영향이 있습니다. 응용프로그램이 버려진
데이터를 요청하면, 캐쉬 관리 프로그램은 파일 서버에서 이를 요청해야
하므로, 네트워크에서 데이터를 패치하는 것은 로컬 디스크에서 패치하는
것보다 항상 속도가 느립니다. 캐쉬 관리 프로그램은 국지적으로
수정되었지만 아직 파일 서버에 저장되지 않은 파일 데이터는 버리지
않습니다. 캐쉬가 아주 작은 경우, 캐쉬 관리 프로그램은 버릴 데이터를
찾을 수 없습니다. 캐쉬된 데이터를 버릴 때 사용하는 알고리즘에
대해서는 <A HREF="#HDRWQ401">캐쉬 관리 프로그램이 버릴 데이터를 선택하는 방법</A>의 내용을 참조하십시오).
<P>캐쉬에 할당하는 디스크 또는 메모리 양은 여러 요소에 의해 결정됩니다.
디스크 캐쉬 디렉토리가 들어있는 파티션 또는 메모리내에서 사용할 수
있는 공간의 양은 절대 제한이 있습니다. 뿐만 아니라, 캐쉬 디렉토리
파티션에서 사용할 수 있는 공간의 95% 이상을 디스크 캐쉬에 할당할 수
없습니다. <B>afsd</B> 프로그램은 캐쉬
관리 프로그램을 시작하지 않고 종료하며, 이 제한사항을 위반했으면 해당
메시지를 표준 출력 문자열로 인쇄합니다. 메모리 캐쉬의 경우, 수행할
다른 프로세스와 응용 프로그램을 위해 충분한 메모리를 남겨 두어야
합니다. 실제로 사용할 수 있는 것 이상의 메모리를 할당하려 하는 경우,
<B>afsd</B> 프로그램은 캐쉬 관리 프로그램을 시작하지
않고 종료하고 표준 출력 문자열로 다음 메시지를 생성합니다.
<PRE>   afsd: memCache allocation failure at <VAR>number</VAR> KB
</PRE>
<P>여기서 <VAR>number</VAR>는 실패 바로 이전에 할당된 킬로바이트입니다.
<P>이 제한내에서, 해당 캐쉬 크기를 결정하는 요소에는 시스템에서 작업중인
사용자 수, 주로 작업하는 파일 크기, 그리고 (메모리 캐쉬의 경우)
시스템에서 주로 실행하는 프로세스 수가 포함됩니다. 이들 요소들에
대한 요구가 증가하면 좋은 성능을 유지하는 데 필요한 캐쉬도 커집니다.
<P>10MB 이하의 디스크 캐쉬에서는 성능이 좋지 못합니다. 적어도 60 - 70
MB의 캐쉬를 가지고 여러 사용자들을 서브하는 시스템들은 성능이 좋습니다.
캐쉬를 확대시키는 시점은 이전에 설명했던 요소에 따라
성능을 향상시키지 않으며, 예상하기 어렵습니다.
<P>1MB 이하의 메모리 캐쉬들은 동작할 수 없으며, 5MB 이하의 캐쉬
성능은 만족스럽지 않습니다. 적합한 상한은 디스크 캐쉬와 비슷하지만
시스템에 있는 다른 소스로부터의 메모리에 대한 요구에 의해
결정됩니다(사용자 및 프로세스 수). 몇몇 프로세스만을 실행하는
시스템들은 보다 작은 메모리 캐쉬를 사용할 수 있습니다.
<P>AFS는 몇몇 버전에서 캐쉬 크기에 대해 절대적으로 제한합니다.
사용하는 버전에 대해서는 <I>AFS 릴리스 노트</I>의 내용을 참조하십시오.
<P><B></B>
<P><H3><A NAME="HDRWQ395" HREF="auagd002.htm#ToC_439">캐쉬 크기와 위치의 표시 및 설정</A></H3>
<A NAME="IDX7356"></A>
<A NAME="IDX7357"></A>
<A NAME="IDX7358"></A>
<A NAME="IDX7359"></A>
<A NAME="IDX7360"></A>
<A NAME="IDX7361"></A>
<A NAME="IDX7362"></A>
<A NAME="IDX7363"></A>
<A NAME="IDX7364"></A>
<A NAME="IDX7365"></A>
<A NAME="IDX7366"></A>
<A NAME="IDX7367"></A>
<A NAME="IDX7368"></A>
<A NAME="IDX7369"></A>
<A NAME="IDX7370"></A>
<A NAME="IDX7371"></A>
<A NAME="IDX7372"></A>
<A NAME="IDX7373"></A>
<A NAME="IDX7374"></A>
<A NAME="IDX7375"></A>
<A NAME="IDX7376"></A>
<P>캐쉬 관리 프로그램은 시작된 뒤
<B>/usr/vice/etc/cacheinfo</B> 파일을 읽고 캐쉬의
캐쉬를 결정합니다. <I>AFS 빠른 시작</I>에서 설명한 것처럼, <B>afsd</B> 프로그램을 실행하기 전에 파일을 작성해야 합니다. 파일은
AFS를 마운트하는 디렉토리(일반적으로 <B>/afs</B>)와,
캐쉬 디렉토리에 사용할 로컬 디스크 디렉토리도 정의합니다.
<P>파일에 있는 값을 변경하려면, 로컬 수퍼유저 <B>루트</B>로서 로그인하십시오. 새로운 값이 적용되려면 시스템을
재부트해야 합니다. 그 명령에 대해서는
<A HREF="#HDRWQ398">cacheinfo 파일 편집하기</A>의 내용을 참조하십시오.
<P><B>cacheinfo</B> 파일을 편집하지 않고 재부트시 캐쉬
크기를 변경하려면, <B>-blocks</B> 인수를
<B>afsd</B> 명령에 포함하십시오. <I>AFS Administration Reference</I>에 있는
명령의 참조 페이지를 참조하십시오.
<P>디스크 캐쉬의 경우, <B>fs setcachesize</B> 명령을
사용하여 재부트하지 않고 캐쉬 크기를 재설정할 수도 있습니다.
설정한 값은 다음 재부트시까지 지속되며, 이 때 캐쉬 크기는
<B>cacheinfo</B> 파일에서 지정한 또는
<B>-blocks</B> 인수를 <B>afsd</B>
삽입하여 지정된 값으로 리턴됩니다.
그 명령에 대해서는 <A HREF="#HDRWQ399">재부트없이 디스크 캐쉬 크기 변경하기</A>의 내용을 참조하십시오.
<P>이 때 현재의 캐쉬 크기와 캐쉬 관리 프로그램이 사용하는 공간양을
표시하려면, <A HREF="#HDRWQ397">현재 캐쉬 크기 표시하시</A>에서 설명한 것처럼
<B>fs getcacheparms</B> 명령을 사용하십시오.
<P><H3><A NAME="HDRWQ396" HREF="auagd002.htm#ToC_440">재부트시 설정한 캐쉬 크기 표시하기</A></H3>
<OL TYPE=1>
<LI>문서 편집기나 <B>cat</B> 명령을 사용하여
<B>/usr/vice/etc/cacheinfo</B> 파일의 내용을 표시하십시오.
<P>
<PRE>   % <B>cat /usr/vice/etc/cacheinfo</B>
</PRE>
</LI></OL>
<A NAME="IDX7377"></A>
<A NAME="IDX7378"></A>
<A NAME="IDX7379"></A>
<A NAME="IDX7380"></A>
<A NAME="IDX7381"></A>
<A NAME="IDX7382"></A>
<P><H3><A NAME="HDRWQ397" HREF="auagd002.htm#ToC_441">현재 캐쉬 크기 표시하시</A></H3>
<OL TYPE=1>
<LI>클라이언트 시스템에서 <B>fs getcacheparms</B>
명령을 실행하십시오.
<P>
<PRE>   % <B>fs getcacheparms</B>
</PRE>
<P>
<P>여기서 <B>getca</B>는
<B>getcacheparms</B>의 축약형입니다.
<P>
<P>출력에서는 명령이 실행될 때 캐쉬 관리 프로그램이 캐쉬로서 사용하는
킬로바이트 블록 수와 캐쉬의 현재 크기를 보여줍니다. 예를 들면 다음과 같습니다.
<P>
<PRE>   AFS using 13709 of the cache's available 15000 1K byte blocks.
</PRE>
</LI></OL>
<A NAME="IDX7383"></A>
<A NAME="IDX7384"></A>
<A NAME="IDX7385"></A>
<A NAME="IDX7386"></A>
<A NAME="IDX7387"></A>
<P><H3><A NAME="HDRWQ398" HREF="auagd002.htm#ToC_442">cacheinfo 파일 편집하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI>문서 편집기를 사용하거나 <B>/usr/vice/etc/cacheinfo</B> 파일을 편집하십시오. 여기에는 콜론으로 구분되는 3개의 필드가
있습니다.
<UL>
<LI>첫번째 필드에서는 AFS 파일공간을 마운트하는 로컬 디렉토리의
이름을 지정합니다. 보통 위치는 <B>/afs</B>입니다.
</LI><LI>두 번째 필드에서는 디스크 캐쉬에 사용할 로컬 디스크 디렉토리를
정의합니다. 보통 위치는 <B>/usr/vice/cache</B> 디렉토리이지만, 다른 파티션에 사용할 수 있는 공간이 더 많으면
대체 디렉토리를 지정할 수도 있습니다. 이 필드에는 항상 값이 있어야
하지만, 시스템이 메모리 캐쉬를 사용하는 경우 캐쉬 관리 프로그램은
이것을 무시합니다.
</LI><LI>세 번째 필드에서는 캐쉬 크기를 킬로바이트(1024 바이트) 블록 수로
정의합니다.
</LI></UL>
<P>
<P>다음 예에서는 AFS 파일공간을 <B>/afs</B> 디렉토리로
마운트하고, <B>/usr/vice/cache</B>를 캐쉬 디렉토리로
지정하며 캐쉬 크기를 50,000 KB로 설정합니다.
<P>
<PRE>   <B>/afs:/usr/vice/cache:50000</B>
</PRE>
</LI></OL>
<A NAME="IDX7388"></A>
<A NAME="IDX7389"></A>
<A NAME="IDX7390"></A>
<A NAME="IDX7391"></A>
<A NAME="IDX7392"></A>
<A NAME="IDX7393"></A>
<P><H3><A NAME="HDRWQ399" HREF="auagd002.htm#ToC_443">재부트없이 디스크 캐쉬 크기 변경하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><A NAME="LIWQ400"></A><B>fs setcachesize</B>
명령을 실행하여 새로운 디스크 캐쉬 크기를 설정하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 명령은 메모리 캐쉬에 대해서는 동작하지 않습니다.
</TD></TR></TABLE>
<P>
<PRE>   # <B>fs setcachesize</B> &lt;<VAR>size&nbsp;in&nbsp;1K&nbsp;byte&nbsp;blocks&nbsp;(0&nbsp;=>&nbsp;reset)</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>setca</B>
</B><DD><B>setcachesize</B>의 축약형입니다.
<P><DT><B><VAR>size in 1K byte blocks (0 => reset)</VAR>
</B><DD>캐쉬에 사용할 킬로바이트 블록 수를 설정합니다.
양의 정수(<B>1024</B>는 1MB임)나 <B>0</B>을
지정하여 <B>cacheinfo</B> 파일에서 지정된
값으로 캐쉬 크기를 재설정하십시오.
</DL>
</LI></OL>
<A NAME="IDX7394"></A>
<A NAME="IDX7395"></A>
<A NAME="IDX7396"></A>
<A NAME="IDX7397"></A>
<A NAME="IDX7398"></A>
<A NAME="IDX7399"></A>
<P><H3><A NAME="Header_444" HREF="auagd002.htm#ToC_444">재부트하지 않고 디스크 캐쉬 크기로 재설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs setcachesize</B> 명령을 실행하여 로컬 디스크
캐쉬의 크기를 재설정하십시오(명령은 메모리 캐쉬에 대해서는 동작하지
않습니다). 다음 옵션 중 하나를 선택하십시오.
<UL>
<LI>캐쉬 크기를 로컬 <B>cacheinfo</B> 파일에서
지정한 값으로 재설정하려면 <B>0</B> 값을 지정하십시오.
<P>
<PRE>   # <B>fs setcachesize 0</B>
</PRE>
</LI><LI>시스템의 마지막 재부트시 설정한 값으로 캐쉬 크기를 재설정하려면,
<B>-reset</B> 플래그를 포함하십시오. <B>-blocks</B> 인수가 <B>afsd</B> 명령에서 사용되지
않았으면, 이것도 <B>cacheinfo</B> 파일에 있는 값입니다.
<P>
<PRE>   # <B>fs setcachesize -reset</B>
</PRE>
</LI></UL>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>setca</B>
</B><DD><B>setcachesize</B>의 축약형입니다.
<P><DT><B>0
</B><DD><B>/usr/vice/etc/cacheinfo</B> 파일의 세 번째
필드에 있는 값으로 디스크 캐쉬 크기를 재설정합니다.
<P><DT><B>-reset
</B><DD>마지막 재부트시 설정한 값으로 캐쉬 크기를 재설정합니다.
</DL>
</LI></OL>
<P><H3><A NAME="HDRWQ401" HREF="auagd002.htm#ToC_445">캐쉬 관리 프로그램이 버릴 데이터를 선택하는 방법</A></H3>
<P>캐쉬가 가득차고 응용프로그램이 AFS로부터 좀 더 많은 데이터를
요청할 경우, 캐쉬 관리 프로그램은 캐쉬 청크를 플러쉬하여 데이터
공간을 확보해야 합니다.
캐쉬 관리 프로그램은 다음 두 가지 사항을 고려합니다.
<OL TYPE=1>
<LI>응용프로그램이 마지막으로 데이터에 액세스했던 빈도
</LI><LI>청크가 <I>더러</I>운 지 여부. 더티 청크에는
파일 서버 시스템에 저장된 영구 사본으로 아직 저장되지 않은 파일의
변경사항이 들어 있습니다.
</LI></OL>
<P>캐쉬 관리 프로그램은 먼저 가장 오래전에 사용한 청크를 체크합니다.
이것이 더티가 아니면, 캐쉬 관리 프로그램은 그 청크에 있는 데이터를
버립니다. 청크가 더티하면, 캐쉬 관리 프로그램은 그 다음
오래전에 사용했던 청크를 계속해서 체크합니다. 충분히 많은 빈 청크를
작성할 때 까지 이러한 방식으로 계속합니다.
<P>읽기 전용 볼륨에서 패치한 데이터가 들어있는 청크는 더티하지 않은
것으로 정의되어 있으므로, 캐쉬 관리 프로그램은 항상 이 볼륨들을
버릴 수 있습니다. 보통, 캐쉬 관리 프로그램은 더티하지 않은 읽기/쓰기
볼륨에서 패치한 데이터 청크를 찾을 수 있지만, 캐쉬가 작으면 충분한
데이터를 찾기 어렵습니다. 캐쉬 관리 프로그램이 버릴 데이터를 찾지
못하면, AFS 데이터를 요청한 응용프로그램에게 입/출력 오류를 리턴해야
합니다. 응용프로그램에서는 이러한 오류를 사용자에게 통지해야 하지만,
그 원인을 밝히지는 않습니다.
<HR><H2><A NAME="HDRWQ402" HREF="auagd002.htm#ToC_446">afsd 프로그램으로 기타 캐쉬 매개변수 설정</A></H2>
<P>설정해야 하는 캐쉬 구성 매개변수는 3가지 즉, AFS용 마운트 디렉토리,
디스크 캐쉬 디렉토리 위치 및 캐쉬 크기 입니다. 이들은
<A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>에서 설명한 것처럼 <B>/usr/vice/etc/cacheinfo</B> 파일에 있는 3개의 필드에 해당됩니다.
그러나 잘 조정된 캐쉬 성능을 위해서는, <B>afsd</B>
명령에서 인수들을 사용하여 다른 여러 매개변수들을 제어할 수 있습니다.
이 절에서는 캐쉬 성능에 대해 직접 영향을 주는 이들 매개변수 몇몇에
대해 설명합니다. <B>afsd</B> 명령의 인수에 대해
알려면 <I>AFS Administration Reference</I>에 있는 참조 페이지를 참조하십시오.
<P>뿐만 아니라, 각 시스템 유형에 대한 AFS 분산에 포함된 AFS 초기설정
스크립트에는 크기와 사용 패턴이 다른 클라이언트 시스템에 적합한 여러
<B>afsd</B> 인수들을 같은 방식으로 설정하는 여러
변수가 포함됩니다. 가장 효과적으로 스크립트를 사용하는 명령에 대해서는
<I>AFS 빠른 시작</I>에 있는 캐쉬 관리 프로그램 구성 절을 참조하십시오.
<P><H3><A NAME="HDRWQ403" HREF="auagd002.htm#ToC_447">캐쉬 구성 매개변수 설정</A></H3>
<P>캐쉬 성능에 직접적으로 가장 많은 영향을 미치는 캐쉬 구성 매개변수는
다음과 같습니다.
<UL>
<LI><I>전체 캐쉬 크기.</I> 이것은 캐쉬에 사용할 수
있는 디스크 공간 또는 시스템 메모리 공간양이며,
<A HREF="#HDRWQ394">캐쉬 유형, 크기 및 위치 결정</A>에서 자세히 설명합니다.
</LI><LI><I>캐쉬 청크 수.</I> 디스크 캐쉬의 경우, 각
청크는 로컬 캐쉬 디렉토리에 있는 <B>V</B><VAR>n</VAR>
파일입니다(<A HREF="#HDRWQ393">캐쉬 관련 파일</A> 참조). 메모리 캐쉬의 경우,
각 청크는 시스템 메모리에서 할당된 연속 블록 세트입니다.
<P>
<P>이 매개변수는 전체 크기만큼 캐쉬 성능에 영향을 주지 않습니다.
그러나 이것을 조정하면 캐쉬 관리 프로그램이 새로운 데이터 공간을
마련하기 위해 캐쉬된 데이터를 버려야 하는 빈도에 영향을 줄 수
있습니다. 예를 들어 디스크 캐쉬 크기를 50MB로, 청크 수(<B>V</B><VAR>n</VAR> 파일)를 1,000으로 설정했다고 가정합니다. 시스템에 있는 10명의
사용자 각각이 평균 크기가 20KB인 100개의 AFS 파일들을 캐쉬하는 경우,
1,000개 청크 모두가 가득차지만(하나의 청크에는 하나의 AFS 파일
데이터만이 포함될 수 있음) 캐쉬에서는 20MB 데이터만을 보유합니다.
한 사용자가 파일 서버에게 데이터를 좀 더 요청하면, 캐쉬
관리 프로그램은 캐쉬가 용량의 50% 이하로 채워져있는 경우라도
캐쉬된 데이터를 버리고 다른 청크를 요청해야 합니다. 그런 경우,
청크 수를 늘리면 캐쉬 관리 프로그램이 덜 자주 데이터를 버릴 수
있습니다.
</LI><LI><I>청크 크기.</I> 이 매개변수는 한 청크에
적합한 최대 데이터 양을 결정합니다. 캐쉬된 요소가 청크 크기보다
작으면, 청크의 나머지 공간은 사용되지 않습니다(청크는 한 구성요소
이상 보유할 수 없음). 구성요소가 한 청크에 들어갈 수 없으면, 필요한
만큼의 여러 청크로 분리될 수 있습니다. 이 매개변수는 캐쉬
관리 프로그램이 한번에 파일 서버에게서 요청할 수 있는 데이터 양도
결정합니다(<I>fetch RPC</I>당 데이터 양. AFS가
부분적인 파일 전송을 사용하기 때문입니다).
<P>
<P>청크 크기를 변경하는 가장 큰 이유는 RPC당 패치되는 데이터양
때문입니다. 네트워크 연결이 매우 빠른 경우는 청크 크기를 증가시켜
성능을 향상시킬 수 있으며, 네트워크가 특히 느린 경우는 청크 크기를
줄일 수 있습니다.
</LI><LI><I>메모리내 dcache 항목 수.</I> 캐쉬
관리 프로그램은 캐쉬 관리 프로그램 각각에 대해 하나의 dcache
항목을 유지하며, 이 항목에는 청크에 해당하는 AFS 파일의 파일
ID(fID) 및 버전 번호와 같은 작은 정보를 기록합니다.
<P>
<P>디스크 캐쉬의 경우, dcache 항목은
<B>/usr/vice/cache/CacheItems</B> 파일에 있고,
액세스 속도를 늘리기 위해 시스템 메모리에서 작은 숫자가 중복됩니다.
<P>
<P>메모리 캐쉬의 경우, dcache 항목 수는 캐쉬 청크 수와 같습니다.
이 각각의 관계에 대한 설명은 <A HREF="#HDRWQ405">메모리 캐쉬 구성 제어</A>의 내용을
참조하십시오.
</LI></UL>
<P>캐쉬 관리 프로그램이 디스크 캐쉬에 있는 청크 수, 청크 크기 및 dcache
항목 수에 대한 기본값을 결정하는 방법에 대한 설명은
<A HREF="#HDRWQ404">디스크 캐쉬 구성</A>의 내용을 참조하십시오. 메모리 캐쉬의
경우는 <A HREF="#HDRWQ405">메모리 캐쉬 구성 제어</A>의 내용을 참조하십시오.
명령에서는 <B>afsd</B> 명령의 인수를 사용하여
기본값을 덮어쓰기하는 방법에 대해 설명합니다.
<P><H3><A NAME="HDRWQ404" HREF="auagd002.htm#ToC_448">디스크 캐쉬 구성</A></H3>
<P>디스크 캐쉬에 있는 캐쉬 청크(<B>V</B><VAR>n</VAR> 파일)의
기본값은 <B>afsd</B> 명령을 사용하여 다음 값 중 가장
큰 값으로 계산됩니다.
<UL>
<LI>100
</LI><LI>캐쉬 크기를 청크 크기로 나눈 결과의 1.5배(<VAR>cachesize</VAR>/<VAR>chunksize</VAR> * 1.5)
</LI><LI>캐쉬 크기를 10MB로 나눈 결과(<VAR>cachesize</VAR>/10240)
</LI></UL>
<P><B>-files</B> 인수로 양의 정수값을 지정하여 이 값을
덮어쓰기할 수 있습니다. 캐쉬 관리 프로그램이 초기설정을 완료한 뒤
<B>V</B><VAR>n</VAR> 파일 중 75% 이상이 이미 사용되었으면
이 값을 증가시키십시오. 이 때 청크 중 일부 퍼센트만이 사용되는 경우는
이를 줄이십시오. 어느 경우이든, 100 이하의 값은 지정하지 마십시오.
값이 100 이하이면 성능에 문제가 발생할 수 있습니다.
<P>다음 예에서는 <B>V</B><VAR>n</VAR> 파일 수를 2,000으로
설정합니다.
<PRE>   <B>/usr/vice/etc/afsd -files 2000</B>
</PRE>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP"><B>afsd</B> 명령을 명령 쉘에 입력하는 대신
시스템의 AFS 초기설정 파일에 삽입하는 것이 좋습니다. 뿐만 아니라,
이 절에서 지정한 값들은 단순한 예이므로, 특정 시스템에 대해서는
적합하지 않을 수 있습니다.
</TD></TR></TABLE>
<P>디스크 캐쉬의 기본 청크 크기는 64KB입니다. 일반적으로, 그 크기를
변경하는 유일한 이유는 네트워크의 속도를 예외적으로 빠르게 또는
느리게 하기 위한 것입니다. <A HREF="#HDRWQ403">캐쉬 구성 매개변수 설정</A>의 내용을
참조하십시오. <B>-chunksize</B> 인수를 사용하여
기본값을 덮어쓰기할 수 있습니다. 청크 크기는 2의 제곱이어야 하므로,
2의 지수로 사용할 값을 0과 30 이내의 값으로 제공해야 합니다. 예를
들어 값 10은 청크 크기를 1KB(2<SUP>10</SUP> =
1024)로 설정하고, 값 16은 디스크 캐쉬의 기본값(2<SUP>16</SUP> = 64 KB)과 같습니다. 0 또는 30 보다 큰 값을 지정하면 청크
크기를 기본값으로 리턴합니다. 10(1KB)보다 작은 값은 좋지 않습니다.
다음 예에서는 청크 크기를 16KB(2<SUP> 14</SUP>)로
설정합니다.
<PRE>   <B>/usr/vice/etc/afsd -chunksize 14</B>
</PRE>
<P>디스크 캐쉬의 경우, 메모리에서 복제되는 dcache 항목의 기본 갯수는
<B>-files</B> 인수에서 지정한 청크 수의 1/2이며, 최대
2,000 항목입니다. 2,000을 초과하더라도 <B>-dcache</B> 인수를 사용하여 기본값을 변경할 수 있습니다.
메모리에 있는 dcache 항목 중 1/2 이상을 복제할 필요는 없지만,
메모리에 대한 액세스가 디스크에 대한 액세스 속도보다 빠르므로 약간
성능이 향상될 수 있습니다. 다음 예에서는 숫자를 70으로 설정합니다.
<PRE>   <B>/usr/vice/etc/afsd -dcache 750</B>
</PRE>
<P>디스크 캐쉬를 구성할 때, 어떤 방식으로든 <B>afsd</B> 명령의 인수를 결합할 수 있습니다. 이렇게 유연할 수 있는 가장
큰 이유는(<B>cacheinfo</B> 파일이나
<B>-blocks</B> 인수로) 디스크 캐쉬에 지정한 설정값이
절대적인 최대 한계이기 때문입니다. <B>-files</B> 또는
<B>-chunksize</B> 인수에 대해 단독으로든 또는
결합해서 사용될 경우이든 큰 값을 지정하여 이를 덮어쓰기할 수
없습니다. 관련 이유는 캐쉬 관리 프로그램이 디스크에서 메모리
양을 유지할 필요가 없기 때문입니다. <B>V</B><VAR>n</VAR> 파일(디스크 캐쉬에 있는 청크)의 초기 길이는 0이지만, 필요한
만큼 지정된 청크 크기로 확장되고 다시 축소될 수 있습니다. 허용가능한
최대 크기로 <B>V</B><VAR>n</VAR> 파일 모두를 확장하면
전체 캐쉬 크기를 초과할 수 있는 그런 값으로 파일 수를 설정하면,
전체 크기로 간단히 성장시킬 수 없습니다.
<P><H3><A NAME="HDRWQ405" HREF="auagd002.htm#ToC_449">메모리 캐쉬 구성 제어</A></H3>
<P><B>afsd</B> 명령의 인수 결합을 허용할 수 없다는 면에서
메모리 캐쉬 구성은 디스크 캐쉬 구성과 다릅니다. 이 제한은 디스크
캐쉬보다는 메모리 캐쉬에 있는 구성 매개변수간의 상호작용으로 인해
발생합니다. 모든 결합이 허용되면, 일관성없는 방식으로 매개변수들을
설정할 수 있습니다. 수용할 수 있는 조합과 수용할 수 없는 조합
목록이 기본값 설명 다음에 옵니다.
<P>메모리 캐쉬의 기본 청크 크기는 8KB입니다. 일반적으로, 그 크기를
변경하는 유일한 이유는 네트워크의 속도를 예외적으로 빠르게 또는
느리게 하기 위한 것입니다. <A HREF="#HDRWQ403">캐쉬 구성 매개변수 설정</A>의 내용을
참조하십시오.
<P>메모리 캐쉬에서는 많은 청크에 대해 미리 정의된 기본값이 없습니다.
캐쉬 관리 프로그램은 대신 전체 캐쉬 크기를 청크 캐쉬로 나누어 정확한
숫자를 계산합니다. 메모리 캐쉬의 경우, 모든 dcache 항목이 메모리에
있음을 기억하십시오. 이것은 청크 수가 메모리에 있는 dcache 숫자와
같고, dcache 항목 수에 대한 기본값이 없음(다른 청크처럼, 총 크기를
청크 크기로 나누어 계산됨)을 의미합니다.
<P>다음은 메모리 캐쉬를 구성할 때 <B>afsd</B> 명령의 인수 중 수용할 수 있는 결합입니다.
<UL>
<LI><B>-blocks</B> 단독, 이것은
<B>/usr/vice/etc/cacheinfo</B> 파일에서 지정한 캐쉬
크기를 덮어쓰기합니다. 캐쉬 관리 프로그램은 이 인수값을 기본 청크
크기 8KB로 나누어 청크 및 dcache 항목 수를 계산합니다. 다음
예에서는 캐쉬 크기를 5MB(5,120 KB), 청크 수를 640(5,120/8)으로
설정합니다.
<P>
<PRE>   <B>/usr/vice/etc/afsd -memcache -blocks 5120</B>
</PRE>
</LI><LI><B>-chunksize</B> 단독, 8KB 기본값을
덮어쓰기합니다. 청크 크기는 2의 제곱이어야 하므로, 2의 지수로
사용할 값을 0과 30 이내의 정수로 제공해야 합니다. 예를 들어 값 10은
청크 크기를 1KB(2<SUP>10</SUP> = 1024)로 설정하고,
값 13은 메모리 캐쉬의 기본값(2<SUP>13</SUP> = 8 KB)과 같습니다. 0 또는 30 보다 큰 값을 지정하면 청크
크기가 기본값으로 리턴됩니다. 10(1KB)보다 작은 값은 좋지 않습니다.
다음 예에서는 청크 크기를 4 KB(2<SUP> 12</SUP>)로
설정합니다. 총 캐쉬 크기를 4 MB(4,096 KB)로 가정하면, 청크 수는
1024입니다.
<P>
<PRE>   <B>/usr/vice/etc/afsd -memcache -chunksize 12</B>
</PRE>
</LI><LI><B>-blocks</B> 및 <B>-chunksize</B>
가 함께 사용되면 캐쉬 크기 및 청크 크기의 기본값들을 덮어쓰기합니다.
캐쉬 관리 프로그램은 첫번째 인수의 기본값을 두 번째 인수의 기본값으로
나누어 청크 갯수와 dcache 항목 수를 계산합니다. 예를 들어 다음
예에서 캐쉬 크기를 6 MB(6,144 KB)로, 청크 크기를
4 KB(2<SUP>12</SUP>)로 설정하면
1,536개의 청크가 계산됩니다.
<P>
<PRE>   <B>/usr/vice/etc/afsd -memcache -blocks 6144 -chunksize 12</B>
</PRE>
</LI></UL>
<P>다음 인수나 조합들은 명시적으로 청크 수와 dcache 항목 수를 설정합니다.
이들을 사용하지 않는 것이 좋으며, 그 이유는 이들이 간접적으로 캐쉬
크기를 설정하여 사용자가 캐쉬 크기를 결정하려면 직접 계산하도록 하기
때문입니다. 대신 <B>-blocks</B>과
<B>-chunksize</B> 인수를 단독으로 또는 결합하여
사용하십시오. 이 경우 캐쉬 관리 프로그램은 청크 수와 dcache 항목
자체를 결정합니다. 다음 결합은 권장되는 것이 아니므로, 예에는
포함되지 않습니다.
<UL>
<LI><B>-dcache</B> 인수 단독으로는 청크 수와 dcache
항목 수를 설정합니다. 캐쉬 관리 프로그램은 이 값에 기본 청크 크기
8KB를 곱하여 총 캐쉬 크기를 생성합니다(<B>cacheinfo</B>
파일에 있는 값은 덮어쓰기).
</LI><LI><B>-dcache</B> 및 <B>-chunksize</B>을 결합하여 사용하면 청크 갯수와 크기가 결정됩니다.
캐쉬 관리 프로그램은 지정된 값을 설정하고, 이들을 함께 곱하여 총
캐쉬 크기를 구합니다(<B>cacheinfo</B> 파일에 있는
값은 덮어쓰기).
</LI></UL>
<P>메모리 캐쉬의 경우는 다음 인수를 사용하지 마십시오.
<UL>
<LI><B>-files</B> 단독. 이 인수는 디스크 캐쉬의 경우
<B>V</B><VAR>n</VAR> 파일 수를 제어하지만, 메모리
캐쉬의 경우는 무시됩니다.
</LI><LI><B>-blocks</B> 및 <B>-dcache</B>.
오류 메시지가 발생되며, 이것은 첫번째(총 크기) 값을 두 번째(청크 수)
값으로 나누면 2의 제곱이 아닌 청크 크기가 발생할 수 있는 값들을
제공할 수 있기 때문입니다.
</LI></UL>
<HR><H2><A NAME="HDRWQ406" HREF="auagd002.htm#ToC_450">데이터베이스 서버 시스템 정보 유지</A></H2>
<A NAME="IDX7400"></A>
<A NAME="IDX7401"></A>
<A NAME="IDX7402"></A>
<A NAME="IDX7403"></A>
<A NAME="IDX7404"></A>
<A NAME="IDX7405"></A>
<A NAME="IDX7406"></A>
<A NAME="IDX7407"></A>
<A NAME="IDX7408"></A>
<P>AFS 클라이언트 시스템 사용자가 셀의 AFS 파일공간과 다른 서비스에
액세스하려면, 캐쉬 관리 프로그램과 다른 클라이언트측 에이전트가
셀의 데이터베이스 서버 시스템에 대한 정확한 목록을 가지고 있어야
합니다. 이에 영향을 받는 기능들은 다음과 같습니다.
<UL>
<LI>파일 액세스. 캐쉬 관리 프로그램은 볼륨 위치(VL) 서버에 접속하여
요청된 파일이나 디렉토리가 들어있는 볼륨이 있는 파일 서버 시스템을
알 수 있습니다. 캐쉬 관리 프로그램이 셀의 VL 서버에 접속할 수
없으면, 파일을 패치할 수 없습니다.
</LI><LI>인증. <B>klog</B> 프로그램과 AFS 수정 로그인
유틸리티는 인증 서버에 접속하여 토큰을 확보하며, AFS 서버
프로세스는 사용자가 인증받았다는 증거로 토큰을 사용합니다.
</LI><LI>보호 그룹 작성. <B>pts</B> 명령 해석기는 사용자가
보호 그룹을 작성하거나 보호 데이터베이스로부터 정보를 요청할 때 보호
서버에 접속합니다.
</LI><LI>액세스 제어 목록(ACL) 편집. <B>fs</B> 명령 해석기는
파일 또는 디렉토리가 들어있는 읽기/쓰기 볼륨을 유지하는 파일 서버에
접속하며, 위치 정보는 VL 서버로부터 제공됩니다.
</LI></UL>
<P>시스템 사용자가 셀에 액세스할 수 있도록 하려면, 시스템의 로컬
디스크에 있는 <B>/usr/vice/etc/CellServDB</B> 파일에서 데이터베이스 서버 시스템의 이름과 IP 주소들을 나열해야
합니다. 시스템의 홈 셀뿐만 아니라, 사용자가 액세스할 수 있도록 하려는
외부 셀들을 나열할 수 있습니다(셀의 파일공간에 액세스할 수 있도록
하려면, 로컬 AFS 파일공간에서 <B>root.cell</B>
볼륨을 마운트해야 합니다. 보통 그 위치는 AFS 루트 디렉토리
<B>/afs</B>입니다. 명령에
대해서는 <I>AFS 빠른 시작</I>의 내용을 참조하십시오).
<P><H3><A NAME="Header_451" HREF="auagd002.htm#ToC_451">클라이언트가 데이터베이스 서버 시스템 목록을 사용하는 방법</A></H3>
<P><B>afsd</B> 프로그램이 실행되고 캐쉬 관리 프로그램을
시작하면, 커널 메모리로 <B>CellServDB</B> 파일 내용을
읽어 들입니다. 캐쉬 관리 프로그램은 시스템이 다음 번 재부트할 때 까지
파일을 다시 참조하지 않습니다. 반대로, AFS 명령 집합에 대한 명령
해석기(<B>fs</B> 및 <B>pts</B>와
같은)에서는 데이터베이스 서버 프로세스에 접속해야 할 때마다
<B>CellServDB</B> 파일을 읽습니다.
<P>셀에 대한 데이터베이스 서버 시스템 목록이 변경되면,
<B>CellServDB</B> 파일과 커널 메모리에 있는 목록
모두를 변경하여 일관성있는 클라이언트 성능을 유지해야 합니다.
시스템의 두 목록이 일치되지 않으면 몇몇 명령들이 실패할 수 있습니다.
<B>CellServDB</B> 파일과 커널 메모리 모두를 갱신하는
한 가지 방법은 파일을 편집하고 시스템을 재부트하는 것입니다.
재부트하지 않아도 되도록 하기 위해, 다음 단계 중 하나를 대신
수행할 수 있습니다.
<OL TYPE=1>
<LI><B>fs newcell</B> 명령을 실행하여 커널 메모리에서
캐쉬 관리 프로그램에 변경사항을 사용할 수 있도록 목록을 직접 변경하십시오.
</LI><LI>변경사항을 명령 해석기에서 사용할 수 있도록 <B>CellServDB</B>
파일을 편집하십시오. 파일 형식에 대해서는
<A HREF="#HDRWQ407">CellServDB 파일의 형식</A>의 내용을 참조하십시오.
</LI></OL>
<P><B>CellServDB</B> 파일이나 커널 메모리에서 정보가
누락되거나 잘못되면 다음과 같은 결과가 발생합니다.
<UL>
<LI>셀에 대한 항목이 없으면, 시스템 사용자들은 셀에 액세스할 수
없습니다.
</LI><LI>셀 항목에 데이터베이스 서버 시스템이 없으면, 캐쉬 관리 프로그램
및 명령 해석기는 시스템에 접속할 수 없습니다.
생략되어도 기타 데이터베이스 서버 시스템에 관한 정보가 정확하고 서버
프로세스, 시스템 및 네트워크가 제대로 동작하는 동안은 셀에
액세스할 수 있지만, 나열된 시스템에 부당한 부담을 줄 수 있습니다.
나열된 시스템 모두가 클라이언트에 액세스할 수 없게 되면, 누락된
데이터베이스 서버 시스템이 제대로 동작하더라도 셀에 액세스할 수 없게
됩니다.
</LI><LI>시스템 이름이나 주소가 정확하지 않거나 시스템이 실제로
데이터베이스 서버 프로세스에서 실행되고 있지 않으면,
클라이언트로부터의 요청은 만료됩니다. 사용자는 캐쉬 관리 프로그램
또는 명령 해석기가 다른 데이터베이스 서버 시스템에 접속하기 전에 전체
제한시간 동안 기다려야 하므로 긴 지연을 경험할 수 있습니다.
</LI></UL>
<P><H3><A NAME="HDRWQ407" HREF="auagd002.htm#ToC_452">CellServDB 파일의 형식</A></H3>
<A NAME="IDX7409"></A>
<A NAME="IDX7410"></A>
<P><B>/usr/vice/etc/CellServDB</B> 파일을 편집할
때에는 셀과 시스템 항목에 대해 정확한 포맷을 사용해야 합니다.
각 셀에는 별도의 항목이 있습니다. 첫번째 행의 형식은 다음과 같습니다.
<PRE>   ><VAR>cell_name</VAR>      #<VAR>organization</VAR>
</PRE>
<P>여기서 <VAR>cell_name</VAR>은 셀의 완전한 인터넷 도메인 이름(예를 들면
<B>abc.com</B>)이고, <VAR>organization</VAR>은 몇개의
공백과 번호 사인(<TT>#</TT>) 다음에 오는 선택적인 필드이므로,
셀이 해당되는 조직(예: ABC 회사)에 이름을 지정할 수 있습니다.
첫번째 행 다음에는 각 데이터베이스 서버 시스템에 대해 별도의 행이
옵니다. 각 행의 형식은 다음과 같습니다.
<PRE>   <VAR>IP_address</VAR>   #<VAR>machine_name</VAR>
</PRE>
<P>여기서 <VAR>IP_address</VAR>는 소숫점 형식으로 된 시스템의 IP
주소(예: 192.12.105.3)입니다. 몇개의 공백과 번호 사인(<TT>#</TT>)
다음에는 시스템의 완전한 호스트 이름인 <VAR>machine_name</VAR>이
옵니다(예: <B>db1.abc.com</B>). 이 경우 번호
사인은 설명을 나타내지 않으며, <VAR>machine_name</VAR>은 필수 필드입니다.
<P>셀이 표시되는 순서는 중요하지 않지만, 클라이언트 시스템의 홈 셀에
먼저 넣으면 편리합니다. 마지막 항목 다음이라도 파일에 공백 행을
넣지 마십시오.
<P>다음 예에서는 두 셀에 대한 항목들을 보여주며, 각각에는 3개의
데이터베이스 서버 시스템이 있습니다.
<PRE>   >abc.com       #ABC Corporation (home cell)
   192.12.105.3      #db1.abc.com
   192.12.105.4      #db2.abc.com
   192.12.105.55     #db3.abc.com
   >stateu.edu    #State University cell
   138.255.68.93     #serverA.stateu.edu
   138.255.68.72     #serverB.stateu.edu
   138.255.33.154    #serverC.stateu.edu
</PRE>
<P><H3><A NAME="HDRWQ408" HREF="auagd002.htm#ToC_453">클라이언트 CellServDB 파일 유지</A></H3>
<A NAME="IDX7411"></A>
<A NAME="IDX7412"></A>
<P><B>CellServDB</B> 파일에 있는 정확한 항목이 일관된
클라이언트 성능에 가장 중요하므로, 셀에 대한 데이터베이스 서버
시스템 목록이 변경될 때 마다(예를 들면 <I>AFS 빠른 시작</I>에 있는 명령을
수행하여 데이터베이스 서버 시스템을 추가하거나 제거할 때) 각
클라이언트 시스템에 있는 파일도 갱신해야 합니다. 클라이언트 갱신을
용이하게 하기 위해 <B>package</B> 프로그램을 사용할
수 있으며, 이것은 AFS에 있는 중앙 소스에서 클라이언트 시스템의 로컬
디스크로 파일을 복사합니다. 보통 시스템이 재부트하면 실행될 수 있도록
클라이언트 시스템의 초기설정 파일에서 <B>package</B>
프로그램을 호출하지만, 언제든 <B>package</B> 명령을
실행할 수도 있습니다. 명령에 대해서는 <A HREF="auagd016.htm#HDRWQ448">package 프로그램 실행</A>의
내용을 참조하십시오.
<P><B>package</B> 프로그램을 사용하는 경우, 셀의 중앙
소스 <B>CellServDB</B> 파일의 일반 위치는
<B>/afs/</B><VAR>cell_name</VAR><B>/common/etc/CellServDB</B>이며, 여기서 <VAR>cell_name</VAR>은 사용자의 셀 이름입니다.
<A NAME="IDX7413"></A>
<P><B>/usr/vice/etc/CellServDB</B>에서 AFS에 있는 중앙
소스 파일로 기호 또는 하드 연결을 작성하는 것은 사용할 수 있는
옵션이 아닙니다. <B>afsd</B> 프로그램은 캐쉬
관리 프로그램이 완전히 시작되어 AFS로 액세스할 수 있게 되기 전에
커널 메모리로 파일을 읽어 들입니다.
<P>모든 클라이언트 시스템에는 자신의 <B>CellServDB</B> 파일 사본이 있으므로, 이론적으로는 여러 시스템에서
액세스할 수 있는 셀 세트를 다르게 작성할 수 있습니다. 그러나
대부분의 경우 셀에 있는 모든 클라이언트 시스템의 파일간에
일관성을 유지하는 것이 가장 좋습니다. 시스템들이 다르면 사용자가
하나가 아닌 여러 시스템을 사용할 때 특히 혼란스럽습니다.
<P>AFS 제품 지원 그룹에서는 데이터베이스 서버 시스템이 다른 AFS 셀에
액세스할 수 있도록 하는 데 동의하는 모든 셀이 포함된 중앙
<B>CellServDB</B> 파일을 유지합니다. 갱신된
정보에 대해 주기적으로 이 파일을 체크하는 것이 좋습니다.
<A HREF="auagd007.htm#HDRWQ38">사용자의 셀을 다른 셀에서 볼 수 있게 만들기</A>를 참조하십시오.
<A NAME="IDX7414"></A>
<P>로컬 <B>CellServDB</B>에 있는 항목은 셀에 액세스하기
위한 두 개의 요구조건 중 하나입니다. 나머지는 셀의 <B>root.cell</B> 볼륨이 보통 <B>/afs</B> 디렉토리의 하위
디렉토리로서 로컬 파일공간에 마운트되는 것입니다.
명령에 대해서는 <A HREF="auagd010.htm#HDRWQ213">셀 방식 마운트 포인트를 작성하려면</A>의 내용을 참조하십시오.
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">클라이언트 시스템에 있는 <B>/usr/vice/etc/CellServDB</B> 파일은 파일 서버 시스템의 로컬 디스크에
있는 <B>/usr/afs/etc/CellServDB</B> 파일과 같지
않습니다. 서버 버전에서는 서버 시스템의 홈 셀에 있는 데이터베이스
서버 시스템만을 나열하며, 이는 서버 프로세스가 외부 셀에 접속하지
않아도 되기 때문입니다. 셀의 데이터베이스 서버 시스템을 변경할
때 마다 셀에 있는 모든 시스템에서 <B>CellServDB</B>
파일의 두 유형을 갱신하는 것은 중요합니다. 서버 버전의
<B>CellServDB</B> 파일 유지에 대해서는
<A HREF="auagd008.htm#HDRWQ118">서버 CellServDB 파일 유지</A> 내용을 참조하십시오.
</TD></TR></TABLE>
<A NAME="IDX7415"></A>
<A NAME="IDX7416"></A>
<A NAME="IDX7417"></A>
<A NAME="IDX7418"></A>
<A NAME="IDX7419"></A>
<P><H3><A NAME="Header_454" HREF="auagd002.htm#ToC_454">/usr/vice/etc/CellServDB 파일 표시하기</A></H3>
<OL TYPE=1>
<LI>문서 편집기나 <B>cat</B> 명령을 사용하여
<B>/usr/vice/etc/CellServDB</B> 파일의 내용을
표시하십시오. 기본적으로 파일에 있는 모드 비트에서 이것을 읽도록
허용합니다.
<P>
<PRE>   %
<B>cat /usr/vice/etc/CellServDB</B>
</PRE>
</LI></OL>
<A NAME="IDX7420"></A>
<A NAME="IDX7421"></A>
<P><H3><A NAME="Header_455" HREF="auagd002.htm#ToC_455">커널 메모리에서 데이터베이스 서버 시스템 목록 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs listcells</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>fs listcells [&amp;]</B> 
</PRE>
<P>
<P>여기서 <B>listc</B>는 <B>listcells</B>의 축약형입니다.
<P>
<P>쉘 프롬프트가 즉시 리턴되도록 하려면, 백그라운드에서 명령이
실행되도록 하는 앰퍼센드(<B>&amp;</B>)를
포함하십시오. 커널은 데이터베이스 서버 시스템의 IP 주소만을 저장하고,
<B>fs</B> 명령 해석기가 셀의 이름 분석 서비스(도메인
이름 서비스 또는 로컬 호스트 테이블)를 호스트 이름으로 번역하므로,
완전한 출력을 생성하는 데에는 다소 시간이 소요될 수 있습니다.
<B>Ctrl-c</B>와 같은 인터럽트 신호를 실행하여
언제든지 명령을 중지할 수 있습니다.
<P>
<P>출력에는 각 셀에 대한 행이 포함되며, 그 형식은 다음과 같습니다.
<P>
<PRE>   Cell <VAR>cell_name</VAR> on hosts <VAR>list_of_hostnames</VAR>.
</PRE>
<P>
<P>때때로 이름 서비스에서는 호스트 이름을 대문자로 리턴하며, 이름을
전혀 해석할 수 없는 경우는 이름의 IP 주소를 리턴합니다.
다음 예에서는 3가지 가능성에 대해 설명합니다.
<P>
<PRE>   %
<B>fs listcells</B>
      .
      .
   Cell abc.com on hosts db1.abc.com db2.abc.com db3.abc.com
   Cell stateu.edu on hosts SERVERA.STATEU.EDU SERVERB.STATEU.EDU 
			    SERVERC.STATEU.EDU
   Cell ghi.org on hosts 191.255.64.111 191.255.64.112
      .
      .
</PRE>
</LI></OL>
<A NAME="IDX7422"></A>
<A NAME="IDX7423"></A>
<A NAME="IDX7424"></A>
<A NAME="IDX7425"></A>
<A NAME="IDX7426"></A>
<A NAME="IDX7427"></A>
<A NAME="IDX7428"></A>
<A NAME="IDX7429"></A>
<A NAME="IDX7430"></A>
<A NAME="IDX7431"></A>
<A NAME="IDX7432"></A>
<P><H3><A NAME="Header_456" HREF="auagd002.htm#ToC_456">커널 메모리에서 셀의 데이터베이스 서버 시스템 목록 변경하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>CellServDB</B> 파일의 중앙 사본을 클라이언트
시스템에 대한 소스로 사용하는 경우, 디렉토리의 ACL에서 사용자에게
<B>l</B>(<B>조회</B>),
<B>r</B>(<B>읽기</B>) 및
<B>w</B>(<B>기록</B>) 권한을
허용했는 지 확인하십시오. 일반 디렉토리는 <B>/afs/</B><VAR>cell_name</VAR><B>/common/etc</B>입니다.
필요하면 <B>fs listacl</B> 명령을 실행하십시오.
이에 대한 전체 설명은 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 설명합니다.
<P>
<PRE>   # <B>fs listacl</B> [&lt;<VAR>dir/file&nbsp;path</VAR>>]
</PRE>
<A NAME="IDX7433"></A>
<A NAME="IDX7434"></A>
</LI><LI><A NAME="LINEWCELL"></A><B>fs newcell</B> 명령을 실행하여
커널 메모리에서 셀 항목을 추가하거나 변경하십시오. 각 셀에 명령을
반복하십시오.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 명령을 사용하여 커널 메모리에서 완전히 셀 항목을
제거할 수는 없습니다. 아주 드물게 특정 셀에 대한 액세스를 갑자기
금지해야 하는 경우, <B>CellServDB</B> 파일을 편집하고
시스템을 재부트해야 합니다.
</TD></TR></TABLE>
<P>
<PRE>   # <B>fs newcell</B> &lt;<VAR>cell&nbsp;name</VAR>> &lt;<VAR>primary&nbsp;servers</VAR>><SUP>+</SUP> \
                [<B>-linkedcell</B> &lt;<VAR>linked&nbsp;cell&nbsp;name</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>n
</B><DD><B>newcell</B>의 축약형입니다.
<P><DT><B><VAR>cell name</VAR>
</B><DD>데이터베이스 서버 시스템의 새로운 목록을 기록할 셀의 완전한
인터넷 도메인 이름을 지정합니다.
<P><DT><B><VAR>primary servers</VAR>
</B><DD>셀에 있는 각 데이터베이스 서버 시스템에 대한 완전한 호스트 이름
또는 IP 주소를 소숫점 형식으로 지정합니다. 제공하는 목록은 기존
목록을 완전히 바꿉니다.
<P><DT><B>-linkedcell
</B><DD>AFS 파일세트 위치를 위해 DCE 셀로 연결할 AFS 셀의 완전한
인터넷 도메인 이름을 지정합니다. 시스템의 AFS 사용자가 AFS/DFS
이주 툴킷 프로토콜 전송기를 통해 AFS에 액세스하는 경우 이 인수를
사용할 수 있습니다. 자세한 정보는 <I>AFS/DFS Migration Toolkit Administration Guide and Reference</I>를 참조하십시오.
</DL>
</LI><LI>다음 3 방법 중 하나를 사용하여 로컬 <B>/usr/vice/etc/CellServDB</B> 파일에서 셀 항목을 추가 또는 편집하십시오. 각각의 경우,
<A HREF="#HDRWQ407">CellServDB 파일의 형식</A>에서 설명한 형식화 요구조건을
만족하도록 하십시오.
<UL>
<LI>중앙 소스 버전의 <B>CellServDB</B> 파일을 유지하고
<B>package</B> 프로그램을 사용하는 경우, 먼저 문서
편집기를 사용하여 파일의 중앙 사본을 변경하십시오. 그런 다음 <B>package</B> 명령을 실행하여 파일 내용을 로컬 시스템으로 전송하십시오.
완전한 명령에 대해서는 <A HREF="auagd016.htm#HDRWQ448">package 프로그램 실행</A>의 내용을 참조하십시오.
<P>
<PRE>   #
<B>/etc/package -v -c</B> &lt;<VAR>name&nbsp;of&nbsp;package&nbsp;file</VAR>>
</PRE>
</LI><LI>중앙 소스 <B>CellServDB</B> 파일을 유지하지만
<B>package</B> 프로그램은 사용하지 않는 경우, 먼저
문서 편집기를 사용하여 파일의 중앙 사본을 변경하십시오. 그런 다음
<B>cp</B> 명령과 같은 복사 명령을 사용하여 이를 로컬
<B>/usr/vice/etc/CellServDB</B> 파일로 복사하십시오.
</LI><LI>중앙 소스 <B>CellServDB</B> 파일을 사용하지
않는 경우, 로컬 시스템의
<B>/usr/vice/etc/CellServDB</B> 파일을 직접 편집하십시오.
</LI></UL>
</LI></OL>
<HR><H2><A NAME="HDRWQ409" HREF="auagd002.htm#ToC_457">클라이언트가 Setuid 프로그램을 실행할 수 있는 지 결정</A></H2>
<A NAME="IDX7435"></A>
<A NAME="IDX7436"></A>
<A NAME="IDX7437"></A>
<P><I>setuid 프로그램</I>은 2진 파일에서 UNIX setuid
모드 비트가 온으로 되는 것입니다. setuid 프로그램을 실행하는 동안,
이 프로그램을 시작했던 사용자는 로컬 ID(UNIX UID)를 로컬
소유자로서 가정하므로, 소유자에게 적합한 로컬 파일 시스템에서의
권한을 부여합니다. 대부분 사용자가 생각하는 ID(보통
<I>유효한 UID</I>)는 로컬 수퍼유저 <B>루트</B>입니다.
<P>AFS가 유효 UID를 인식하지 않습니다. setuid 프로그램이 파일과
디렉토리에 액세스하는 경우, 프로그램 소유자가 아닌 프로그램을
시작했던 사용자의 현재 AFS ID를 사용합니다. 그럼에도 하나 이상의
클라이언트 시스템에서 사용할 수 있도록 AFS에 setuid 프로그램을
저장하는 것이 유용할 수 있습니다. AFS를 사용하면 클라이언트 시스템의
관리자가 로컬 캐쉬 관리 프로그램이 setuid 프로그램을 실행하도록
허용하는 지 여부를 결정할 수 있습니다.
<P>기본적으로 캐쉬 관리 프로그램을 사용하면 자신의 홈 셀에서 setuid
권한을 가지고 프로그램을 실행할 수 있지만, 외부 셀에 있는 프로그램에
대해서는 setuid 권한을 거부합니다. 프로그램은 파일 서버 시스템의
<B>/usr/afs/etc/ThisCell</B> 파일에서 지정된 바와
같이, 파일이 있는 볼륨이 상주하는 파일 서버 시스템과 같은 셀에
속합니다. 캐쉬 관리 프로그램은 초기설정시 <B>/usr/vice/etc/ThisCell</B> 파일을 읽고 자신의 홈 셀을 결정합니다.
<P>로컬 시스템 측면에서 셀의 setuid 상태를 변경하려면, 로컬 수퍼유저
<B>루트</B>가 되어 <B>fs setcell</B>
명령을 실행하십시오. 셀의 현재 setuid 상태를 결정하려면
<B>fs getcellstatus</B> 명령을 실행하십시오.
<P><B>fs setcell</B> 명령을 실행할 때, 커널 메모리에
기록된 것처럼 셀의 setuid 상태를 직접 변경하므로, 시스템을
재부트하지 않아도 됩니다. 그러나 기본값이 아닌 설정값은 적합한
<B>fs setcell</B> 명령을 시스템의 AFS 초기설정 파일에
추가하지 않으면 시스템 재부트시 유지되지 않습니다.
<P><B>system:administrators</B> 그룹의 유일한 구성원들은
AFS 파일 또는 디렉토리에서 setuid 모드 비트를 온으로 설정할 수
있습니다. setuid 모드 비트가 온이 되면, UNIX <B>ls
-l</B> 명령에서는 <B>x</B> 대신
<B>s</B>로 세 번째 사용자 모드 비트를 표시하지만, AFS
파일 또는 디렉토리에서는 파일이 있는 셀에 setuid 권한이 허용되는
경우에만 <B>s</B>가 나타납니다.
<A NAME="IDX7438"></A>
<A NAME="IDX7439"></A>
<P><H3><A NAME="Header_458" HREF="auagd002.htm#ToC_458">셀의 setuid 상태 결정하기</A></H3>
<OL TYPE=1>
<LI><B>fs getcellstatus</B> 명령을 실행하여 원하는 각
셀의 setuid 상태를 확인하십시오.
<P>
<PRE>   % <B>fs getcellstatus</B> &lt;<VAR>cell&nbsp;name</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>getce</B>
</B><DD><B>getcellstatus</B>의 축약형입니다.
<P><DT><B><VAR>cell name</VAR>
</B><DD>setuid 상태를 알려주는 각 셀의 이름입니다. 로컬
<B>/usr/vice/etc/CellServDB</B> 파일에 나열된 다른
셀과 구분하는 완전한 인터넷 도메인 이름 또는 축약형 이름을 제공합니다.
</DL>
</LI></OL>
<P>출력에서는 각 셀의 setuid 상태를 알려줍니다.
<UL>
<LI><TT>no setuid allowed</TT> 문자열은 캐쉬 관리 프로그램이 셀의
프로그램이 setuid 권한으로 실행되지 않도록 불허함을 나타냅니다.
</LI><LI><TT>setuid allowed</TT> 문자열은 캐쉬 관리 프로그램이 셀
프로그램이 setuid 권한으로 실행되도록 허용함을 나타냅니다.
</LI></UL>
<A NAME="IDX7440"></A>
<A NAME="IDX7441"></A>
<P><H3><A NAME="Header_459" HREF="auagd002.htm#ToC_459">셀의 setuid 상태 변경하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs setcell</B> 명령을 실행하여 셀의
setuid 상태를 변경하십시오.
<P>
<PRE>   # <B>fs setcell</B> &lt;<VAR>cell&nbsp;name</VAR>><SUP>+</SUP> [<B>-suid</B>] [<B>-nosuid</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>setce</B>
</B><DD><B>setcell</B>의 축약형입니다.
<P><DT><B><VAR>cell name</VAR>
</B><DD><B>-suid</B> 또는 <B>-nosuid</B>
플래그로 지정된 대로 setuid 상태를 변경하는 각 셀의 이름입니다. 로컬
<B>/usr/vice/etc/CellServDB</B> 파일에 나열된 다른 셀과
구분하는 각 셀의 완전한 인터넷 도메인 이름 또는 축약형 양식을 제공합니다.
<P><DT><B><B>-suid</B>
</B><DD>지정된 각 셀에서 setuid 권한으로 프로그램을 실행할 수
있도록 합니다. 이 플래그나 <B>-nosuid</B> 플래그 중
하나를 사용하거나, 모두를 생략하여 각 셀에 대한 setuid 권한을 사용
불가능하게 설정하십시오.
<P><DT><B><B>-nosuid</B>
</B><DD>지정된 각 셀에서 프로그램이 setuid 권한으로 실행되지 않도록
합니다. 이 플래그나 <B>-suid</B> 플래그 중 하나를
사용하거나, 모두를 생략하여 각 셀에 대해 setuid 권한을 사용불가능하게
설정하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ410" HREF="auagd002.htm#ToC_460">파일 서버 탐침 간격 설정</A></H2>
<A NAME="IDX7442"></A>
<A NAME="IDX7443"></A>
<A NAME="IDX7444"></A>
<P>캐쉬 관리 프로그램은 서버 시스템을 정기적으로 탐침하여 계속해서
사용할 수 있는 지 확인합니다. 특히 셀과, 캐쉬된 데이터가 있는
파일 서버에서 데이터베이스 서버 시스템을 탐침합니다.
<P>서버 프로세스에 탐침에 반응하지 않으면, 클라이언트 시스템은 이에
액세스할 수 없는 것으로 생각합니다. 기본적으로 탐침 간격은 3분이므로,
클라이언트가 서버 프로세스가 액세스할 수 없게 된 후 다시 액세스할
수 있게 되었음을 인식하기 까지는 최대 3분이 소요될 수 있습니다.
<P>탐침 간격을 조정하려면, 로컬 수퍼유저 <B>루트</B>로서
로그인하는 동안 <B>-interval</B> 인수를
<B>fs checkservers</B> 명령에 포함하십시오.
새로운 간격 설정값은 명령을 실행하거나 시스템을 재부트할 때 까지
유지되며, 설정값 시간은 기본값으로 리턴됩니다. 재부트시 기본값이 아닌
설정값을 유지하려면, 시스템의 AFS 초기설정 파일에 해당
<B>fs checkservers</B> 명령을 포함하십시오.
<P><H3><A NAME="Header_461" HREF="auagd002.htm#ToC_461">클라이언트의 파일 서버 탐침 간격 설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs checkservers</B> 명령을 <B>-interval</B> 인수와 함께 실행하십시오. 
<A NAME="IDX7445"></A>
<A NAME="IDX7446"></A>
<P>
<P>
<PRE>   # <B>fs checkservers -interval</B> &lt;<VAR>seconds&nbsp;between&nbsp;probes</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>checks</B>
</B><DD><B>checkservers</B>의 축약형입니다.
<P><DT><B>-interval
</B><DD>탐침간의 초 수를 지정합니다. 0보다 큰 정수값을 제공합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ411" HREF="auagd002.htm#ToC_462">클라이언트 시스템의 셀 멤버쉽 설정</A></H2>
<A NAME="IDX7447"></A>
<A NAME="IDX7448"></A>
<A NAME="IDX7449"></A>
<A NAME="IDX7450"></A>
<A NAME="IDX7451"></A>
<A NAME="IDX7452"></A>
<P>각각의 클라이언트 시스템들은 특별한 셀에 속하며, 이것은 로컬 디스크의
<B>/usr/vice/etc/ThisCell</B>에서 지정됩니다.
시스템의 셀 멤버쉽은 시스템 사용자에게 중요한 3개의 기본값을
결정합니다.
<UL>
<LI><B>login</B> 프로그램을 사용하거나 <B>klog</B> 명령을 실행할 때 토큰(인증)을 확보한 시스템 사용자의 셀.
두 가지 효과가 있습니다.
<UL>
<LI><B>klog</B> 프로그램 및 AFS 수정 로그인 유틸리티는
<B>ThisCell</B> 파일에서 지정한 셀에서 인증 서버에 접속합니다.
</LI><LI><B>klog</B> 프로그램 및 AFS 수정 로그인 유틸리티는
사용자가 제공한 암호와 <B>ThisCell</B> 파일 내용을
결합하여, 암호화 키를 생성합니다. 인증 데이터베이스에 있는 사용자
항목에는 암호와 셀 이름을 결합하여 생성한 암호화 키도 포함됩니다.
<B>ThisCell</B> 파일에 있는 셀 이름이 틀리면, 사용자가
정확한 암호를 제공하는 경우라도 인증할 수 없습니다.
</LI></UL>
</LI><LI>캐쉬 관리 프로그램이 로컬, 또는 홈 셀로 생각하는 셀. 캐쉬
관리 프로그램을 사용하면 로컬 셀에서 프로그램이 setuid 권한으로
실행될 수 있지만, 외부 셀에서는 프로그램을 실행할 수 없습니다. 이에
대해서는 <A HREF="#HDRWQ409">클라이언트가 Setuid 프로그램을 실행할 수 있는 지 결정</A>에서 자세히 설명합니다.
</LI><LI>이 시스템에서 실행중인 AFS 명령 해석기가 접속하는 기본
데이터베이스 서버 시스템
</LI></UL>
<P><H3><A NAME="Header_463" HREF="auagd002.htm#ToC_463">클라이언트 시스템의 셀 멤버쉽 표시하기</A></H3>
<OL TYPE=1>
<LI>문서 편집기나 <B>cat</B> 명령을 사용하여
<B>/usr/vice/etc/ThisCell</B> 파일을 내용을 표시하십시오.
<P>
<PRE>   % <B>cat /usr/vice/etc/ThisCell</B>
</PRE>
</LI></OL>
<P><H3><A NAME="Header_464" HREF="auagd002.htm#ToC_464">클라이언트 시스템의 셀 멤버쉽 설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI>문서 편집기를 사용하여 <B>/usr/vice/etc/ThisCell</B> 파일에 있는 셀 이름을 바꾸십시오.
</LI><LI><B>(선택적)</B> 시스템을 재부트하여 캐쉬
관리 프로그램이 새로운 셀 이름을 즉시 사용할 수 있도록 합니다.
해당 명령은 시스템의 시스템 유형에 따라 달라집니다.
<B>klog</B> 프로그램, AFS 수정 로그인 유틸리티 및
AFS 명령 해석기는 다음번 호출할 때 새로운 셀 이름을 사용하며,
재부트는 필요하지 않습니다.
<P>
<PRE>   # <B>sync</B>
   
   # <B>shutdown</B>
</PRE>
</LI></OL>
<HR><H2><A NAME="HDRWQ412" HREF="auagd002.htm#ToC_465">캐쉬된 데이터 갱신 강요하기</A></H2>
<A NAME="IDX7453"></A>
<A NAME="IDX7454"></A>
<A NAME="IDX7455"></A>
<A NAME="IDX7456"></A>
<A NAME="IDX7457"></A>
<A NAME="IDX7458"></A>
<A NAME="IDX7459"></A>
<A NAME="IDX7460"></A>
<P>AFS의 콜백 메카니즘에서는 보통 캐쉬 관리 프로그램이 시스템에서
실행중인 응용프로그램에게 가장 최근 버전의 파일 또는 디렉토리를
제공하도록 합니다. 그러나 응용프로그램이 캐쉬된 데이터를 다음번에
요청할 때 캐쉬 관리 프로그램가 파일 서버에서 사용할 수 있는 최근
버전을 패치할 수 있도록 캐쉬 관리 프로그램에게 캐쉬된 데이터를
버리도록 (플러쉬)할 수 있습니다.
<P>한번에 플러쉬할 파일 시스템 구성요소 갯수를 제어할 수 있습니다.
<UL>
<LI>특정 파일이나 디렉토리만을 플러쉬하려면 <B>fs flush</B> 명령을 사용하십시오. 이 명령은 캐쉬 관리 프로그램에게
지정된 파일이나 디렉토리에서 캐쉬한 데이터 및 상태 정보를 버리도록
합니다. 응용프로그램 버퍼 정보나 국지적으로 변경된 정보(캐쉬에서는
변경되었지만 아직 파일 서버에 영구적으로 변경되지 않음)는 버리지
않습니다. 그러나 다음 번에 응용프로그램이 구성요소의 데이터나 상태 정보를
요청할 때, 캐쉬 관리 프로그램은 이를 얻기 위해 파일 서버에 접속해야
합니다.
</LI><LI>어떤 볼륨에서 캐쉬된 모두를 플러쉬하려면, <B>fs flushvolume</B> 명령을 사용하십시오. 이 명령은 <B>fs flush</B> 명령과 유사하게 동작하지만 두 가지 점에서 다릅니다.
<UL>
<LI>캐쉬 관리 프로그램은 지정된 파일 또는 디렉토리과 같은 볼륨에서
온 캐쉬내의 모든 구성요소 데이터를 버립니다.
</LI><LI>캐쉬 관리 프로그램은 상태 정보가 아닌 데이터만을 버립니다.
이 차이점이 실제에서는 약간의 효과가 있지만, 같은 구성요소에 대해
다른 두 명령을 사용할 경우 <B>ls</B> 명령의 출력이
달라질 수 있습니다.
</LI></UL>
</LI></UL>
<P>콜백뿐만 아니라, 캐쉬 관리 프로그램에는 볼륨 위치 변경과 같은 다른
종류의 변경사항을 추적하는 메카니즘도 있습니다. 볼륨이 이동하고
캐쉬 관리 프로그램이 오랜 시간동안 여기에 그 볼륨에 있는 데이터에
액세스하지 않으면, 캐쉬 관리 프로그램의 볼륨 위치 레코드는 틀려질 수
있습니다. 이를 다시 동기화하려면 <B>fs
checkvolumes</B> 명령을 사용하십시오. 명령을 실행할 때, 캐쉬
관리 프로그램은 볼륨 이름, ID 번호 및 위치간의 새로운 맵핑 테이블을
작성합니다. 그렇게 하면 캐쉬 관리 프로그램이 이들에 대한 데이터를
제공하기 전에 새롭게 위치지정되고 이름이 지정된 볼륨을 참조할 수 있습니다.
<P>캐쉬에서 마운트 포인트에 대한 정보가 훼손될 수도 있습니다.
마운트 포인트가 훼손되었다는 징후는 <B>fs lsmount</B>
명령의 출력이 잘못되었거나, 디렉토리를 변경하거나 마운트 포인트 내용을
표시하려는 시도가 실패하는 것입니다. <B>fs flushmount</B> 명령을 사용하여 잘못된 마운트 포인트를 버리십시오.
캐쉬 관리 프로그램은 다음번에 경로 이름에서 이를 참조할 때
마운트 포인트를 다시 패치해야 합니다(캐쉬 관리 프로그램은 주기적으로
캐쉬된 마운트 포인트를 새로 고치지만, 이것을 즉시 버리는 또 다른 방법은
시스템을 재부트하여 캐쉬 관리 프로그램을 다시 초기설정하는 것입니다).
<A NAME="IDX7461"></A>
<A NAME="IDX7462"></A>
<P><H3><A NAME="Header_466" HREF="auagd002.htm#ToC_466">파일 또는 디렉토리 플러쉬하기</A></H3>
<OL TYPE=1>
<LI><B>fs flush</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs flush</B> [&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>flush</B>
</B><DD>모두를 입력해야 합니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>캐쉬에서 플러쉬할 파일이나 디렉토리 구조의 이름입니다. 이
인수를 생략하면 현재 작업 디렉토리가 플러쉬됩니다.
디렉토리 구조를 플러쉬해도 여기에 캐쉬된 파일 또는 하위 디렉토리가
플러쉬되지는 않습니다.
</DL>
</LI></OL>
<A NAME="IDX7463"></A>
<A NAME="IDX7464"></A>
<P><H3><A NAME="Header_467" HREF="auagd002.htm#ToC_467">볼륨의 모든 데이터 플러쉬하기</A></H3>
<OL TYPE=1>
<LI><B>fs flushvolume</B> 명령을 실행하십시오.
<P>
<PRE>  %
<B>fs flushvolume</B> [&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>flushv</B>
</B><DD><B>flushvolume</B>의 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>캐쉬에서 플러쉬할 각 볼륨의 파일 또는 디렉토리 이름입니다.
캐쉬 관리 프로그램은 같은 볼륨에서 패치한 캐쉬에 있는 모든 것을
플러쉬합니다. 이 인수를 생략하면 현재 작업 디렉토리가 포함되는
볼륨에서 패치한 모든 캐쉬 데이터들이 플러쉬됩니다.
</DL>
</LI></OL>
<A NAME="IDX7465"></A>
<A NAME="IDX7466"></A>
<P><H3><A NAME="Header_468" HREF="auagd002.htm#ToC_468">캐쉬 관리 프로그램이 기타 볼륨 변경사항 알리도록 하기</A></H3>
<OL TYPE=1>
<LI><B>fs checkvolumes</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>fs checkvolumes</B>
</PRE>
<P>
<P>여기서 <B>checkv</B>는 <B>checkvolumes</B>의 축약형입니다.
</LI></OL>
<P>다음 명령으로 명령이 완전히 성공했음을 확인할 수 있습니다.
<PRE>   All volumeID/name mappings checked.
</PRE>
<A NAME="IDX7467"></A>
<A NAME="IDX7468"></A>
<P><H3><A NAME="HDRWQ413" HREF="auagd002.htm#ToC_469">하나 이상의 마운트 포인트 플러쉬하기</A></H3>
<OL TYPE=1>
<LI><B>fs flushmount</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>fs flush</B> [&lt;<VAR>dir/file&nbsp;path</VAR>><SUP>+</SUP>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B><B>flushm</B>
</B><DD><B>flushmount</B>의 축약형입니다.
<P><DT><B><VAR>dir/file path</VAR>
</B><DD>캐쉬에서 플러쉬할 마운트 포인트의 이름입니다. 이 인수를 생략하면
현재 작업 디렉토리가 플러쉬됩니다. 연관된 볼륨에서 캐쉬한 파일 또는
하위 디렉토리들은 영향을 받지 않습니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ414" HREF="auagd002.htm#ToC_470">서버 선호 사항 순위 유지</A></H2>
<A NAME="IDX7469"></A>
<A NAME="IDX7470"></A>
<A NAME="IDX7471"></A>
<A NAME="IDX7472"></A>
<A NAME="IDX7473"></A>
<A NAME="IDX7474"></A>
<P>이 장의 소개에서 설명한 바와 같이, AFS는 클라이언트측 데이터 캐쉬와
콜백을 사용하여 셀에서의 네트워크 통신량을 줄입니다. 캐쉬
관리 프로그램은 로컬 시스템에 대한 네트워크 근접도를 근거로 서버
시스템에 <I>선호 사항 순위</I>를 지정하여 가능한
효과적으로 네트워크를 사용하려고 시도합니다. 순위는 캐쉬
관리 프로그램이 다른 네트워크가 아닌 자신의 서브네트워크나 네트워크에
있는 서버 시스템 정보에서 정보를 패치하도록 합니다.
클라이언트와 서버 사이에서 데이터가 이동되는 네트워크 거리를 줄이면
네트워크 통신량이 줄어들고, 캐쉬 관리 프로그램이 응용 프로그램에
데이터를 전달하는 속도가 늘어납니다.
<P>캐쉬 관리 프로그램은 커널 메모리에 별도의 두 가지 선호 사항 순위를
저장합니다. 첫번째 순위 세트는 볼륨 위치(VL) 서버 프로세스를
실행하는 시스템에 적용되며, 이후부터는 <I>VL 서버
시스템</I>이라고 합니다. 두 번째 순위 세트는 파일 서버 프로세스를
실행하는 시스템에 적용되며, 이후 부터는 <I>파일 서버
시스템</I>이라고 합니다. 이 절에서는 캐쉬 관리 프로그램이 기본
순위를 설정하는 방법, <B>fs setserverprefs</B> 명령을
사용하여 기본 순위를 변경하거나 새로운 순위를 설정하는 방법, 그리고
<B>fs getserverprefs</B> 명령을 사용하여 현재 순위
세트를 표시하는 방법에 대해 설명합니다.
<P><H3><A NAME="Header_471" HREF="auagd002.htm#ToC_471">캐쉬 관리 프로그램이 기본 순위를 설정하는 방법</A></H3>
<P><B>afsd</B> 프로그램이 캐쉬 관리 프로그램을 시작한
뒤에는, 로컬 <B>/usr/vice/etc/CellServDB</B> 파일에
나열된 VL 서버 시스템 각각에 선호 사항 순위 10,000을 지정합니다. 그런
다음 0 - 126 범위내에서 임의로 선택한 정수를 추가하여 순위를 무작위로
작성합니다. 이렇게 하면 같은 순위를 한 셀에 있는 여러 시스템에
지정하지 않게 되지만, 다른 셀에 있는 시스템들이 같은 순위를 갖게
될 수는 있습니다.
그렇다고 사용상 문제점이 예방되는 것은 아닙니다. 캐쉬 관리 프로그램이
한번에 한 셀의 데이터베이스 서버 기계 순위들을 비교하기 때문입니다.
AFS가 멀티홈 데이터베이스 서버 시스템의 사용을 지원하더라도, 캐쉬
관리 프로그램은 로컬 <B>/usr/vice/etc/CellServDB</B>
파일에 있는 각 데이터베이스 서버 시스템용으로 나열된 하나의 주소만을
사용합니다. Ubik만이 멀티홈 데이터베이스 서버 시스템의 다중
인터페이스의 장점을 이용할 수 있습니다.
<P>캐쉬 관리 프로그램은 VL 서버로부터 서버의 VLDB 레코드를 확보할 때
파일 서버 시스템으로 선호 사항 순위를 지정하며, 처음에는 시스템에
있는 볼륨에 액세스합니다. 시스템이 멀티홈인 경우, 캐쉬
관리 프로그램은 인터페이스 각각에 고유한 순위를 지정합니다(각
시스템에 대해 VLDB가 저장할 수 있는 최대 인터페이스까지. 이것은
<I>AFS 릴리스 노트</I>에서 지정됩니다). 캐쉬 관리 프로그램은 인터페이스의
IP 주소를 로컬 시스템의 주소와 비교하며, 다음 알고리즘을 적용합니다.
<UL>
<LI>로컬 시스템이 파일 서버 시스템인 경우, 인터페이스 각각에 대한
기본 순위는 5,000입니다.
</LI><LI>파일 서버 시스템 인터페이스가 로컬 시스템과 같은 서브 네트워크상에
있으면, 이것의 기본 순위는 20,000입니다.
</LI><LI>파일 서버 시스템 인터페이스가 로컬 시스템과 같은 네트워크상에
있거나 로컬 시스템과의 점대점 연결에서 끝에 있는 경우, 이것의 기본
순위는 30,000입니다.
</LI><LI>파일 서버 시스템이 로컬 시스템과 다른 네트워크상에 있는 경우
또는 캐쉬 관리 프로그램이 이에 대한 네트워크 정보를 얻을 수 없는
경우, 이것의 기본 순위는 40,000입니다.
</LI></UL>
<P>클라이언트 시스템에 하나의 인터페이스만 있는 경우, 캐쉬 관리
프로그램은 이를 서버 인터페이스의 IP 주소와 비교한 다음, 알고리즘에
따라 순위를 설정합니다. 클라이언트 시스템이 멀티홈인 경우, 캐쉬
관리 프로그램은 로컬 인터페이스 주소 각각을 서버 인터페이스와
비교한 다음, 클라이언트 인터페이스 모두와 비교하여 얻은 최하위
순위를 서버 인터페이스에 지정합니다.
<P>기본 순위를 파일 서버 시스템 인터페이스에 지정한 뒤, 캐쉬
관리 프로그램은 0 - 15 이내에서 임의로 선택한 번호를 이에 추가합니다.
예에서 처럼, 로컬 시스템과 같은 서브네트워크에 있는 파일 서버 시스템
인터페이스에는 기본 순위 20,000이 지정되지만, 캐쉬 관리 프로그램은
20,000 - 20,015 이내의 정수로 실제 순위를 기록합니다. 이 프로세스로
실제로 같은 순위에 있는 인터페이스 수가 줄어듭니다. VL 서버 시스템
순위와 같이, 외부 셀에 있는 파일 서버 시스템 인터페이스가 로컬 셀에
있는 인터페이스와 같은 순위를 갖을 수 있지만, 문제를 예방할 수는
없습니다. 특정 볼륨이 들어있는 인터페이스의 상대 순위만이 관계되며,
AFS는 한번에 한 셀에 있는 볼륨 기억영역만을 지원합니다.
<P><H3><A NAME="Header_472" HREF="auagd002.htm#ToC_472">캐쉬 관리 프로그램이 선호 사항 순위를 사용하는 방법</A></H3>
<P>각각의 선호 사항 순위는 인터페이스의 IP 주소와 1 - 65,534 이내의
정수로 한 쌍이 됩니다. 낮은 순위(하위 번호)는 강력한 선호 사항을
나타냅니다. 일단 순위가 설정되면, 시스템이 재부트할 때 까지, 또는
<B>fs setserverprefs</B> 명령을 사용하여 변경할 때
까지 지속됩니다.
<P>캐쉬 관리 프로그램은 셀에서 볼륨 위치 정보를 패치해야 할 때 VL 서버
시스템 순위를 사용합니다. 셀의 CL 기계 시스템 순위와 비교하여
최상의(최하 번호) 순위를 가진 시스템의 VL 서버 프로세스와 접속하려 합니다.
그 VL 서버에 접속할 수 없으면, 그 다음 순위의 VL 서버에 접속하려
합니다. 셀의 VL 서버 시스템 모두에 액세스할 수 없는 경우, 캐쉬
관리 프로그램은 셀에서 데이터를 패치할 수 없습니다.
<P>이와 유사하게 캐쉬 관리 프로그램이 볼륨에서 데이터를 패치해야 하는
경우, 볼륨이 있는 시스템의 인터페이스 순위와 비교하고 최상위 순위를
갖는 인터페이스에 접속하려 합니다. 그 인터페이스를 통해
<B>fileserver</B> 프로세스와 접속할 수 없으면, 그 다음
순위의 인터페이스에 접속을 시도합니다. 볼륨이 들어있는 시스템의
인터페이스에 접속할 수 없으면, 볼륨에서 데이터를 패치할 수 없습니다.
<P><H3><A NAME="Header_473" HREF="auagd002.htm#ToC_473">선호 사항 순위 표시 및 설정</A></H3>
<P>캐쉬 관리 프로그램이 사용하는 파일 서버 시스템 순위를 표시하려면
<B>fs getserverprefs</B> 명령을 사용하십시오.
<B>-vlservers</B> 플래그를 삽입하여 대신 VL 서버
시스템 순위를 표시하십시오.
기본적으로 출력은 표준 출력 문자열(STDOUT)에 표시되지만,
<B>-file</B> 인수를 포함시켜 대신 파일에 기록할 수 있습니다.
<P>캐쉬 관리 프로그램은 커널 목록에 호스트 이름이 아닌 IP 주소를
저장하지만, 기본적으로 출력에서는 셀의 이름 서비스(도메인 이름
서버) 또는 로컬 호스트 테이블을 참조하는 변환 루틴을 호출한 뒤
호스트 이름으로 인터페이스를 식별합니다. 이 경우 IP 주소가
표시되면, 이것은 변환이 실패하기 때문입니다. 변환 단계를
통과하고 호스트 이름 대신 IP 주소를 표시하려면,
<B>-numeric</B> 플래그를 포함하십시오. 이것으로 출력
속도가 현저히 증가할 수 있습니다.
<P><B>fs setserverprefs</B> 명령을 사용하여 기존 선호
사항 순위를 재설정하거나, 캐쉬 관리 프로그램에 순위가 없는
파일 서버 시스템 인터페이스 또는 VL 서버 시스템의 초기 순위를 설정할
수 있습니다. 설정한 순위는 시스템이 재부트할 때 까지 또는
<B>fs setserverprefs</B> 명령을 다시 실행할 때 까지
유지됩니다. 재부트하면서도 순위를 유지하려면, 해당
<B>fs setserverprefs</B> 명령을 시스템의 AFS
초기설정 파일에 넣으십시오.
<P>기본 순위에서 처럼, 캐쉬 관리 프로그램은 사용자가 지정한 각 순위
범위에 임의로 선택한 정수를 추가합니다. 파일 서버 시스템 인터페이스의
경우 임의 번호는 0 - 15 이내이며, VL 서버 시스템의 경우 0 - 126 범위
이내입니다. 예를 들어 15,000 순위를 파일 서버 시스템 인터페이스에
지정하면, 캐쉬 관리 프로그램은 15,000 - 15,015 이내의 정수를
저장합니다.
<P>VL 서버 시스템 순위를 지정하려면, <B>fs
setserverprefs</B> 명령에 있는 <B>-vlserver</B> 인수 다음에 이 순위를 나열하십시오.
<P>파일 서버 시스템 순위를 지정하려면, 다음 3가지 방법을 사용하십시오.
<OL TYPE=1>
<LI>명령행에서 <B>-servers</B> 인수 다음에 이를
나열하십시오.
</LI><LI>파일에 이를 기록하고 <B>-file</B> 인수로 이름을
지정하십시오. <B>-file</B> 인수를 <B>fs getserverprefs</B> 명령에 포함시키면 적합한 형식으로 파일을 쉽게 생성할 수 있습니다.
</LI><LI><B>-stdin</B> 플래그를 포함시켜 표준 입력 문자열을
통해 이들을 입력하십시오. 이렇게 하면 명령이나, 사용자 셀에 적합한
알고리즘을 사용하여 선호 사항을 생성하는 스크립트에서 직접 값을
읽어들일 수 있습니다. 적합한 형식으로 생성해야 하며, 각 쌍 사이에,
그리고 쌍의 두 파트 사이에 하나 이상의 공간이 있습니다. AFS 분배에는
그러한 스크립트가 포함되지 않으므로, 이 방법을 사용하려는 경우는 하나
작성해야 합니다.
</LI></OL>
<P>원하면 같은 명령행에서 <B>-servers</B>,
<B>-file</B> 및 <B>-stdin</B> 옵션들을
결합할 수 있습니다. 이들 중 하나 이상이 같은 인터페이스에 대해 순위를
지정하면, <B>-servers</B> 인수로 지정된 순위의
우선순위가 높습니다.
또한 같은 명령행에서 <B>-vlservers</B> 인수를
제공하여 VL 서버 시스템 순위를 동시에 파일 서버 시스템 순위로
설정할 수 있습니다.
<P><B>fs</B> 명령 해석기는 호스트 이름이나 IP 주소를
확인하지 않으므로, 실제로 존재하지 않는 호스트 이름과 주소의 순위도
저장합니다. 캐쉬 관리 프로그램은 서버 시스템에 대한 동일한 VLDB
레코드에서 동일한 틀린 정보를 기록하지 않는다면 그러한 순위는
사용하지 않습니다.
<A NAME="IDX7475"></A>
<A NAME="IDX7476"></A>
<P><H3><A NAME="Header_474" HREF="auagd002.htm#ToC_474">서버 선호 사항 순위 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs getserverprefs</B> 명령을 실행하여 파일
서버 시스템 또는 VL 서버 시스템에 대한 캐쉬 관리 프로그램의 선호
사항 순위를 표시하십시오.
<P>
<PRE>   % <B>fs getserverprefs</B> [<B>-file</B> &lt;<VAR>output&nbsp;to&nbsp;named&nbsp;file</VAR>>] [<B>-numeric</B>] [<B>-vlservers</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>gp
</B><DD><B>getserverprefs</B>에 대한
별명입니다(<B>gets</B>는 축약형입니다).
<P><DT><B>-file
</B><DD>순위 목록을 기록할 파일의 경로 이름을 지정합니다. 이 인수를
생략하면 표준 출력 문자열(STDOUT)에서 목록이 표시됩니다.
<P><DT><B>-numeric
</B><DD>순위가 지정된 시스템 인터페이스의 IP 주소를 호스트 이름 대신
표시합니다. 이 플래그를 생략하면 주소가 호스트 이름으로 변환되며,
이를 수행하는 데에는 다소 시간이 소요됩니다.
<P><DT><B>-vlservers
</B><DD>파일 서버 시스템 대신 VL 서버 시스템의 순위를 표시합니다.
</DL>
<P>
<P>다음 예에서는 파일 서버 시스템의 순위를 표시합니다.
<B>-numeric</B> 플래그가 사용되지 않았으므로, IP
주소가 표시되면 이것을 호스트 이름으로 변환할 수 없음을 의미합니다.
<P>
<PRE>   % <B>fs gp</B>
   fs5.abc.com         20000
   fs1.abc.com         30014
   server1.stateu.edu  40011
   fs3.abc.com         20001
   fs4.abc.com         30001
   192.12.106.120      40002
   192.12.106.119      40001
      .   .   .   .   .     . .
</PRE>
</LI></OL>
<A NAME="IDX7477"></A>
<A NAME="IDX7478"></A>
<A NAME="IDX7479"></A>
<P><H3><A NAME="Header_475" HREF="auagd002.htm#ToC_475">서버 선호 사항 순위 설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs setserverprefs</B> 명령을 실행하여 하나
이상의 파일 서버 시스템 또는 VL 서버 시스템에 대한 캐쉬
관리 프로그램의 선호 사항 순위를 설정하십시오.
<P>
<PRE>   # <B>fs setserverprefs</B> [<B>-servers</B> &lt;<VAR>fileserver&nbsp;names&nbsp;and&nbsp;ranks</VAR>><SUP>+</SUP>]  \
                       [<B>-vlservers</B> &lt;<VAR>VL&nbsp;server&nbsp;names&nbsp;and&nbsp;ranks</VAR>><SUP>+</SUP>]  \
                       [<B>-file</B> &lt;<VAR>input&nbsp;from&nbsp;named&nbsp;file</VAR>>] [<B>-stdin</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sp
</B><DD><B>setserverprefs</B>의 별명입니다(<B>sets</B>는 축약형입니다).
<P><DT><B>-servers
</B><DD>한쌍 이상의 파일 서버 시스템 인터페이스와 순위를 지정합니다.
완전한 호스트 이름이나 소수점 십진 형식으로 된 IP 주소로 각
인터페이스를 식별합니다. 수용할 수 있는 순위는 <B>1</B> - <B>65534</B> 이내의 정수입니다. 한 쌍에서 각
파트를, 쌍을 다른 쌍과 구분하는 데 하나 이상의 공백을 사용하십시오.
<P><DT><B>-vlservers
</B><DD>한쌍 이상의 VL 서버 시스템과 순위를 지정합니다. 완전한 호스트
이름이나 소수점 십진 형식으로 된 IP 주소로 각 인터페이스를 식별합니다.
수용할 수 있는 순위는 <B> 1</B> -
<B>65534</B> 이내의 정수입니다.
<P><DT><B>-file
</B><DD>한쌍 이상의 파일 서버 시스템 인터페이스와 순위가 들어있는
파일의 경로 이름을 지정합니다. 파일에서 이 매개변수 행에 각 쌍을
삽입하십시오. 인터페이스와 순위에 대해 <B>-servers</B> 인수에서와 같은 형식을 사용하십시오.
<P><DT><B>-stdin
</B><DD>파일 서버 시스템 인터페이스 및 순위가 표준 입력 문자열(stdin)을
통해 제공됨을 나타냅니다. 쌍을 생성하는 프로그램이나 스크립트는
<B>-servers</B> 인수에서와 같은 방식으로 이들을
형식화해야 합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ415" HREF="auagd002.htm#ToC_476">멀티홈 클라이언트 시스템 관리</A></H2>
<A NAME="IDX7480"></A>
<A NAME="IDX7481"></A>
<A NAME="IDX7482"></A>
<A NAME="IDX7483"></A>
<A NAME="IDX7484"></A>
<A NAME="IDX7485"></A>
<P>파일 서버는 멀티홈 클라이언트 시스템(하나 이상의 네트워크
인터페이스와 IP 주소를 가진 시스템)에서 캐쉬 관리 프로그램과의 통신을
시작할 때 메시지를 전송할 인터페이스를 선택할 수 있습니다. 그
인터페이스에 액세스할 수 없으면, 자동으로 대체 인터페이스로
전환합니다. 이렇게 하면 AFS 성능이 향상되며, 이는 인터페이스가
부족해도 파일 서버와 캐쉬 관리 프로그램간의 통신을 방해하지
못함을 의미합니다.
<P>파일 서버는 두 가지 유형의 메시지를 전송할 때 클라이언트 인터페이스를
선택할 수 있습니다.
<UL>
<LI>캐쉬 관리 프로그램이 캐쉬된 파일을 보유하는 콜백을 중단하는 메시지
</LI><LI>캐쉬 관리 프로그램에 계속 액세스할 수 있고 응답하고 있는 지
체크하는 <I>ping</I> 메시지. 파일 서버는 이러한
메시지를 매 몇분마다 전송합니다.
</LI></UL>
<P>(파일 서버는 AFS 데이터에 대한 캐쉬 관리 프로그램의 요청을 채울 때
응답할 클라이언트 인터페이스를 선택하지 않습니다. 그런 경우, 캐쉬
관리 프로그램이 요청을 전송했던 클라이언트 인터페이스를 통해 항상
응답합니다).
<P>캐쉬 관리 프로그램은 시작된 후 클라이언트 시스템에 있는 사용하기 쉬운
인터페이스 목록을 자동으로 컴파일한 다음, 이를 커널 메모리에
기록합니다. 캐쉬 관리 프로그램이 제일 처음 파일 서버와의 연결을
구축할 때, 인터페이스 주소 목록만을 전송합니다. 파일 서버는 주소를
기록하고, 콜백을 중단하거나 캐쉬 관리 프로그램에게 ping 명령을
전송해야 할 때 목록 맨 위에 있는 하나를 사용합니다. 그 인터페이스에
액세스할 수 없으면, 파일 서버는 목록에 있는 다른 여러 인터페이스에게
동시에 메시지를 전송합니다. 어떤 인터페이스가 포함되는 지 관계없이
파일 서버는 메시지를 첫번째에게 전송합니다.
<P>클라이언트에 있는 로컬 디스크의 <B>/usr/vice/etc</B>
디렉토리에 있는 두 개의 파일(<B>NetInfo</B> 및
<B>NetRestrict</B>)에서 주소들을 나열하여 캐쉬
관리 프로그램이 파일 서버로 등록하는 주소를 제어할 수 있습니다.
캐쉬 관리 프로그램이 시작될 때 <B>NetInfo</B> 파일이
있으면, 캐쉬 관리 프로그램은 인터페이스 목록에 대한 기본으로서 그
내용을 사용합니다. 그렇지 않으면 운영 체제에서 구성한 인터페이스
목록을 사용합니다. 그런 다음 <B>/usr/vice/etc/NetRestrict</B> 파일에 표시되는 주소들을 목록에서 제거합니다. 캐쉬
관리 프로그램은 커널 메모리에 결과 목록을 기록합니다.
<P>또한 <B>fs setclientaddrs</B> 명령을 사용하여
클라이언트 시스템을 재부트하지 않고도 캐쉬 관리 프로그램의 커널
메모리에 저장된 주소 목록을 변경할 수 있습니다. 명령행에서 제공한
주소 목록은 커널 메모리에 있는 현재 목록을 완전히 바꿉니다. 그러나
변경사항은 클라이언트 시스템이 재부트할 때 까지만 유지됩니다.
재부트하면서도 개정된 목록을 유지하려면, 로컬
<B>/usr/vice/etc</B> 디렉토리에 있는
<B>NetInfo</B> 파일(적합하면 <B>NetRestrict</B> 파일)의 인터페이스를 나열하십시오(시스템의
AFS 초기설정 스크립트에 해당되는 <B>fs setclientaddrs</B>
명령을 삽입할 수도 있습니다. 그러나 효과는 적습니다. 이런
경우 대개 캐쉬 관리 프로그램이 스크립트에서 명령을 읽고,
인터페이스 목록을 이미 컴파일했습니다).
<P>캐쉬 관리 프로그램이 현재 파일 서버로 등록하는 주소 목록을
표시하려면, <B>fs getclientaddrs</B> 명령을 사용하십시오.
<P><B>NetInfo</B> 또는 <B>NetRestrict</B>
파일을 변경할 때, 또는 <B>fs getclientaddrs</B> 또는
<B>fs setclientaddrs</B> 명령을 실행할 때 다음을
기억하십시오.
<UL>
<LI><B>fs setclientaddrs</B> 명령을 실행할 때, 개정된
주소 목록은 캐쉬 관리 프로그램이 이미 연결을 설정했던 파일 서버로
자동 전달되지 않습니다. 처음 연결을 설정할 때 캐쉬 관리 프로그램이
등록했던 목록을 계속해서 사용합니다. 이전에 접속했던 파일 서버가
개정된 목록을 사용하도록 하려면, 각각의 파일 서버 시스템을
재부트하거나, <B>NetInfo</B> 파일,
<B>NetRestrict</B> 파일 또는 이들 모두를 변경한 뒤
클라이언트 시스템을 재부트해야 합니다.
</LI><LI><B>fs</B> 명령 해석기는 <B>fs
setclientaddrs</B> 명령행에서 지정한 주소 각각이 실제로
클라이언트 시스템의 운영 체제에서 구성되었는 지 확인합니다. 구성되어
있지 않으면, 명령은 주소를 <TT>Nonexistent interface</TT>로
표시하는 오류 메시지와 함께 실패합니다.
</LI><LI>이전에 설명한 바와 같이, 파일 서버는 데이터에 대한 캐쉬
관리 프로그램의 요청에 응답할 때 등록된 주소 목록을 사용하지
않습니다(통신을 시작할 때와는 반대). 캐쉬 관리 프로그램이 요청을
전송했던 인터페이스에 항상 그 응답을 전송하려 합니다. 응답에
실패하면, 파일 서버는 캐쉬 관리 프로그램이 등록한 주소 목록이 아닌
서버 시스템의 네트워크 라우팅 구성에 따라 응답을 재전송하기 위한 대체
루트를 선택합니다.
</LI><LI>캐쉬 관리 프로그램은 파일 서버에 대한 연결을 설정하기 위한
인터페이스를 선택할 때 인터페이스 목록을 사용하지 않습니다.
</LI><LI>캐쉬 관리 프로그램이 먼저 그 파일 서버에 접속하므로 관리자가
<B>fs setclientaddrs</B> 명령을 실행하는 경우 <B>fs
getclientaddrs</B> 명령이 표시하는 주소 목록이 특정 파일 서버가
사용하는 것일 필요는 없습니다.
앞으로 파일 서버에 연결될 때 캐쉬 관리 프로그램이 등록하는 주소만을
결정합니다.
</LI></UL>
<A NAME="IDX7486"></A>
<A NAME="IDX7487"></A>
<A NAME="IDX7488"></A>
<A NAME="IDX7489"></A>
<P><H3><A NAME="Header_477" HREF="auagd002.htm#ToC_477">클라이언트 NetInfo 파일 작성 또는 편집하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI>문서 편집기를 사용하여 <B>/usr/vice/etc/NetInfo</B>
파일을 여십시오. 소수점 십진 형식의 IP 주소를 각 행에 두십시오(예:
<TT>192.12.107.33</TT>). 첫번째 행에 각 파일 서버가 초기에
사용하도록 하려는 주소를 넣으십시오. 나머지 시스템 순서는 중요하지
않습니다. 첫번째 인터페이스에 대한 RPC가 실패하면, 파일 서버가
목록에 있는 다른 인터페이스 모두에게 동시에 RPC를 전송하기
때문입니다. 어떤 인터페이스가 포함되는 지 관계없이 파일 서버는 콜백을
중단하기 위해 ping과 RPC를 첫번째 인터페이스에 전송합니다.
</LI><LI>캐쉬 관리 프로그램이 개정된 목록을 사용하여 즉시 시작되도록
하려면, 시스템을 재부트하거나, <B>fs setclientaddrs</B>
명령을 사용하여 커널 메모리에서 직접 같은 주소 목록을 작성하십시오.
</LI></OL>
<A NAME="IDX7490"></A>
<A NAME="IDX7491"></A>
<A NAME="IDX7492"></A>
<A NAME="IDX7493"></A>
<P><H3><A NAME="Header_478" HREF="auagd002.htm#ToC_478">클라이언트 NetRestrict 파일 작성 또는 편집하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI>문서 편집기를 사용하여 <B>/usr/vice/etc/NetRestrict</B> 파일을 여십시오. 각 행에 소수점 십진 형식의 IP 주소를 두십시오.
주소 순서는 중요하지 않습니다. 그 필드에서 가능한 모든 주소들을
나타내는 와일드 카드로서 <B>255</B> 값을
사용하십시오. 예를 들어 <TT>192.12.105.255</TT> 항목은 캐쉬
관리 프로그램이 192.12.105 서브네트에서 주소를 등록하지 않음을 나타냅니다.
</LI><LI>캐쉬 관리 프로그램이 개정된 목록을 사용하여 즉시 시작되도록 하려면,
시스템을 재부트하거나, <B>fs setclientaddrs</B>
명령을 사용하여 금지된 주소가 들어있지 않은 주소 목록을 설정하십시오.
</LI></OL>
<A NAME="IDX7494"></A>
<A NAME="IDX7495"></A>
<P><H3><A NAME="Header_479" HREF="auagd002.htm#ToC_479">커널 메모리의 주소 목록 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs getclientaddrs</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>fs getclientaddrs</B> 
</PRE>
<P>
<P>여기서 <B>gc</B>는
<B>getclientaddrs</B>의 변경입니다(<B>getcl</B>은 축약형입니다).
</LI></OL>
<P>출력에서는 각 행에 소숫점 십진 형식으로 IP 주소를 나열합니다.
<A NAME="IDX7496"></A>
<A NAME="IDX7497"></A>
<P><H3><A NAME="Header_480" HREF="auagd002.htm#ToC_480">커널 메모리에서 주소 목록 설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs setclientaddrs</B> 명령을 실행하여 현재
커널 메모리에 있는 주소 목록을 새로운 목록으로 대체하십시오.
<P>
<PRE>   #
<B>fs setclientaddrs</B> [<B>-address</B> &lt;<VAR>client&nbsp;network&nbsp;interfaces</VAR>><SUP>+</SUP>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sc
</B><DD><B>setclientaddrs</B>의 별명입니다(<B>setcl</B>은 축약형입니다).
<P><DT><B>-address
</B><DD>소수점 십진 형식으로 하나 이상의 IP 주소를 지정합니다(호스트
이름은 수용할 수 없습니다). 각 주소를 하나 이상의 공백으로 분리하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ416" HREF="auagd002.htm#ToC_481">경고 및 정보 메시지 표시 제어</A></H2>
<A NAME="IDX7498"></A>
<A NAME="IDX7499"></A>
<P>기본적으로 캐쉬 관리 프로그램은 경고와 정보 메시지, 이 두 가지 유형을
생성합니다.
<UL>
<LI><I>사용자 메시지</I>를 전송하며, 이것은 사용자
레벨 상태 및 경고 정보를 사용자 화면에 제공합니다.
</LI><LI><I>콘솔 메시지</I>를 전송하며, 이것은 시스템
레벨 상태 및 경고 정보를 클라이언트 시스템의 지정 콘솔에 제공합니다.
</LI></UL>
<P><B>fs messages</B> 명령을 사용하여 캐쉬 관리
프로그램이 메시지 유형 중 하나, 모두 또는 어느 것도 표시하지 않는 지
여부를 제어할 수 있습니다. 메시지는 유용한 정보를 제공하므로,
완전히 사용 불가능하게 하지 않는 것이 좋습니다.
<P>캐쉬 관리 프로그램 상태 및 성능을 보다 왕성하게 모니터하려면,
<B>afsmonitor</B> 프로그램을 사용하여 확장된 통계
세트를 수집할 수 있습니다(파일 서버 통계를 수집하기도 합니다).
성능상의 문제점을 발견하면, <B>fstrace</B> 명령 집합을
사용하여 캐쉬 관리 프로그램 동작의 하위 레벨 추적을 수집할 수 있으며,
여기에서 AFS 지원 및 개발 그룹은 문제점을 해결하는 데 도움이 되도록
분석할 수 있습니다. 유틸리티 모두에 대해 알려면
<A HREF="auagd013.htm#HDRWQ323">AFS 성능 모니터 및 감사</A>의 내용을 참조하십시오.
<A NAME="IDX7500"></A>
<A NAME="IDX7501"></A>
<P><H3><A NAME="Header_482" HREF="auagd002.htm#ToC_482">경고 및 상태 메시지 표시 제어하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>-show</B> 인수와 함께 <B>fs
messages</B> 명령을 실행하여 표시할 메시지 유형을 지정하십시오.
<P>
<PRE>   # <B>fs messages -show</B> &lt;<B>user</B>|<B>console</B>|<B>all</B>|<B>none</B>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>me
</B><DD><B>messages</B>의 축약형입니다.
<P><DT><B>-show
</B><DD>표시할 메시지 유형을 지정합니다. 다음 값 중 하나를 선택하십시오.
<P>
<DL>
<P><DT><B>user
</B><DD>사용자 화면에 사용자 메시지를 전송합니다.
<P><DT><B>console
</B><DD>콘솔로 콘솔 메시지를 전송합니다.
<P><DT><B>all
</B><DD>사용자 화면에는 사용자 메시지를, 콘솔에는 콘솔 메시지를
전송합니다(<B>-show</B> 인수가 생략된 경우 기본값).
<P><DT><B>none
</B><DD>메시지를 완전히 사용할 수 없습니다.
</DL>
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ417" HREF="auagd002.htm#ToC_483">시스템 유형 이름 표시 및 설정</A></H2>
<A NAME="IDX7502"></A>
<A NAME="IDX7503"></A>
<P>캐쉬 관리 프로그램은 커널 메모리에 로컬 클라이언트 시스템의 시스템
유형 이름을 저장합니다. AFS 클라이언트 소프트웨어에서 하드코드된
정의에서 기본값을 읽어 들입니다.
<P>캐쉬 관리 프로그램은 AFS 경로이름에서 <VAR>@sys</VAR> 변수에 대한
대체로서 시스템 이름을 사용합니다. 변수는 클라이언트 시스템의 시스템
유형에 대한 2진 파일이 들어있는 로컬 디스크에서 AFS 디렉토리로의
기호 연결을 작성할 때 유용합니다. <VAR>@sys</VAR> 변수는 자동으로
캐쉬 관리 프로그램을 해당 디렉토리로 진행시키므로, 다른 시스템 유형의
클라이언트 기계에서 동일한 기호 연결을 작성할 수
있습니다(<A HREF="auagd016.htm#HDRWQ419">package 프로그램을 사용한 클라이언트 시스템 구성</A>에서 설명했던 패키지 유틸리티를
사용하여 작성 동작을 자동화할 수도 있습니다). 연결은 시스템을
새로운 시스템 유형으로 업그레이드할 때까지 유효한 채로 남습니다.
<P>사용자가 AFS가 지정한 시스템 유형 이름을 사용할 때 구성이 가장 간단합니다.
목록에 대해서는 <I>AFS 릴리스 노트</I>의 내용을 참조하십시오.
<P>커널 메모리에 저장된 시스템 이름을 표시하려면, <B>sys</B> 또는 <B>fs sysname</B> 명령을 사용하십시오.
이름을 변경하려면, 나중에 명령의 <B>-newsys</B> 인수를
추가하십시오.
<A NAME="IDX7504"></A>
<A NAME="IDX7505"></A>
<A NAME="IDX7506"></A>
<A NAME="IDX7507"></A>
<P><H3><A NAME="Header_484" HREF="auagd002.htm#ToC_484">시스템 유형 이름 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs sysname</B> 또는 <B>sys</B>
명령을 실행하십시오.
<P>
<PRE>   % <B>fs sysname</B> 
   
   % <B>sys</B>
</PRE>
</LI></OL>
<P><B>fs sysname</B> 명령의 출력 형식은 다음과 같습니다.
<PRE>   Current sysname is '<VAR>system_name</VAR>'
</PRE>
<P><B>sys</B> 명령에서는 다른 텍스트없이
<VAR>system_name</VAR> 문자열을 표시합니다.
<P><H3><A NAME="Header_485" HREF="auagd002.htm#ToC_485">시스템 유형 이름 변경하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>-newsys</B> 인수와 함께 <B>fs sysname</B> 명령을 실행하여 새로운 이름을 지정하십시오.
<P>
<PRE>   # <B>fs sysname</B> &lt;<VAR>new&nbsp;sysname</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sys
</B><DD><B>sysname</B>의 축약형입니다.
<P><DT><B><VAR>new sysname</VAR>
</B><DD>새로운 시스템 유형의 이름을 지정합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ418" HREF="auagd002.htm#ToC_486">비동기 기록 가능</A></H2>
<A NAME="IDX7508"></A>
<A NAME="IDX7509"></A>
<A NAME="IDX7510"></A>
<P>기본적으로, 캐쉬 관리 프로그램은 응용프로그램이 파일을 닫을 때 모든
데이터를 파일 서버로 즉시 동기식으로 기록합니다. 즉
<B>close</B> 시스템 호출은 캐쉬 관리 프로그램이
파일에서 캐쉬한 모든 데이터를 파일 서버로 기록할 때 까지는 리턴하지
않습니다. 캐쉬 관리 프로그램이 응용프로그램으로 제어를 리턴할 때
파일 서버로 기록되기 위해 남을 수 있는 파일의 킬로바이트 수를
지정하여 파일을 동기적으로 기록할 수 있도록 합니다.
<P>비동기 기록을 가능하게 설정하는 것은 보통 대형 파일에 대해 작업하는
사용자에게 유용할 수 있습니다. 이는 주로 응용프로그램이 좀 더 빠르게
수행되는 것으로 나타남을 의미합니다. 그러나 몇가지 복잡한 사항에
대해 설명합니다. 시스템 사용자가 잠재적인 문제점을 이해하거나 이에
대한 예방법을 이해하기에 충분히 순진하지 않은 경우를 제외하면 비동기
기록을 사용 가능하게 설정하지 않는 것이 좋습니다. 남은 문제점은
다음과 같습니다.
<UL>
<LI>대부분의 경우 캐쉬 관리 프로그램은 기본적으로 수행하는 것보다
빨리 응용 프로그램으로 제어를 리턴하지만, 이를 보장할 수는
없습니다. 사용자들은 항상 빠른 성능을 기대할 수는 없습니다.
</LI><LI>비동기 기록에 실패하면, 응용프로그램에 통지할 수 없습니다.
<B>close</B> 시스템 호출이 이미 성공을 알리는 코드로
리턴되었기 때문입니다.
</LI><LI>비동시 기록은 사용자가 기록 동작으로 인해 볼륨이 그 할당량을
초과할 때를 알리는 데 실패할 수 있는 가능성을 증가시킵니다. 항상
그렇지만 할당량을 초과하는 파일 부분은 다음과 같은 메시지에서
표시하는 것처럼 유실됩니다.
<P>
<PRE>   No space left on device
</PRE>
<P>
<P>할당량 부족으로 인해 데이터가 유실되지 않게 하려면, 파일을 닫기
전에 사용자가 파일이 있는 볼륨에 이를 수용할 충분한 공간이 있는
지 확인해야 합니다.
</LI></UL>
<P><B>fs storebehind</B> 명령을 실행하여 비동기 기록을
사용 가능하게 하면, 캐쉬 관리 프로그램이 응용프로그램으로 제어를
리턴할 때 파일 서버로 기록하기 위해 계속해서 남아 있을 수 있는 파일의
킬로바이트 수를 설정합니다. 시스템에서 실행중인 응용 프로그램이
조작하는 모든 파일에, 또는 일정한 파일에만 설정값을 적용할 수 있습니다.
<UL>
<LI>모든 파일에 적용하는 설정을 시스템에 대한 <I>기본 비동기 저장값</I>이라고 하며, 시스템이 재부트할 때 까지
유지됩니다. 예를 들어 기본 비동기 저장값을 10KB로 설정하면, 이것은
응용프로그램이 파일을 닫을 때, 닫히는 파일의 10KB 이하가 파일 서버로
기록되기 위해 남겨지면 캐쉬 관리 프로그램은 응용프로그램으로 제어를
리턴할 수 있습니다.
</LI><LI>각 파일의 설정값은 기본 비동기 저장값을 대체하며, 캐쉬
관리 프로그램이 파일 정보를 추적하기 위해 사용하는 내부 테이블에
파일 항목이 있는 동안은 유지됩니다. 일반적으로 이러한 항목은
적어도 응용프로그램이 파일을 닫거나 완전히 종료할 때 까지 유지되지만,
캐쉬 관리 프로그램은 파일이 사용되고 있지 않아 테이블에서 슬롯을
해제시켜야 하는 경우 항목을 재사용하기 위해 자유롭게 됩니다.
테이블이 항목이 있는 지 확인하려면, 파일을 닫기 바로 전에
<B>fs storebehind</B> 명령을 실행하십시오.
</LI></UL>
<A NAME="IDX7511"></A>
<A NAME="IDX7512"></A>
<P><H3><A NAME="Header_487" HREF="auagd002.htm#ToC_487">기본 비동기 저장값 설정하기</A></H3>
<OL TYPE=1>
<LI>시스템에서 로컬 수퍼유저 <B>루트</B>가 아닌 경우
<B>su</B> 명령을 실행하여 이러한 권한을 얻으십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs storebehind</B> 명령을 <B>-allfiles</B> 인수와 함께 실행하십시오.
<P>
<PRE>   # <B>fs storebehind -allfiles</B>  &lt;<VAR>new&nbsp;default&nbsp;(KB)</VAR>> [<B>-verbose</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>st
</B><DD><B>storebehind</B>의 축약형입니다.
<P><DT><B>-allfiles
</B><DD>캐쉬 관리 프로그램이 파일을 닫은 응용프로그램으로 제어를 리턴할 때
파일 서버로 기록되기 위해 남을 수 있는 데이터의 킬로바이트 수를
설정합니다.
<P><DT><B>-verbose
</B><DD>새로운 설정을 확인하는 메시지를 생성합니다.
</DL>
</LI></OL>
<A NAME="IDX7513"></A>
<A NAME="IDX7514"></A>
<P><H3><A NAME="Header_488" HREF="auagd002.htm#ToC_488">하나 이상의 파일에 대한 비동기 저장 설정하기</A></H3>
<OL TYPE=1>
<LI><A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명했던 <B>fs listacl</B> 명령을 실행하여, 비동기 저장값을 설정하는 각 파일의 액세스 제어
목록(ACL)에 대해 <B>w</B>(<B>기록</B>) 권한을 가지고 있는 지 확인하십시오.
<P>
<PRE>   % <B>fs listacl</B> <VAR>dir/file&nbsp;path</VAR>
</PRE>
<P>
<P>또는 아직 수퍼유저가 아니라면 <B>su</B> 명령을
실행하여 클라이언트 시스템에서 로컬 일반 사용자인
<B>루트</B>가 되십시오.
<P>
<PRE>   % <B>su root</B>
   Password: <VAR>root_password</VAR>
</PRE>
</LI><LI><B>fs storebehind</B> 명령을 <B>-kbytes</B> 및 <B>-files</B> 인수와 함께 실행하십시오.
<P>
<PRE>   # <B>fs storebehind -kbytes</B> &lt;<VAR>asynchrony&nbsp;for&nbsp;specified&nbsp;names</VAR>> \
                    <B>-files</B> &lt;<VAR>specific&nbsp;pathnames</VAR>><SUP>+</SUP>  \
                    [<B>-verbose</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>st
</B><DD><B>storebehind</B>의 축약형입니다.
<P><DT><B>-kbytes
</B><DD>캐쉬 관리 프로그램이 <B>-files</B> 인수가 지정한
파일을 닫은 응용프로그램으로 제어를 리턴할 때 파일 서버로 기록되기
위해 남겨질 수 있는 데이터의 킬로바이트 수를 설정합니다.
<P><DT><B>-files
</B><DD>기본값을 대체하는 비동기 저장값을 설정할 각 파일을
지정합니다. 일부 경로 이름은 현재의 작업 디렉토리와 관련하여
해석됩니다.
<P><DT><B>-verbose
</B><DD>새로운 설정을 확인하는 메시지를 생성합니다.
</DL>
</LI></OL>
<A NAME="IDX7515"></A>
<A NAME="IDX7516"></A>
<P><H3><A NAME="Header_489" HREF="auagd002.htm#ToC_489">기본 비동기 저장값 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs storebehind</B> 명령을 인수없이, 또는
<B>-verbose</B> 플래그만 사용하여 실행하십시오.
<P>
<PRE>   % <B>fs storebehind </B> [<B>-verbose</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>st
</B><DD><B>storebehind</B>의 축약형입니다.
<P><DT><B>-verbose
</B><DD>기본 비동기 저장값을 알려주는 출력을 생성합니다.
</DL>
</LI></OL>
<A NAME="IDX7517"></A>
<A NAME="IDX7518"></A>
<P><H3><A NAME="Header_490" HREF="auagd002.htm#ToC_490">하나 이상의 파일에 대한 비동기 저장 표시하기</A></H3>
<OL TYPE=1>
<LI><B>fs storebehind</B> 명령을 <B>-files</B> 인수만 사용하여 실행하십시오.
<P>
<PRE>   % <B>fs storebehind</B>
<B>-files</B> &lt;<VAR>specific&nbsp;pathnames</VAR>><SUP>+</SUP> 
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>st
</B><DD><B>storebehind</B>의 축약형입니다.
<P><DT><B>-files
</B><DD>비동기 저장값을 표시할 각 파일을 지정합니다. 일부 경로 이름은
현재의 작업 디렉토리와 관련하여 해석됩니다.
</DL>
</LI></OL>
<P>출력에서는 각 파일을 개별적으로 나열합니다.
지정된 파일에 대한 값이 이전에 설정되었으면, 출력에서는 다음을
알려줍니다.
<PRE>   Will store up to <VAR>y</VAR> kbytes of <VAR>file</VAR> asynchronously.
   Default store asynchrony is <VAR>x</VAR> kbytes.
</PRE>
<P>기본 비동기 저장값이 파일에 적용되는 경우(이에 대한
<B>-kbytes</B> 값을 설정하지 않았으므로), 출력은
다음과 같습니다.
<PRE>   Will store <VAR>file</VAR> according to default.
   Default store asynchrony is <VAR>x</VAR> kbytes.
</PRE>
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd014.htm">이전 페이지</A> &#124; <A HREF="auagd016.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B> 
<!-- Begin Footer Records  ========================================== -->
<P><HR><B> 
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved 
</B> 
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
