<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    --> 
<BODY bgcolor="ffffff"> 
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<HR><H1><A NAME="HDRWQ5" HREF="auagd002.htm#ToC_9">AFS 관리의 개요</A></H1>
<P>이 장은 AFS 개념과 구성을 광범위한 측면에서 대략적으로 살펴 봅니다. AFS 셀 관리에
참여하는 사람은 누구든지 명령을 실행하기 전에 반드시 이 장을 읽어 보도록 하십시오.
<HR><H2><A NAME="HDRWQ6" HREF="auagd002.htm#ToC_10">AFS의 광범위한 개요</A></H2>
<P>이 절은 AFS를 기본적으로 이해하는 데 필요한 대부분의 핵심 용어와 개념을
다룹니다. 자세한 설명은 <A HREF="#HDRWQ7">몇몇 기본 개념에 대한 상세한 정보</A>를 참조하십시오.
<P><B>AFS: 분산 파일 시스템</B>
<P>AFS는 사용자들이 로컬 시스템에 저장된 파일을 액세스할 때처럼 쉽게 컴퓨터
네트워크에 저장된 모든 파일을 공유하고 액세스할 수 있게 해 주는
<I>분산 파일 시스템</I>입니다. 이 파일 시스템은
파일이 여러 다른 시스템에 상주할 수 있으나 (여러 시스템에 분산됨) 모든 시스템의
사용자들이 액세스할 수 있으므로 분산 파일 시스템이라고 합니다.
<P><B>서버 및 클라이언트</B>
<P>실제로 AFS는 <I>파일 서버 시스템</I>이라고 하는 네트워크의
시스템 서브네트에 파일을 저장합니다. 파일 서버 시스템은 다른 특수화된
서비스와 함께 파일 저장 및 전달 서비스를 <I>클라이언트
시스템</I>에 해당하는 네트워크의 다른 시스템 서브네트에 제공합니다.
이들 시스템은 자체의 작업을 수행하면서 동시에 서비의 서비스를 활용할 수
있으므로 클라이언트라고 합니다. 표준 AFS 구성에서 클라이언트는 자신의
콘솔에 앉아 있는 사용자들에게 컴퓨터 능력을 제공하고 AFS의 파일과
다른 "일반 목적"의 도구를 액세스할 수 있게 해줍니다. 일반적으로 파일
서버 시스템보다 훨씬 더 많은 클라이언트 워크스테이션이 존재합니다.
<P>AFS 파일 서버 시스템은 많은 수의 <I>서버 프로세스</I>를
실행합니다. 왜냐하면 각각이 특수하게 구별된 서비스를 제공하기 때문입니다.
즉 하나의 시스템은 파일 요청을 처리하고, 다른 시스템은 파일 위치를
추적하고, 또 다른 시스템은 보안을 관리할 수 있습니다. 혼란을 피하기 위해
AFS 설명서에서는 항상 단순히 <I>서버</I>라고 지칭하지
않고 <I>서버 시스템</I>과 <I>서버
프로세스</I>로 구분하고 있습니다. 서버 프로세스에 대한 자세한 설명을
보려면 <A HREF="#HDRWQ17">AFS 서버 프로세스 및 캐쉬 관리 프로그램</A>을 참조하십시오.
<P><B>셀</B>
<P><I>셀</I>은 AFS가 실행되는 독립적으로 관리되는 사이트입니다.
셀의 시스템 관리자라면 다른 셀의 관리자에게 자문을 구하지 않고도 사용자에게
최상의 도움을 주도록 자신의 셀을 구성 및 유지하는 작업과 관련된
의사 결정을 내려야 합니다. 예를 들어 클라이언트와 서버가 얼마나 많은 수의
파일을 가지는가, 파일을 어디에 배치할 것인가, 클라이언트 시스템을 사용자에게
어떻게 할당할 것인가 등을 결정하게 됩니다.
<P><B>가시적 액세스 및 균일한 이름 공간</B>
<P>AFS 셀이 독립적으로 관리된다고 해도 다른 셀의 사용자들이 이 셀에 있는
정보도 액세스할 수 있도록 파일의 로컬 모음(<I>파일 공간</I> 또는 <I>트리</I>)을 구성하려 할 수 있습니다.
AFS는 로컬 파일 공간을 <I>전역 파일 공간</I>으로 조합할 수
있게 해주며 이러한 조합은 파일 액세스가 <I>가시적</I>으로
수행될 수 있게 하여 사용자들이 파일을 액세스하기 위해 파일 위치를 알아야 할 필요가
없도록 해 줍니다.
사용자들은 모든 셀에 동일하게 적용되는 파일의 경로명만 알면 됩니다.
따라서 모든 시스템의 모든 사용자는 동일한 방법으로 파일 모음을 볼 수
있으며 이것은 AFS가 사용자들에게 <I>균일한 파일 공간</I>을
제공함을 의미합니다.
<P><B>볼륨</B>
<P>AFS는 파일을 <I>볼륨</I>으로 그룹화하여 많은 시스템에
파일을 분산하고 균일한 이름 공간을 유지할 수 있게 합니다.
볼륨은 관련된 파일 집합 컨테이너 같은 기능을 하는 디스크 공간의 단위이며
관련 파일 모두를 하나의 파티션에 함께 보유합니다. 볼륨은 다양한 크기를 가지지만
파티션보다는 당연히 더 작습니다.
<P>볼륨은 여러 가지 이유로 인해 관리자와 사용자에게는 중요한 개념입니다.
볼륨은 크기가 작기 때문에 한 파티션에서 다른 파티션으로 또는 시스템
사이에서도 쉽게 이동할 수 있습니다. 시스템 관리자는 볼륨을 이동하여 로드 밸런스를
균일하게 유지함으로써 최대 효율을 유지할 수 있습니다. 또한 볼륨은
파일 공간의 디렉토리와 동일한 개념에 해당합니다. 따라서 대부분의 셀은
각 사용자 홈 디렉토리의 내용을 별도의 볼륨에 저장하고 있습니다.
결과적으로 볼륨이 이동될 때 디렉토리의 전체 내용이 함께 이동되므로
AFS가 특정 시점에서 파일의 위치를 쉽게 추적할 수 있습니다. 볼륨 이동은
자동으로 기록되므로 사용자는 파일 위치를 추적할 필요가 없습니다.
<P><B>효율 강화 기능: 복제 및 캐슁</B>
<P>AFS는 서버 및 클라이언트 시스템에서 AFS 기능을 보다 효율적이고 신뢰성 있게
만들어 주는 특수한 기능들을 통합하고 있습니다.
<P>서버 시스템에서 AFS는 관리자들이 자주 사용되는 볼륨(예를들어, 프로그램에 대한 2진 파일을
포함하는 볼륨)과 같이 일반적으로 사용되는 볼륨을 <I>복제</I>할
수 있게 해 줍니다. 복제는 둘 이상의 파일 서버 시스템에 동일한 읽기 전용
볼륨 복사본(경우에 따라 <I>클론</I>이라고 함)을 배치하는
것을 의미합니다. 이 볼륨을 가지는 한 파일 서버 시스템에 장애가 발생해도
이 볼륨의 내용을 다른 시스템에서 계속 사용할 수 있으므로 사용자의 작업은
중단되지 않습니다. 또한 복제는 한 시스템이 자주 사용되는 볼륨의 파일에
대한 요청으로 과부하되지 않게 하는 것을 의미하기도 합니다.
<P>클라이언트 시스템에서 AFS는 <I>캐슁</I>을 사용하여
효율을 높입니다. 클라이언트 워크스테이션의 사용자가 파일을 요청하면
클라이언트의 <I>캐쉬 관리 프로그램</I>은 데이터에 대한
요청을 적절한 파일 서버 시스템에서 실행되는 파일 서버 프로세스로 보냅니다.
사용자는 그 시스템이 어떤 시스템인지 알 필요가 없습니다. 캐쉬 관리
프로그램이 자동으로 파일 위치를 결정하기 때문입니다. 캐쉬 관리 프로그램은
파일 서버 프로세스로부터 파일을 받아 이를 클라이언트 시스템의 로컬 디스크 영역,
임시 파일 저장 영역에 전용으로 할당된 메모리 또는 <I>캐쉬</I>에
배치합니다. 캐슁은 사용자가 동일한 파일을 원할 때마다 클라이언트가 네트워크에서
요청을 전송할 필요가 없으므로 효율성을 높여 줍니다. 파일이 로컬로 저장되므로
네트워크 통신량이 최소화되고 다음에 진행되는 파일 액세스가 특히 더
빨라집니다. AFS는 캐쉬된 파일을 최신 상태로 유지하는
<I>콜백</I>이라는 방법을 사용합니다.
<P><B>보안: 상호 인증 및 액세스 제어 목록</B>
<P>파일 공유가 특히 자주 발생하는 셀에서도 모든 사용자가 모든 파일에 대해 동일한
액세스 권한을 가지는 것은 바람직하지 못합니다. AFS가 적절한 보안을 제공하는
한 가지 방법은 서버와 클라이언트가 정보를 교환하기 전에 서로에게 자신을
식별하도록 요구하는 것입니다. <I>상호 인증</I>이라고 하는
이 절차는 서버와 클라이언트가 둘만이 알고 있는 (암호와 같은) "공유 비밀"을
알고 있음을 증명하도록 요구합니다. 상호 인증은 서버가 인증된 클라이언트에게만
정보를 제공하고 이 클라이언트는 적법한 서버로부터만 정보를 받도록 해 줍니다.
<P>사용자들은 자신이 소유하는 디렉토리에 대한 액세스 권한이 있는 사람을
확인하여 AFS 보안의 다른 측면을 제어합니다. 사용자가 소유하는 디렉토리에
대해, 사용자는 디렉토리의 내용에 대한 액세스를 부여하거나 거부하는
<I>액세스 제어 목록</I>(ACL)을 구축할 수 있습니다.
액세스 제어 목록은 특정 사용자를 특정 유형의 액세스 권한과 함께
묶어 줍니다. 액세스 제어 목록에는 7가지의 별도의 권한과 최고 20명의 다른
사람 또는 사람 그룹이 포함될 수 있습니다.
<P>AFS의 상호 인증 절차에 대한 자세한 설명을 보려면
<A HREF="auagd007.htm#HDRWQ75">상호 인증에 대한 상세한 설명</A>을 참조하십시오. ACL에 대한 자세한
설명은 <A HREF="auagd020.htm#HDRWQ562">액세스 제어 목록 관리</A>를 참조하십시오.
<HR><H2><A NAME="HDRWQ7" HREF="auagd002.htm#ToC_11">몇몇 기본 개념에 대한 상세한 정보</A></H2>
<P>앞 절에서는 AFS 시스템 관리자가 이해해야 하는 여러 가지 개념들의 간략한
개요를 제공했습니다. 다음 절에서는 몇 가지 중요한 개념들을 좀더 상세히
검토할 것입니다. 경험 있는 관리자에게는 모든 개념들이 새로운 것은 아니겠지만
이 절을 읽어보면 용어와 개념을 이해하는 데 좀더 도움이 될 것입니다.
<P><H3><A NAME="HDRWQ8" HREF="auagd002.htm#ToC_12">네트워크</A></H3>
<A NAME="IDX5538"></A>
<P><I>네트워크</I>는 서로 통신할 수 있게 하고 서로 간의 정보
교환을 가능하게 하는 상호 연결된 컴퓨터 집합입니다.
<P>네트워크로 연결된 컴퓨팅 환경은 <I>메인프레임</I>과
<I>개인</I>의 두 가지 컴퓨팅 유형과 대조됩니다.
<A NAME="IDX5539"></A>
<A NAME="IDX5540"></A>
<UL>
<LI><I>메인프레임</I> 컴퓨팅 환경은 가장 전형적인
환경입니다. 이 환경은 강력한 단일 컴퓨터(메인프레임)를 사용하여 파일 저장 및
전산의 두 가지 작업 대부분을 시스템에서 수행합니다. 이 환경은 보통
키보드로부터 입력을 받고 화면에 데이터를 표시하는 데 필요한 충분한 컴퓨팅
능력만을 제공하는 <I>터미널</I>을 통해 파일을 액세스하고
메인프레임에 명령을 실행하는 여러 사용자에게 사용됩니다.
<A NAME="IDX5541"></A>
</LI><LI><I>개인</I> 컴퓨팅 환경은 한 명(또는 기껏해야 소수)의
사용자에게 사용되는 한 대의 소형 컴퓨터입니다. 이 단일 컴퓨터는 메인프레임
컴퓨터와 같이 모든 파일을 저장하고 모든 전산을 수행합니다.
이 개인용 컴퓨터에서는 터미널과 같이 키보드와 화면을 통해 컴퓨터를 액세스할
수 있습니다.
<A NAME="IDX5542"></A>
</LI></UL>
<P>네트워크는 여러 종류의 컴퓨터를 연결할 수 있지만 AFS가 실행되는
전형적인 네트워크는 고기능 개인 워크스테이션을 연결합니다. 각 워크스테이션은
몇몇 컴퓨팅 능력과 로컬 디스크 공간을 가지며 그 수준은 개인용 컴퓨터나
터미널보다는 더 크지만 메인프레임보다는 작습니다. AFS 환경에서 사용되는
시스템 클래스에 대한 자세한 설명을 보려면 <A HREF="#HDRWQ10">서버 및 클라이언트</A>를
참조하십시오.
<P><H3><A NAME="HDRWQ9" HREF="auagd002.htm#ToC_13">분산 파일 시스템</A></H3>
<A NAME="IDX5543"></A>
<A NAME="IDX5544"></A>
<P><I>파일 시스템</I>은 파일 모음 및 사용자가 파일의 정보를
액세스할 수 있게 하는 기능(프로그램과 명령)입니다. 모든 컴퓨팅 환경은
파일 시스템을 가집니다. 메인프레임 환경에서 파일 시스템은 메인프레임의
기억영역 디스크에 있는 모든 파일로 구성되지만 개인용 컴퓨팅 환경에서는
컴퓨터의 로컬 디스크에 있는 파일로 구성됩니다.
<P>네트워크로 연결된 컴퓨팅 환경에서는 종종 AFS와 같은 <I>분산
파일 시스템</I>을 사용합니다. 분산 파일 시스템은 네트워크의 둘 이상의
컴퓨터에 파일을 저장하고 이들 모든 컴퓨터에게 액세스할 수 있게함으로써
상호 연결된 네트워크의 본질을 활용합니다. 다시 말해서 파일 저장 및 배달의
책임이 한 시스템에만 의존하지 않고 여러 시스템에 "분산"되는 것입니다.
책임의 분배에도 불구하고 AFS와 같은 분산 파일 시스템은 단일 파일 공간에
있는 것과 같은 현상을 발생합니다.
<P><H3><A NAME="HDRWQ10" HREF="auagd002.htm#ToC_14">서버 및 클라이언트</A></H3>
<A NAME="IDX5545"></A>
<A NAME="IDX5546"></A>
<A NAME="IDX5547"></A>
<P>AFS는 서버/클라이언트 모델을 사용합니다. 일반적으로 <I>서버</I>는
다른 시스템에 특수화된 서비스를 제공하는 시스템이나 시스템에서 실행되는
프로세스입니다. <I>클라이언트</I>는 작업 과정 중에
서버의 특수화된 서비스를 사용하는 시스템이나 프로세스로서 서버의 경우보다
좀더 일반적인 성향을 가집니다.
클라이언트와 서버 간의 기능적 구분이 항상 뚜렷한 것은 아닙니다.
그러나 서버는 그 서비스가 사용되고 있는 다른 서버의 클라이언트로 고려될 수
있습니다.
<P>AFS는 <I>파일 서버 시스템</I>과
<I>클라이언트 시스템</I>의 두 가지 기본 클래스로 네트워크의
시스템을 구분하며 각각에게 다른 타스크와 책임을 지정합니다.
<P><B>파일 서버 시스템</B>
<A NAME="IDX5548"></A>
<A NAME="IDX5549"></A>
<P><I>파일 서버 시스템</I>은 분산 파일 시스템에 파일을 저장하고
이 파일 서버 시스템에서 실행되는 <I>서버 프로세스</I>는
파일을 전달하고 받습니다. AFS 파일 서버 시스템은 많은 수의
<I>서버 프로세스</I>를 실행합니다. 각 프로세스는 AFS 운영,
관리, 보안 또는 볼륨 처리에 중요한 데이터베이스를 관리하는 등의 특수한
기능을 가집니다. 이 모듈 방식의 디자인을 통해 각 서버 프로세스는 한 영역에서
특수하게 실행될 수 있으므로 보다 효율적으로 수행됩니다.
각 AFS 서버 프로세스의 기능에 대한 설명을 보려면
<A HREF="#HDRWQ17">AFS 서버 프로세스 및 캐쉬 관리 프로그램</A>을 참조하십시오.
<P>모든 AFS 서버 시스템이 모든 서버 프로세스를 실행해야 하는 것은 아닙니다.
일부 프로세스는 그 서비스 요구가 낮으므로 소수의 시스템에서만 실행됩니다.
다른 프로세스는 동기화 사이트로서 작동되기 위해 한 시스템에서만 실행됩니다.
<A HREF="auagd008.htm#HDRWQ90">파일 서버 시스템의 네 가지 역할</A>을 참조하십시오.
<P><B>클라이언트 시스템</B>
<A NAME="IDX5550"></A>
<P>다른 클래스의 시스템으로 사용자를 위해 직접 작동하여 컴퓨팅 능력과 다른
일반 목적의 도구를 제공하는 <I>클라이언트 시스템</I>을
들 수 있습니다. 또한 클라이언트는 사용자에게 파일 서버 시스템에 저장된
파일을 액세스할 수 있게 해 줍니다. 클라이언트는 기본적으로 특수 프로세스를
실행하지는 않으나 파일 서버 시스템에서 실행되는 AFS 서버 프로세스와 통신하고
파일을 캐쉬에 저장할 수 있게 하는 수정된 커널을 사용합니다.
이러한 커널 수정 모음을 <I>캐쉬 관리 프로그램</I>이라고도
합니다. <A HREF="#HDRWQ28">캐쉬 관리 프로그램</A>을 참조하십시오. 하나의 셀에는
보통 파일 서버 시스템보다 더 많은 수의 클라이언트 시스템이 있습니다.
<P><B>클라이언트 및 서버 구성</B>
<P>대부분의 전형적인 AFS 구성에서 파일 서버 시스템과 클라이언트 시스템은 모두
디스크 드라이브를 갖춘 고기능 워크스테이션입니다. 이 구성이 필수인 것은
아니지만 몇 가지 장점을 제공합니다. 
<A NAME="IDX5551"></A>
<P>파일 서버 시스템으로서 개인 워크스테이션을 사용할 때의 몇 가지 이점이
있습니다. 하나는 다른 파일 서버 시스템을 추가함으로써 네트워크를 쉽게
확장할 수 있다는 것입니다. 또한 기존 시스템에 디스크를 추가하여 저장장소를
쉽게 늘릴 수도 있습니다. 많은 강력한 메인프레임을 사용하는 것보다 워크스테이션을
사용하면 하나의 파일 서버 시스템을 사용하는 것보다 많은 파일 서버 시스템을
사용할 때 더 많은 경제적 이점을 얻을 수 있습니다. 복수의 파일 서버 시스템은
자주 사용되는 파일을 두 대 이상의 시스템에서 사용할 수 있는 경우 시스템
가용성과 신뢰성이 향상됩니다.
<P>클라이언트로서 워크스테이션을 사용할 때의 이점은 로컬 디스크에서
<I>캐슁</I>을 사용하는 것이 응용프로그램에 파일을 전달하는
속도를 높여준다는 것입니다. (캐슁에 대한 설명을 보려면
<A HREF="#HDRWQ16">캐슁 및 콜백</A>을 참조하십시오.)
디스크없는 시스템은 NFS<SUP>(R)</SUP> 및 AFS 분산의 선택적 구성요소인
NFS/AFS 변환 프로그램을 실행하고 있는 경우 AFS를 액세스할 수 있습니다.
<P><H3><A NAME="HDRWQ11" HREF="auagd002.htm#ToC_15">셀</A></H3>
<A NAME="IDX5552"></A>
<P><I>셀</I>은 AFS가 실행되는 독립적으로 관리되는 사이트입니다.
하드웨어의 측면에서 볼 때 셀은 셀에 속하는 것으로 정의된 파일 서버 시스템과
클라이언트 시스템의 모음으로 구성되며 하나의 시스템은 한 번에 하나의
셀에만 속할 수 있습니다. 또한 사용자는 셀에 계정을 가짐으로써 셀에 속하지만
시스템과는 달리 여러 셀에 속할 수 있습니다 (계정을 가질 수 있음).
셀이 독립적으로 관리된다고 말할 수 있는 것은 그 관리자가 다른 셀이나 중앙
기관의 관리자에게 문의하지 않고도 그 구성의 세부 사항을 결정할 수 있음을
의미합니다. 예를 들어 셀 관리자는 여러 다른 유형의 시스템이 실행되는 방식,
로컬 트리에서 파일을 배치할 위치, 볼륨과 디렉토리가 관련되어 있는 방식 및
각 사용자에게 할당될 공간을 결정합니다.
<P>용어 <I>로컬 셀</I>과 <I>홈 셀</I>은
같은 용어로 사용자가 해당 셀에 속해 있는 시스템에 로그온함으로써 세션 중에
처음에 인증을 받은 셀을 나타냅니다. 다른 모든 셀은 사용자의 관점에서 볼 때
<I>외부</I> 셀이 됩니다. 즉 전체 로그인 세션에서 사용자는
그 셀 구성원이 로컬 셀을 정의하는 단일 캐쉬 관리 프로그램--초기에
로그인한 시스템에 있는 프로그램--을 통해 파일 공간을 액세스합니다.
사용자가 추가 셀에서 인증을 받거나 <B>cd</B> 명령을 사용하여
디렉토리를 파일 트리로 변경하는 경우에도 다른 모든 셀은 해당 세션 중에 외부
셀로 간주됩니다. 
<A NAME="IDX5553"></A>
<A NAME="IDX5554"></A>
<A NAME="IDX5555"></A>
<A NAME="IDX5556"></A>
<P>하나의 지리적 위치에 둘 이상의 셀을 둘 수 있습니다. 예를 들어 대학교
캠퍼스나 기업의 여러 부서에서 자체의 셀을 관리하도록 선택할 수 있습니다.
또한 지리적으로 먼 사이트에 있는 시스템들이 동일한 셀에 속할 수 있습니다.
이러한 구조가 얼마나 현실적인가는 네트워크 통신 속도의 제한만 받습니다.
<P>그 독립성에도 불구하고 AFS 셀은 그 로컬 파일 공간을 다른 AFS 셀에서 볼 수
있게 하는 데 대체적으로 동의하기 때문에 다른 셀의 사용자들도 원하는 경우
파일을 공유할 수 있습니다. 셀이 "전역" AFS 이름 공간에 참여하려면
로컬 파일 공간이 구성되는 방식과 특정 파일 시스템의 주소가 외부 세계에서
어떻게 알려져 있는지를 제어하는 몇 가지 기본 규칙을 준수해야 합니다.
<P><H3><A NAME="HDRWQ12" HREF="auagd002.htm#ToC_16">균일 이름 공간 및 가시적 액세스</A></H3>
<A NAME="IDX5557"></A>
<A NAME="IDX5558"></A>
<P>AFS를 사용하기 쉽게 만들어 주는 특성 중 하나는 이 시스템이 셀의 파일 공간에
있는 파일에 대해 <I>가시적 액세스</I>를 제공한다는 것입니다.
사용자들은 파일을 액세스하기 위해 어떤 파일 서버 시스템에 파일이 저장되어
있는지 알 필요가 없으며 AFS에서 시스템 위치로 자동으로 변환하게 되는
파일의 경로명만 제공하면 됩니다.
<P>가시적 액세스와 함께 AFS는 <I>균일 이름 공간</I>을
생성합니다. 파일의 경로명은 사용자가 어떤 클라이언트 시스템에서 작업하고
있는지에 관계 없이 동일합니다. 셀의 파일 트리는 셀의 파일 서버 시스템이
모드 파일을 중앙에 저장하고 이들 파일을 모든 클라이언트에 동일한 방식으로
나타내기 때문에 클라이언트에서 볼 때 동일하게 보입니다.
<P>가시적 액세스 및 균일 이름 공간 기능을 사용 가능하게 하려면 시스템 관리자는
클라이언트 시스템과 파일 트리를 구성할 때 몇 가지 간단한 규칙을 따라야
합니다. 자세한 내용은 <A HREF="auagd007.htm#HDRWQ39">사용자의 셀에서 다른 셀을 볼 수 있게 만들기</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ13" HREF="auagd002.htm#ToC_17">볼륨</A></H3>
<A NAME="IDX5559"></A>
<P><I>볼륨</I>은 하나의 파일 서버 시스템 파티션에서 파일들을
모두 함께 보유하는 관련 파일 집합을 위한 개념적 컨테이너입니다.
볼륨은 다양한 크기를 가지지만 파티션보다는 더 작습니다.
볼륨은 AFS에서 기본 관리 단위로서 관리 작업을 좀더 쉽게 수행하고
전반적인 시스템 성능을 향상시키는 데 도움을 주는 몇 가지 특성을
가집니다.
<UL>
<LI>볼륨은 크기가 비교적 작기 때문에 한 파티션에서 다른 파티션으로 또는 시스템
사이에서도 쉽게 이동할 수 있습니다.
</LI><LI>볼륨을 이동하여 여러 시스템에서 로드 밸런스를 균일하게 유지함으로써
최대 효율을 유지할 수 있습니다. 하나의 파티션이 꽉 차면 개별 볼륨의 크기가
작기 때문에 다른 시스템에서 그 공간을 쉽게 찾을 수 있습니다. 
<A NAME="IDX5560"></A>
</LI><LI>각 볼륨은 논리적으로 파일 트리의 디렉토리에 해당하며 디렉토리의 파일을
구성하는 모든 데이터는 단일 파티션에 함께 보유됩니다. 각 사용자의 홈
디렉토리에 대해 별도의 볼륨을 유지할 경우 모든 사용자의 파일을 함께 보유하면서
다른 사용자의 파일과는 구분할 수 있습니다. 이것은 파티션이 가장 작은
저장 단위인 경우에는 불가능한 관리상의 이점이 됩니다. 
<A NAME="IDX5561"></A>
<P>
<A NAME="IDX5562"></A>
<P>
<A NAME="IDX5563"></A>
</LI><LI>디렉토리/볼륨 대응은 파일 위치 찾기 프로세스를 간편화해 주므로
가시적 파일 액세스를 가능하게 합니다. 한 디렉토리의 모든 파일은 하나의
볼륨에 함께 상주하며 파일을 찾기 위해 파일 서버는 파일 경로명에 포함된
정보인 파일의 상위 디렉토리 이름만 알면 됩니다. AFS는 디렉토리 이름을
볼륨 이름으로 변환하는 방법을 알고 있으며 볼륨이 한 시스템에서 다른 시스템으로
이동된 경우에도 각 볼륨의 위치를 자동으로 추적합니다. 디렉토리/볼륨
대응에 대한 자세한 정보를 보려면 <A HREF="#HDRWQ14">마운트 포인트</A>를 참조하십시오.
</LI><LI>볼륨은 복제 및 백업을 통해 파일 사용 효율을 높입니다.
<A NAME="IDX5564"></A>
<P>
<A NAME="IDX5565"></A>
</LI><LI>복제(둘 이상의 파일 서버 시스템에 한 볼륨의 사본을 배치하는 것)를
수행하면 내용을 좀더 신뢰성있게 사용할 수 있습니다.
<A HREF="#HDRWQ15">복제</A>를 참조하십시오.
전체 볼륨 집합은 테이프에 백업하고 파일로 복원할 수 있습니다.
<A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및 <A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
AFS에서 백업은 또한 특정 시점에 볼륨 상태를 기록한 다음 포함된 파일이 우연히
삭제되었거나 변경되었을 때 이를 복구하기 위해 저장(테이프나 파일 시스템의
다른 위치에)하는 것을 의미하기도 합니다.
<A HREF="auagd010.htm#HDRWQ201">백업 볼륨 작성</A>을 참조하십시오.
</LI><LI>볼륨은 자원 관리의 단위입니다. 각 볼륨 집합과 관련된 공간 할당량에
따라 최대 볼륨 크기에 대한 한계가 설정됩니다. <A HREF="auagd010.htm#HDRWQ234">볼륨 할당량과 현재 크기 설정 및 표시</A>를 참조하십시오. 
<A NAME="IDX5566"></A>
</LI></UL>
<P><H3><A NAME="HDRWQ14" HREF="auagd002.htm#ToC_18">마운트 포인트</A></H3>
<A NAME="IDX5567"></A>
<P>앞 절에서는 각 볼륨이 논리적으로 어떻게 파일 시스템의 디렉토리에 대응되는지
살펴 보았습니다. 볼륨은 디렉토리의 파일에 있는 모든 데이터를 하나의
파티션에 함께 보유됩니다. 볼륨에 해당하는 디렉토리를 <I>루트
디렉토리</I>라고 하며 디렉토리와 볼륨을 연관짓는 메카니즘을
<I>마운트 포인트</I>라고 합니다. 마운트 포인트는 파일 트리에서
디렉토리에 보존된 파일을 포함하는 볼륨을 지정하는 기호적인 연결과 유사합니다.
마운트 포인트는 실제적인 기호적인 연결은 아닙니다. 그 내부 구조는 다릅니다.
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">그 이름이 숫자 기호(#)나 퍼센트 기호(%)로 시작되는 파일로의
기호적인 연결을 작성하며 안됩니다. 왜냐하면 캐쉬 관리 프로그램은 이러한 연결을
각각 일반 또는 읽기/쓰기 볼륨으로의 마운트 포인트로 해석하기 때문입니다.
</TD></TR></TABLE>
<P>
<A NAME="IDX5568"></A>
<A NAME="IDX5569"></A>
<A NAME="IDX5570"></A>
<A NAME="IDX5571"></A>
<P>마운트 포인트를 사용한다는 것은 표준 UNIX 파일 시스템 디렉토리와 같이 보이고
기능하는 AFS 파일 트리의 많은 요소가 실제 마운트 포인트라는 것을 의미합니다.
형식상, 마운트 포인트는 디렉토리의 파일 데이터를 포함하는 볼륨을 명명하는
한 행으로 된 파일입니다. 캐쉬 관리 프로그램(<A HREF="#HDRWQ28">캐쉬 관리 프로그램</A> 참고)이
마운트 포인트--예를 들면 경로명을 해석하는 과정에서--을 만나면
마운트 포인트에 명명된 볼륨을 조사합니다. 이 볼륨에서 캐쉬 관리 프로그램은
디렉토리/볼륨에 포함된 파일을 나열하는 실제의 UNIX 스타일 디렉토리 요소--
볼륨의 루트 디렉토리--를 찾습니다. 경로 이름의 다음 요소는 이 목록에
나타납니다.
<P>볼륨은 볼륨을 가리키는 마운트 포인트가 있는 파일 트리의 지점에
<I>마운트된</I> 것으로 표현됩니다. 볼륨의 내용은
마운트되어야만 보거나 액세스할 수 있습니다.
<P><H3><A NAME="HDRWQ15" HREF="auagd002.htm#ToC_19">복제</A></H3>
<A NAME="IDX5572"></A>
<A NAME="IDX5573"></A>
<P><I>복제</I>는 원본 읽기/쓰기 볼륨의 사본이나
<I>클론</I>을 만든 다음 이 사본을 셀의 하나 이상의 추가
파일 서버 시스템에 배치하는 것을 의미합니다. 볼륨을 복제할 때의 한 가지
이점은 내용의 사용 효율이 증가된다는 것입니다. 볼륨이 있는 하나의 파일
서버에 장애가 발생하면 사용자는 다른 시스템에 있는 볼륨을 여전히 액세스할 수
있습니다. 이 파일을 여러 시스템에서 사용할 수 있으므로 어떠한 시스템도 특정
파일에 대한 요청으로 인해 과부하되지 않습니다.
<P>복제는 제한된 디스크 공간 내의 셀에 적절한 것이 아니며 모든 유형의 볼륨이
모두 동일하게 복제에 적절한 것도 아닙니다(복제는 자주 변경되지 않으면서
자주 사용되는 파일을 포함하는 볼륨에 가장 적절함).
자세한 정보를 보려면 <A HREF="auagd007.htm#HDRWQ50">볼륨 복제 시기</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ16" HREF="auagd002.htm#ToC_20">캐슁 및 콜백</A></H3>
<A NAME="IDX5574"></A>
<P>복제가 시스템 사용 효율을 높이는 것처럼 <I>캐슁</I> 역시
AFS에서 파일 액세스의 속도와 효율을 높여 줍니다. 각 AFS 클라이언트 시스템은
데이터를 일시적으로 저장하는 <I>캐쉬</I>로 그 로컬 디스크나
메모리의 일부를 전용으로 지정합니다. 클라이언트 시스템에서 실행되는
응용프로그램(예: 문서 편집기)이 AFS 파일로부터 데이터를 요청할 때마다
이 요청은 캐쉬 관리 프로그램을 통해 전달됩니다. 캐쉬 관리 프로그램은
로컬 응용프로그램의 파일 요청을 해당 파일을 저장하는 파일 서버 시스템에서
실행되는 <I>파일 서버 프로세스</I>에 대한 크로스 네트워크
요청으로 변환하는 클라이언트 시스템의 커널 부분입니다.
캐쉬 관리 프로그램은 파일 서버로부터 요청된 파일을 받아 이를 캐쉬에
저장한 다음 응용프로그램에 전달합니다.
<P>캐슁은 다음과 같은 방식으로 응용프로그램으로의 데이터 전달 속도를
향상시킵니다.
<UL>
<LI>응용프로그램이 동일한 파일의 데이터를 반복적으로 요청할 때 이 데이터가
이미 로컬 디스크에 존재합니다. 응용프로그램은 캐쉬 관리 프로그램이 파일
서버로부터 데이터를 요청하고 받을 때까지 기다릴 필요가 없습니다.
</LI><LI>데이터를 캐쉬에 저장하면 동일한 데이터에 대한 반복 요청 및 전송이
필요하지 않게 되므로 네트워크 통신량이 줄어듭니다. 따라서 초기 요청과
다른 통신량이 보다 빠르게 처리될 수 있습니다. 
<A NAME="IDX5575"></A>
<A NAME="IDX5576"></A>
<P>
<A NAME="IDX5577"></A>
</LI></UL>
<P>
<A NAME="IDX5578"></A>
<P>
<A NAME="IDX5579"></A>
 캐슁이 많은
이점을 제공하기는 하지만 파일의 많은 캐쉬 사본과 원본 간의 일관성을 유지하는
문제가 발생합니다. 이 문제는 <I>콜백</I>이라고 하는
메카니즘으로 해결됩니다.
<P>콜백은 파일 서버에서 전달한 데이터가 변경될 때 캐쉬 관리 프로그램에게
그 정보를 전달하겠다는 파일 서버의 작용입니다.
콜백은 다음과 같이 파일 서버가 전달한 파일의 유형에 따라 다르게 사용됩니다.
<UL>
<LI>파일 서버는 쓸 수 있는 파일 사본(읽기/쓰기 볼륨에서 복사한)을 캐쉬
관리 프로그램에 전달할 때 해당 파일과 함께 콜백도 보냅니다. 파일 원본을
다른 사용자가 변경하면 파일 서버는 해당 파일의 캐쉬된 버전과 연관된 콜백을
파괴하여 캐쉬된 사본을 업데이트해야 함을 캐쉬 관리 프로그램에 알립니다.
</LI><LI>파일 서버는 읽기 전용 볼륨의 파일을 캐쉬 관리 프로그램에 전달할 때
전체 볼륨과 관련된 콜백도 함께 보냅니다(따라서 볼륨에서 추가 파일을
전달할 때는 다른 콜백을 보낼 필요가 없음). 읽기 전용 볼륨의 파일은
새로운 버전의 전체 볼륨이 릴리스될 때만 변경될 수 있으므로 액세스되는
읽기 전용 볼륨당 한 번의 콜백이 필요합니다. 이전 버전의 볼륨과 연관된
모든 콜백은 릴리스 시에 파괴됩니다.
</LI></UL>
<P>이러한 콜백 메카니즘을 통해 캐쉬 관리 프로그램은 항상 가장 최신 버전의
파일을 요청하게 됩니다. 그러나 캐쉬 관리 프로그램이 가장 최신 버전을
가지게 되는 즉시, 사용자가 이것을 알게 되는 것은 아닙니다. 이것은 응용프로그램이
파일 시스템에서 추가 데이터를 요청하는 빈도나 캐쉬 관리 프로그램을 사용하여
데이터를 확인하는 빈도에 따라 달라집니다.
<HR><H2><A NAME="HDRWQ17" HREF="auagd002.htm#ToC_21">AFS 서버 프로세스 및 캐쉬 관리 프로그램</A></H2>
<A NAME="IDX5580"></A>
<A NAME="IDX5581"></A>
<P><A HREF="#HDRWQ10">서버 및 클라이언트</A>에 언급된 것처럼 AFS 파일 서버 시스템은 많은 수의
프로세스를 실행하며 각각은 특수한 기능을 가집니다. 시스템 관리자의 기본
책임 중 하나는 가능한 시간의 회수만큼 프로세스가 올바르게 실행되게 하여
서버 프로세스가 제공하는 관리 서비스를 사용하는 것입니다.
<P>다음 목록은 각 서버 프로세스와 캐쉬 관리 프로그램의 기능을 설명하고 있습니다.
다음 절에서 중요한 기능들을 보다 상세히 설명합니다.
<P>가장 기본적인 서버인 <I>파일 서버</I>는 요청될 때 파일 서버
시스템에서 로컬 워크스테이션으로 데이터 파일을 전달하고 사용자가 파일 변경을
저장할 때 해당 파일을 다시 저장합니다.
<P><I>BOS(Basic OverSeer Server)</I>는 이 프로그램이 사용
가능할 경우에만 서버가 유용하므로 서버 시스템의 다른 서버 프로세스가 가능한
한 오래동안 제대로 실행될 수 있게 하는 역할을 합니다.
BOS 서버는 시스템 조작을 감독해야 하는 시스템 관리자의 책임을 많이 덜어줍니다.
<P><I>인증 서버</I>는 네트워크 상에서 보안 통신이 유지되도록
도와 줍니다. 이 서버는 로그인 시 사용자 신원을 확인하고 트랜잭션 참여자들이
다른 사용자에게 자신의 신원을 입증하는 기능(상호 인증)을 제공합니다.
이 서버는 인증 데이터베이스를 유지합니다.
<P><I>보호 서버</I>는 그 파일 및 디렉토리에 대한 액세스 권한이
있는 사람을 제어할 수 있게 해 줍니다. 사용자들은 다른 사용자들을 보호 서버가
관리하는 보호 데이터베이스의 그룹 항목에 추가하여 다른 사용자들에게 액세스
권한을 부여할 수 있습니다.
<P><I>볼륨 서버</I>는 모든 유형의 볼륨을 처리합니다.
이 서버는 관리자가 한 서버 시스템에서 다른 서버 시스템으로 볼륨을 이동하여
다양한 시스템에서 작업 로드의 균형을 이룰 수 있게 도와 줍니다.
<P><I>볼륨 위치 서버(VL 서버)</I>는 VLDB(Location Database)를
관리하는 데 여기에는 볼륨을 한 파일 서버 시스템에서 다른 파일 서버 시스템으로
옮길 때 해당 볼륨의 위치가 기록됩니다. 이 서비스는 사용자의 가시적 파일
액세스에 있어서 핵심적인 요소가 됩니다.
<P><I>갱신 서버</I>는 새 버전의 AFS 서버 프로세스 소프트웨어와
구성 정보를 모든 파일 서버 시스템으로 분배합니다.
모든 서버 시스템이 동일한 소프트웨어를 실행하는 것은 시스템 성능을
안정시키는 데 있어서 중요합니다.
<P><I>백업 서버</I>는 백업 데이터베이스를 관리하는 데 여기에
백업 시스템과 관련된 정보를 저장합니다. 이 서버는 관리자가 볼륨에서 테이프로
데이터를 백업할 수 있게 합니다. 그런 다음 데이터는 파일 시스템에서 유실될
경우 테이프에서 복원될 수 있습니다.
<P><I>구조 프로그램</I>은 다른 서버와 같은 개념으로 볼 때
서버가 아닙니다. 이 프로그램은 파일 서버나 볼륨 서버가 실패한 후에만
실행되어 장애로 발생한 불일치 상태를 수리합니다. 시스템 관리자는
필요할 때 직접 이 프로그램을 호출할 수 있습니다.
<P><I>NTPD(Network Time Protocol Daemon)</I>는 AFS 서버
프로세스가 아니지만 중요한 역할을 합니다. 이것은 다른 시스템의 시계와
파일 서버 시스템의 내부 시계를 동기화합니다.
동기화된 시계는 AFS 분산 데이터베이스 기술(<I>Ubik</I>)의
올바른 작동에 있어서 특히 중요합니다 (<A HREF="auagd008.htm#HDRWQ103">적절한 Ubik 작업을 위한 셀 구성</A> 참고).
NTPD는 <B>runntp</B> 프로세스에 의해 제어됩니다.
<P><I>캐쉬 관리 프로그램</I>은 파일 서버 시스템이 아닌 AFS
클라이언트에 위치하는 이 목록의 한 구성요소입니다. 이 프로그램은 프로세스는
아니지만 AFS 서버 프로세스와 통신하는 AFS 클라이언트 시스템에 있는 커널의
일부입니다. 그 기본 책임은 클라이언트에서 실행되는 응용프로그램에 대한
파일을 검색하고 이 파일을 캐쉬에 유지하는 것입니다.
<P><H3><A NAME="HDRWQ18" HREF="auagd002.htm#ToC_22">파일 서버</A></H3>
<A NAME="IDX5582"></A>
<P><I>파일 서버</I>는 AFS 서버 프로세스의 가장 기본적인
부분이며 각 파일 서버 시스템에서 실행됩니다. 이 서버는 로컬 디스크에
UNIX 파일 시스템이 제공하는 것과 동일한 서비스를 네트워크에 제공합니다.
<UL>
<LI>요청될 때 클라이언트 워크스테이션에 프로그램 및 데이터 파일을 전달하고
클라이언트 워크스테이션이 그 사용을 끝냈을 때 다시 저장.
</LI><LI>사용자가 그 파일을 구성하기 위해 작성하는 계층형 디렉토리 구조 유지.
</LI><LI>파일 및 디렉토리 복사, 이동, 작성 및 삭제를 위한 요청 처리.
</LI><LI>각 파일 및 디렉토리에 대한 상태 정보 (크기와 마지막 수정 시간 포함) 추적.
</LI><LI>사용자가 특정 파일이나 디렉토리에 대해 요청한 조치를 수행할 수 있는
권한을 가지는지 확인.
</LI><LI>파일 사이에 기호 및 하드 연결 작성.
</LI><LI>요청에 대해 권장 잠금 (UNIX 잠금에 해당) 부여.
</LI></UL>
<P><H3><A NAME="HDRWQ19" HREF="auagd002.htm#ToC_23">BOS(Basic OverSeer) 서버</A></H3>
<A NAME="IDX5583"></A>
<P><I>BOS(Basic OverSeer) 서버</I>는 파일 서버 시스템에서
실행되는 프로세스를 계속 모니터하여 시스템 관리자에 대한 수요를 줄여 줍니다.
이 서버는 실패한 프로세스를 자동으로 재시작할 수 있으며 관리 타스크를 위한
편리한 인터페이스를 제공합니다.
<P>BOS 서버는 모든 파일 서버 시스템에서 실행됩니다. 그 기본 기능은 시스템
작동 정지를 최소화하는 것입니다. 또한 다음 기능도 수행합니다.
<UL>
<LI>(로컬 시스템의) 다른 서버 프로세스를 계속 모니터하여 제대로 실행되고
있는지 확인합니다.
</LI><LI>작업자를 요청하지 않고도 실패한 프로세스를 자동으로 재시작합니다.
복수의 서버 프로세스를 동시에 재시작하면 BOS 서버는 상호 종속성을 고려하고
올바른 순서대로 재시작을 초기화합니다.
<A NAME="IDX5584"></A>
<P>
<A NAME="IDX5585"></A>
</LI><LI>시스템 관리자의 요청을 승인합니다. BOS에 접속하는 일반적인 이유는
파일 서버 시스템의 서버 프로세스 상태를 확인하고, 새로운 프로세스를 설치 및
시작하고, 프로세스를 일시적으로나 영구적으로 정지하고, 중단된 프로세스를
수동으로 재시작하기 위한 것입니다.
</LI><LI>시스템 관리자가 시스템 구성 정보를 관리하는 데 도움을 줍니다.
BOS 서버는 상호 인증에서 중요한 요소인 <I>서버 암호화
키</I> 추가 및 변경 프로세스를 자동화합니다.
또한 BOS 서버는 권한 있는 사용자와 특수 파일 서버 시스템에 대한 정보를
포함하는 두 파일을 수정하기 위한 간단한 인터페이스를 제공합니다.
이들 구성 파일에 대한 자세한 정보를 보려면 <A HREF="auagd008.htm#HDRWQ85">/usr/afs/etc 디렉토리의 일반 구성 파일</A>을
참조하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ20" HREF="auagd002.htm#ToC_24">인증 서버</A></H3>
<A NAME="IDX5586"></A>
<P><I>인증 서버</I>는 네트워크 보안과 관련된 두 가지 기본
기능을 수행합니다.
<UL>
<LI>사용자에게 암호를 제공하도록 요구함으로써 사용자가 시스템에 로그인할
때 사용자의 신원을 확인. 인증 서버는 사용자가 인증을 받은 AFS 서버
프로세스에 대한 증거로서 사용자에게 <I>토큰</I>을
부여합니다. 토큰에 대한 자세한 정보를 보려면
<A HREF="auagd007.htm#HDRWQ76">복합 상호 인증</A>을 참조하십시오.
</LI><LI>서버 및 클라이언트 프로세스가 서로에게 자신을 입증하는 수단
제공(상호 인증). 이것은 크로스 네트워크 메시지를 보낼 수 있는 보안 환경을
만드는 데 도움을 줍니다.
</LI></UL>
<P>인증 서버는 이러한 의무를 수행할 때 <I>Kerberos</I>(따라서
인증 서버에 접속하는 데 사용되는 많은 명령들이 문자 <B>k</B>로
시작됨)로 알려져 있는 알고리즘과 기타 절차들을 활용합니다. 이 기술은
원래 MIT Project Athena에서 개발했습니다.
<P>또한 인증 서버는 <I>인증 데이터베이스</I>를 유지하는 데
여기에 AFS 서버 암호화 키 뿐 아니라 암호화 키 양식으로 변환되는 사용자
암호를 저장합니다. AFS에서 상호 인증 중에 사용자 신원을 확인하는 절차에
대한 자세한 정보를 보려면 <A HREF="auagd007.htm#HDRWQ75">상호 인증에 대한 상세한 설명</A>을 참조하십시오.
<A NAME="IDX5587"></A>
<A NAME="IDX5588"></A>
<A NAME="IDX5589"></A>
<A NAME="IDX5590"></A>
<P><H3><A NAME="HDRWQ21" HREF="auagd002.htm#ToC_25">보호 서버</A></H3>
<A NAME="IDX5591"></A>
<A NAME="IDX5592"></A>
<A NAME="IDX5593"></A>
<P><I>보호 서버</I>는 권한 없는 사용으로부터 파일과
디렉토리를 보호하기 위한 일반적인 UNIX 메소드를 AFS 방식으로 구현한 것입니다.
이러한 구현 방식에는 다음이 포함됩니다.
<UL>
<LI>표준 UNIX 파일 시스템의 3가지 대신 7가지 액세스 권한 정의. AFS는
각 파일 및 디렉토리 요소와 연관된 UNIX 모드 비트와 함께
<I>액세스 제어 목록(ACL)</I>을 각 디렉토리에 연관짓습니다.
ACL은 어떤 사용자가 디렉토리와 이 디렉토리의 모든 파일에 대한 7가지 특정
권한 중 어떤 권한을 가지는지 지정합니다.
AFS의 7가지 액세스 권한의 정의와 사용자가 액세스 제어 목록에 대해 이들
권한을 어떻게 설정할 수 있는지 보려면 <A HREF="auagd020.htm#HDRWQ562">액세스 제어 목록 관리</A>를
참조하십시오. 
<A NAME="IDX5594"></A>
</LI><LI>사용자가 많은 개별 사용자에게 권한을 부여할 수 있게 하기--
원할 경우 각 개인에게 다른 권한 조합 부여. UNIX 보호 기능은 파일의 소유자,
지정된 단일 그룹의 구성원 및 로컬 파일 시스템을 액세스할 수 있는 모든
사용자와 같이 세 가지 사용자 또는 그룹 사이만을 구별합니다.
</LI><LI>보호 서버에서 유지하는 <I>보호 데이터베이스</I>에
기록된 사용자 자체 그룹을 사용자가 정의할 수 있게 하기.
이들 그룹은 마치 개인인 것처럼 많은 사용자에게 동시에 권한을 부여할 수
있게 하는 디렉토리의 액세스 제어 목록에 나타납니다.
</LI><LI>시스템 관리자가 클라이언트 시스템 IP 주소를 포함하는 그룹을 작성하여
지정된 클라이언트 시스템에서 시작되는 액세스를 허용할 수 있게 하기.
이러한 유형의 그룹은 시스템 기반 사용권 제한을 따라야 할 경우에
유용합니다.
</LI></UL>
<A NAME="IDX5595"></A>
<A NAME="IDX5596"></A>
<P>보호 서버의 기본 의무는 사용자가 요청된 방식으로 파일을 액세스할 수 있는
권한을 가지는지 파일 서버에서 확인하는 데 도움을 주는 것입니다. 보호 서버는
사용자가 속해 있는 모든 그룹의 목록을 작성합니다. 그런 다음 파일 서버는
이 목록을 파일의 상위 디렉토리와 연관된 ACL과 비교합니다. 따라서 사용자는
개인으로서의 액세스 권한과 그룹의 구성원으로서 액세스 권한을 모두 필요로 합니다.
<P>또한 보호 서버는 <I>username</I>(로그인 프롬프트에
입력된 이름)를 <I>AFS 사용자 ID</I>
번호(<I>AFS UID</I>)에 대응합니다. 이들 UID는 기능적으로
UNIX UID와 동일하지만 시스템 로컬 디스크의 UNIX 파일 시스템이 아닌 AFS의
도메인에서 작동됩니다. 이 변환 서비스는 인증 서버가 인증된 사용자에게 부여하는
토큰에 username이 붙어 있으므로 (Kerberos 표준을 준수하기 위해) 필수적입니다.
AFS 서버는 username이 아닌 AFS UID에 의해 사용자를 식별합니다. 토큰이
누구를 나타내는지 이해하려면 먼저 username을 AFS UID로 변환하기 위해
보호 서버가 필요합니다. 토큰에 대한 자세한 설명을 보려면
<A HREF="auagd007.htm#HDRWQ75">상호 인증에 대한 상세한 설명</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ22" HREF="auagd002.htm#ToC_26">볼륨 서버</A></H3>
<A NAME="IDX5597"></A>
<P><I>볼륨 서버</I>는 볼륨을 테이프나 다른 매체에 보존(백업)하기
위해 준비하고, 작성, 삭제, 이동 및 복제할 때 사용하는 인터페이스를
제공합니다. <A HREF="#HDRWQ13">볼륨</A>에서는 볼륨에 파일을 저장하여
얻어지는 이점을 설명합니다. 볼륨을 작성하고 삭제하는 것은 시스템 볼륨에
사용자를 추가하거나 제거할 경우 필요합니다. 로드 밸런스를 위해 볼륨 이동이
수행되고 복제를 통해 복수의 파일 서버 시스템에 볼륨이 배치됩니다(복제에
대한 정보는 <A HREF="#HDRWQ15">복제</A> 참고).
<P><H3><A NAME="HDRWQ23" HREF="auagd002.htm#ToC_27">볼륨 위치(VL) 서버</A></H3>
<A NAME="IDX5598"></A>
<A NAME="IDX5599"></A>
<P><I>VL 서버</I>는 <I>VLDB(Location Database)</I>에 완전한 볼륨 위치 목록을 유지합니다.
캐쉬 관리 프로그램(<A HREF="#HDRWQ28">캐쉬 관리 프로그램</A> 참고)은 응용프로그램의
파일 요청을 채우기 시작할 때 먼저 현재 파일을 포함하는 볼륨이 있는 파일 서버
시스템을 알기 위해 먼저 VL 서버에 접속합니다. 그런 다음 캐쉬 관리 프로그램은
해당 파일 서버 시스템에서 실행되는 파일 서버 프로세스로부터 파일을
요청합니다.
<P>VLDB 및 VL 서버는 캐쉬 관리 프로그램이 특정 파일을 찾아야 할 위치를
알고 있기 때문에 AFS가 복수의 파일 서버 시스템을 사용함으로써 증가된 시스템
가용성을 활용할 수 있게 해 줍니다. 실제로 어떤 견지에서 본다면
VL 서버는 전체 파일 시스템의 근본 원리라고 할 수 있습니다.
왜냐하면 VLDB의 정보를 액세스할 수 없을 때 캐쉬 관리 프로그램은
파일 서버 프로세스가 제대로 작동하는 경우에도 파일을 검색할 수 없기
때문입니다. 각 볼륨에 대해 VLDB에 저장된 정보 목록은
<A HREF="auagd010.htm#HDRWQ180">VLDB의 볼륨 정보</A>에 제공됩니다.
<A NAME="IDX5600"></A>
<P><H3><A NAME="HDRWQ24" HREF="auagd002.htm#ToC_28">갱신 서버</A></H3>
<A NAME="IDX5601"></A>
<P><I>갱신 서버</I>는 모든 파일 서버 시스템이 동일한 서버
프로세스 버전을 실행하고 있는지 확인하는 데 도움을 줍니다. 일부 시스템에서
하나의 BOS 서버 버전을 실행하고 있고 다른 시스템에서 다른 버전을 실행하고
있으면 시스템 성능이 일관되지 못할 수 있습니다.
<P>모든 시스템이 하나의 프로세스의 동일한 버전을 실행하게 하려면
각 유형에 대해 <I>2진 분산 시스템</I>이라고 하는
단일 파일 서버 시스템에 새 소프트웨어를 설치하십시오.
이 2진 분산 시스템에는 갱신 서버의 <I>서버 부분</I>이
실행되고 해당 유형을 가진 다른 모든 시스템에서는 갱신 서버의 <I>클라이언트 부분</I>이 실행됩니다. 이 클라이언트 부분은 서버 부분을 자주
확인하여 모든 프로세스의 올바른 버전을 실행하고 있는지 확인합니다.
그렇지 못한 경우 클라이언트 부분은 2진 분산 시스템에서 올바른 버전을
검색하여 이를 로컬로 설치합니다. 시스템 관리자는 모든 파일 서버 시스템에
개별적으로 새 소프트웨어를 설치할 필요가 없습니다. 갱신 서버가 자동으로
설치를 수행해 줍니다. 2진 분산 시스템에 대한 자세한 정보를 보려면
<A HREF="auagd008.htm#HDRWQ93">2진 분산 시스템</A>을 참조하십시오. 
<A NAME="IDX5602"></A>
<P>
<A NAME="IDX5603"></A>
<P>미국판 AFS가 실행되는 셀에서 갱신 서버는 또한 모든 파일 서버 시스템이
로컬 디스크에 저장해야 하는 구성 파일을 분산합니다(이들 파일의 내용과
목적에 대한 설명을 보려면 <A HREF="auagd008.htm#HDRWQ85">/usr/afs/etc 디렉토리의 일반 구성 파일</A>을 참조하십시오).
서버 프로세스 소프트웨어와 마찬가지로 일관된 시스템 성능을 유지하기 위해서는
모든 시스템이 이들 파일의 동일한 버전을 가지고 있어야 합니다. 미국판을
사용할 경우 시스템 관리자는 이들 파일을 갱신 서버의 서버 부분이 실행되는
셀의 <I>시스템 제어 시스템</I>인 한 시스템에서만 이들
파일을 변경해야 합니다. 셀의 다른 모든 시스템은 시스템 제어 시스템으로부터
이들 구성 파일의 올바른 버전을 액세스하는 클라이언트 부분을 실행합니다.
각국 언어판 AFS가 실행되는 셀은 구성 파일을 분배하기 위해 시스템 제어 시스템을
사용하지 않습니다. 자세한 내용은 <A HREF="auagd008.htm#HDRWQ94">시스템 제어 시스템</A>을
참조하십시오
<P><H3><A NAME="HDRWQ25" HREF="auagd002.htm#ToC_29">백업 서버</A></H3>
<A NAME="IDX5604"></A>
<A NAME="IDX5605"></A>
<P><I>백업 서버</I>는 <I>백업
데이터베이스</I>의 정보를 유지합니다. 백업 서버와 백업 데이터베이스를
통해 관리자는 AFS 볼륨의 데이터를 테이프로 백업하고 필요할 때 테이프에서
파일 시스템으로 데이터를 복원할 수 있습니다. 백업 서버와 백업 데이터베이스를
함께 <I>백업 시스템</I>이라고 합니다.
<P>초기에 관리자는 함께 덤프될 볼륨 집합과 볼륨 집합이 덤프될 일정을 정의하여
백업 시스템을 구성합니다. 또한 시스템의 테이프 드라이브를 설치하고
테이프 드라이브를 제어하는 프로세스인 드라이브의
<I>테이프 조정자</I>를 정의합니다.
<P>일단 백업 시스템이 구성되면 사용자 및 시스템 데이터는 볼륨에서 테이프로
덤프될 수 있습니다. 데이터가 시스템에서 유실되는 경우(예: 시스템이나
디스크 장애로 인해 데이터가 유실될 경우) 관리자는 테이프에서 데이터를
복원할 수 있습니다. 테이프가 주기적으로 보존되거나 저장될 경우 데이터는
특정 시점의 상태로 복원될 수 있습니다. 또한 백업 시스템 데이터는
재생하기 어려우므로 백업 데이터베이스 자체가 테이프로 백업되고
손상될 경우 복원될 수 있습니다. 백업 시스템 구성 및 사용에 대한 자세한
정보를 보려면 <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및 <A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ26" HREF="auagd002.htm#ToC_30">구조 프로그램</A></H3>
<A NAME="IDX5606"></A>
<P><I>구조 프로그램</I>은 선택된 시간에만 실행된다는
점에서 다른 AFS 서버와 다릅니다. BOS 서버는 파일 서버, 볼륨 서버 또는
두 서버 모두에서 오류가 발생할 때 구조 프로그램을 호출합니다. 구조 프로그램은
장애로 인해 유발될 수 있는 디스크 손상을 수리하려고 시도합니다.
<P>시스템 관리자라면 파일 서버나 볼륨 서버에 장애가 발생하지 않은 경우에도
필요할 때 구조 프로그램을 호출할 수 있습니다.
<A HREF="auagd010.htm#HDRWQ232">볼륨 구조</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ27" HREF="auagd002.htm#ToC_31">NTPD(Network Time Protocol Daemon)</A></H3>
<A NAME="IDX5607"></A>
<P><I>NTPD(Network Time Protocol Daemon)</I>는 AFS 서버
프로세스가 아니지만 중요한 역할을 합니다. 이것은 모든 파일 서버 시스템이
해당 시간에 동일한 상태에 있도록 합니다. 한 파일 서버 시스템의 NTPD는
동기화 사이트로서 기능하여 보통 셀 외부의 소스로부터 올바른 시간을
확인합니다. 다른 파일 서버 시스템의 NTPD는 이 동기화 사이트를 참조하여
자체 시스템의 내부 시계를 설정합니다.
<P>시계를 동기 상태로 유지하는 일은 인증, 백업, 보호 및 볼륨 위치
데이터베이스 사본을 조정하는 AFS의 분산 데이터베이스 기술의 올바른
작동을 위해 특히 중요합니다. <A HREF="auagd007.htm#HDRWQ52">AFS 관리 데이터베이스 복제</A>를 참조하십시오.
또한 클라이언트 시스템도 이들 시계에서 올바른 시간을 참조합니다.
모든 파일 서버 시스템이 올바른 시간으로 설정되어 있으면 덜 혼란스러울
것입니다. NTPD에 대한 자세한 기술 정보를 보려면
<A HREF="auagd009.htm#HDRWQ151">runntp 프로세스</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ28" HREF="auagd002.htm#ToC_32">캐쉬 관리 프로그램</A></H3>
<A NAME="IDX5608"></A>
<P><A HREF="#HDRWQ16">캐슁 및 콜백</A>에서 이미 언급한 것처럼 <I>캐쉬 관리 프로그램</I>은 파일 서버 시스템이 아닌 클라이언트 시스템에
위치하는 이 섹션의 한 구성요소입니다. 이 프로그램은 기술적으로 독립형
프로세스가 아니지만 서버 시스템에서 실행되는 서버 프로세스와의 통신을
가능하게 하는 클라이언트 시스템 커널의 확장 또는 수정 기능 집합입니다.
그 주요 의무는 파일 요청(클라이언트 시스템의 응용프로그램이 생성)을
파일 서버로의 원격 프로시듀어 호출(RPC)로 변환하는 것입니다(먼저 캐쉬
관리 프로그램은 <A HREF="#HDRWQ23">볼륨 위치(VL) 서버</A>에서 설명하는
것처럼 VL 서버에 접속하여 현재 요청된 파일을 포함하는 볼륨을 관장하는
파일 서버를 찾습니다). 캐쉬 관리 프로그램은 요청된 파일을 받아 데이터를
응용프로그램에 전달하기 전에 먼저 캐쉬합니다.
<P>캐쉬 관리 프로그램은 또한 파일 서버가 보낸 콜백을 저장하여 파일 서버에
있는 파일 버전과 비교하여 캐쉬의 파일 상태를 추적합니다. 파일 서버가
파일이나 볼륨이 변경되었음을 나타내는 콜백을 파괴하면 캐쉬 관리 프로그램은
더 많은 데이터를 응용프로그램에 제공하기 전에 새 버전의 파일 사본을 요청합니다.
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd005.htm">이전 페이지</A> &#124; <A HREF="auagd007.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B> 
<!-- Begin Footer Records  ========================================== -->
<P><HR><B> 
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved 
</B> 
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
